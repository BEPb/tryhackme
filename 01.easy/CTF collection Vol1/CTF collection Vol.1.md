

[>> вернуться на главную страницу](https://github.com/BEPb/tryhackme/blob/master/README.md)

# Комната [CTF collection Vol.1](https://tryhackme.com/r/room/ctfcollectionvol1) 
 CTF Collection Vol 1 состоит из тщательно подобранного набора простых задач, которые охватывают некоторые базовые 
 навыки, необходимые любому начинающему игроку CTF. 

Некоторые из затронутых тем включают преобразование базовых чисел, стеганографию изображений, декодирование 
различных схем кодирования, подстановочные шифры, OSINT и многое другое.  

Первая коллекция состоит из 20 заданий и предлагает прогрессивный путь обучения, начинающийся с чрезвычайно простых, 
доступных новичкам задач и постепенно усложняющийся, что позволяет игрокам оттачивать свои навыки CTF в удобном для 
них темпе.  

Всего 21 заданиe:
## Задание 1
Просто еще одна случайная комната CTF, созданная мной. Ну, главная цель комнаты — проверить ваши навыки CTF. К 
вашему сведению, том 1 состоит из 20 заданий, и все испытания чрезвычайно легкие. Сохраняйте спокойствие и захватите 
флаг. :)  

Примечание: все флаги задач имеют формат, если не указано иное.THM{flag}

### Ответьте на вопросы ниже
Дай пять!
```commandline
Ответ не нужен
```

## Задание 2
Можете ли вы расшифровать следующее?

VEhNe2p1NTdfZDNjMGQzXzdoM19iNDUzfQ==

### Ответьте на вопросы ниже
Дай мне флаг!

Это похоже на сообщение, закодированное в Base64 . Чтобы определить это, вы обычно ищете строку символов, состоящую 
из комбинации заглавных и строчных букв, цифр, « + » или « / », и обычно заканчивающуюся или передаваемую символом « 
= ».  

Давайте раскодируем это, используя ' echo ' для передачи строки в утилиту ' base64 ' с параметром для декодирования 
(--decode или -d). 
```commandline
echo "VEhNe2p1NTdfZDNjMGQzXzdoM19iNDUzfQ==" | base64 -d
```
```commandline
THM{ju57_d3c0d3_7h3_b453}
```

## Задание 3
Мета! мета! мета! мета...................................

### Ответьте на вопросы ниже
Я голоден, мне нужен флаг.

Загрузить файлы заданий: Findme.jpg

#### Решение
Загрузите файл задания « Findme.jpg ».

Для доступа к метаданным изображений лучшим инструментом для начала анализа обычно является ExifTool. Возможно, вам 
придется сначала установить его, если он отсутствует в вашей системе. 
```commandline
sudo apt update
sudo apt install exiftool
exiftool Findme.jpg
```
```commandline
THM{3x1f_0r_3x17}
```

## Задание 4
Что-то скрывается. Это все, что вам нужно знать.

### Ответьте на вопросы ниже
Это грустно. Покорми меня флагом.

#### Решение
Начнем с загрузки файла задания Extinction.jpg .

Мы начинаем наш обычный анализ, снова запуская ExitTool (см. Задание 3 ), но это не выявило ничего скрытого в 
метаданных изображения. 

Далее следует еще один популярный инструмент стеганографии (или стего для краткости) под названием steghide. Если 
он не установлен по умолчанию на вашем компьютере Kali, вы можете установить его, следуя инструкциям ниже: 
```commandline
sudo apt update 
sudo apt install steghide
```

Давайте проанализируем его на наличие скрытого текста с помощью опции « info »:
```commandline
steghide info Extinction.jpg 


"Extinction.jpg": 
  формат: jpeg 
  емкость: 1,3 КБ 
Попытаться получить информацию о внедренных данных ? (y/n) y 
Введите парольную фразу: 
  внедренный файл "Final_message.txt": 
    размер: 79,0 Байт 
    зашифрован: rijndael-128, cbc 
    сжат: да
```

Бинго! Кажется, есть скрытый текстовый файл под названием « Final_message.txt ».
Теперь мы извлекаем данные с помощью команды ниже. Обратите внимание, что вам не предоставили парольную фразу, 
поэтому вы можете нажать «Enter» и оставить поле пустым. 
```commandline
steghide extract -sf Extinction.jpg 
```

Введите парольную фразу: 
записал извлеченные данные в "Final_message.txt". 

```commandline
cat Final_message.txt 
Скоро все закончится. Спи, дитя мое. 

THM{500n3r_0r_l473r_17_15_0ur_7urn}
```

```commandline
THM{500n3r_0r_l473r_17_15_0ur_7urn}
```

## Задание 5
А где флаг? THM {wh173_fl46}

### Ответьте на вопросы ниже
Вы нашли флаг?

#### Решение
Это было немного сложно поначалу. Нет загружаемых файлов, нечего анализировать.
Для этого нам придется воспользоваться подсказкой:
- «Выделите текст или проверьте HTML».

Выделив текст или просмотрев исходный код страницы, вы сможете обнаружить текст.


Выделите, чтобы увидеть скрытый текст
Используйте функцию «Проверка» браузера или инструменты разработчика, чтобы обнаружить скрытый текст.

```commandline
THM{wh173_fl46}
```
## Задание 6
Такая технология вполне надежна.

### Ответьте на вопросы ниже
Пожалуйста, больше флагов!

#### Решение
Начнем с загрузки файла задания QR.png, содержащего QR-код.
Используя камеру телефона или планшета или приложение для чтения QR-кодов, наведите камеру на изображение QR-кода, 
открыв его в любом просмотрщике изображений. Получить флаг для этого просто. 
```commandline
THM{qr_m4k3_l1f3_345y}
```

## Задание 7
Оба варианта работают, все зависит от вас.

### Ответьте на вопросы ниже
Нашли флаг?
#### Решение
Загрузите файл задачи hello.hello, который выглядит как двоичный файл. Давайте сначала проверим это.
```commandline
file hello.hello 

hello.hello: исполняемый файл ELF 64-bit LSB pie, x86-64, версия 1 (SYSV), динамически скомпонованный, интерпретатор 
/lib64/ld-linux-x86-64.so.2, BuildID[sha1]=02900338a56c3c8296f8ef7a8cf5df8699b18696, для GNU/Linux 3.2.0, не очищенный
```
Действительно, это исполняемый файл Linux. Описание задачи предполагает, что мы либо попытаемся «обратно 
разработать» его, либо прочитать. Обратное проектирование подразумевает использование таких инструментов, как Ghidra 
, radare2 , Cutter , OllyDBG , x64dbg и GNU's gdb для анализа двоичного файла.  

Для этого упражнения мы пойдем по более легкому пути, который подойдет новичку CTF, который еще не знаком с обратным 
проектированием. Чтение двоичного файла предполагает, что мы могли бы извлечь строки из двоичного файла с помощью 
инструмента, такого как strings.  

Обратите внимание, что мы можем либо перенаправить вывод в файл, на экран или на grep (найти) интересующие нас 
строки. В этом случае мы ищем THM{ и проигнорируем чувствительность к регистру, поэтому он может соответствовать 
либо «thm{», либо «THM{».  

$ strings hello.hello | grep -i thm{ 
```commandline
THM{345y_f1nd_345y_60}
```

## Задание 8
Можете ли вы это расшифровать?

3agrSy1CewF9v8ukcSkPSYm3oKUoByUpKG4L

### Ответьте на вопросы ниже
О, о, ты понял?

####  Решение
Эта строка не похожа на Base64 или Base32. Мы можем, конечно, попробовать и проверить это, чтобы быть уверенными, 
используя тот же процесс, что и в Задаче 2. 
```commandline
echo "3agrSy1CewF9v8ukcSkPSYm3oKUoByUpKG4L" | base32 -d
base32: invalid input

echo "3agrSy1CewF9v8ukcSkPSYm3oKUoByUpKG4L" | base64 -d
ݨ+K-B{}�ˤq)I����(%)(n
```

Знаем ли мы о других возможных схемах кодирования Base?
После небольшого исследования (хм… погуглив!) мы натыкаемся на Base58.
```commandline
$ echo "3agrSy1CewF9v8ukcSkPSYm3oKUoByUpKG4L" | base58 -d 
THM{17_h45_l3553r_l3773r5}
```
Это было похоже на грубую силу, не правда ли?

Если вы планируете проводить больше CTF в будущем, то чем больше вы автоматизируете и сократите количество ручных 
попыток, тем быстрее и эффективнее вы будете это делать. 

Будучи Maverick, это кричит о простом скрипте bash, чтобы пропустить эту строку через столько схем кодирования, 
сколько мы можем, чтобы сэкономить нам время. Скрипт найдете по ссылке [bash](https://github.com/BEPb/tryhackme/blob/master/01.easy/CTF%20collection%20Vol1/base-decoder.sh)

```commandline
THM{17_h45_l3553r_l3773r5}
```

## Задание 9
Лево, право, лево, право... Rot 13 слишком мейнстримовый. Решите это

MAF{atbe_max_vtxltk}

### Ответьте на вопросы ниже
Что вы получили?
#### Решение
Эта задача предполагает, что очень распространенный ROT13 не является правильным. ROT13 — это простой шифр замены 
букв, также известный как шифр Цезаря. Скорее всего, закодированная строка использовала вариацию ROT-N, где N не 
равно 13.

ROT26 не используется для перебора шифра ROT, потому что это похоже на попытку открыть дверь тем же ключом, но 
повернув его дважды и удивляясь, почему она не открывается.

Метод 1:

Используйте онлайн-декодер, например https://www.dcode.fr/rot-cipher .

Метод 2:

Если вы хотите стать эффективным игроком CTF и кибер-независимым игроком, вам придется привыкнуть к написанию 
скриптов на таких языках, как Python. 

Эту задачу можно автоматизировать, и вы сможете добавить этот скрипт в свой набор инструментов для будущих CTF.

По ссылке находится простой [скрипт](https://github.com/BEPb/tryhackme/blob/master/01.easy/CTF%20collection%20Vol1/rot1_25-bruteforce.py) 
Python для брутфорса ROT1 вплоть до расшифровки ROT25 для заданной строки. Для запуска:
```commandline
python ./rot1_25-bruteforce.py .
```
Запуск скрипта выше должен содержать флаг в одном из оборотов.

```commandline
THM{hail_the_caesar}
```

## Задание 10
Нет загружаемого файла, нет зашифрованного или кодированного текста. Ага .......

### Ответьте на вопросы ниже
Я сейчас голоден... Мне нужен флаг.

#### Решение
Нашим первым подозрением было проверить исходный код HTML. Это очень распространенная задача CTF, особенно очень 
легкие задачи. 

Как оказалось, мы были правы в своих предположениях. Проверка подсказки также поможет вам быстрее добраться туда, 
если вы застряли. 
```commandline
THM{4lw4y5_ch3ck_7h3_c0m3mn7}
```
## Задание 11
Я случайно испортил этот PNG-файл. Можете помочь мне исправить? Спасибо, ^^

### Ответьте на вопросы ниже
Каково содержание?
#### Решение
Мы загрузили файл задания spoil.png, который выглядит как поврежденное изображение PNG.
Этот вызов является одним из самых распространенных в CTF-вызовах для новичков. При работе с изображениями JPG или 
PNG необходимо проверить несколько вещей.

Если изображение не повреждено, вы можете сразу же проверить его на наличие стеганографии, используя для начала 
такие инструменты, как `exiftool` и `steghide` . 

Однако, если мы имеем дело с поврежденным изображением, одним из первых инструментов, который следует использовать, 
является команда Linux « `file` ». Это удобная утилита, которая помогает идентифицировать типы файлов независимо от их 
расширений на основе нескольких выполняемых ею проверок. Одной из таких проверок является `Magic Byte`, которая 
является способом быстрой идентификации распространенных форматов файлов.
```commandline
file spoil.png 
spoil.png: данные
Для изображения PNG заголовок всегда должен начинаться с « .PNG…. » или шестнадцатеричных значений « 0x89 0x50 0x4E 0x47 0x0D 0x0A 0x1A 0x0A ».
```

Мы избалованы выбором, когда дело доходит до использования Hex-редактора для проверки двоичного файла или 
изображения и проверки Magic. Некоторые варианты включают: 
- bvi or bview
- hexeditor
- Bless
Давайте проверим, начинается ли заголовок PNG с « .PNG » или « 89 50 4E 47 ». Похоже, у нашего файла неправильный 
  заголовок:  


Использование bmore или binary more для просмотра изображения
```commandline
bmore spoil.png
```
Файл начинается с « #3D_ », который мы должны заменить на « .PNG ».
Давайте заменим это правильными значениями заголовка, используя графический редактор Hex « `bless` ».


Использование bless для редактирования шестнадцатеричных значений в sploil.png
Снова используя команду file, мы можем проверить, сработало ли это:
```commandline
file spoil.png 
spoil.png: данные изображения PNG, 800 x 800, 8-бит/цвет RGBA, нечересстрочный
```
Отлично! Похоже, мы исправили это и нам не нужно продолжать анализ файла дальше. Открытие файла сейчас покажет флаг:
```commandline
THM{y35_w3_c4n}
```

## Задание 12
Какой-то скрытый флаг внутри аккаунта Tryhackme в соцсети.
### Ответьте на вопросы ниже
Вы нашли спрятанный флаг?

#### Решение
Для выполнения этой задачи потребуется провести OSINT-анализ в социальных сетях.

Начнем с запроса, подобного поиску Google ниже:
```commandline
“Task 12” + “flag”
```

Это дает несколько страниц с описанием CTF или пошаговым руководством, что не то, что нам нужно. Это слишком просто 
и это своего рода мошенничество!

Несколькими результатами ниже по списку мы видим обсуждение Reddit, которое показалось нам интересным. Мы также 
подтверждаем это, проверив подсказку для задания.

Это действительно похоже на скрытую закодированную строку в середине потока.

Мы бы попробовали использовать ROT или простой шифр подстановки методом перебора. Однако, если вы внимательно 
посмотрите на строку, то заметите смешение заглавных и строчных букв, что может указывать на базовую кодировку (16, 
32, 58, 64 и т. д.).  

Помните наш предыдущий скрипт bash в задании 8 ? Вот где пригодятся повторное использование и автоматизация!
```commandline
./base-decoder.sh 
Enter the encoded string: SlVTVCBPTkUgTU9SRSBTVEVQICEhISEhISEhIApzaXRlOiJyZWRkaXQuY29tIiBpbnRleHQ6IlRITSIgaW50aXRsZToidHJ5aGFja21l
Original String: SlVTVCBPTkUgTU9SRSBTVEVQICEhISEhISEhIApzaXRlOiJyZWRkaXQuY29tIiBpbnRleHQ6IlRITSIgaW50aXRsZToidHJ5aGFja21l
base32: invalid input
subsection not found

Decoded (Base64): JUST ONE MORE STEP !!!!!!!!
site:"reddit.com" intext:"THM" intitle:"tryhackme
```

Это было кодирование Base64, и мы получили весьма обнадеживающий результат.

Давайте обратимся к Google и попробуем выполнить следующий поиск:
```commandline
site:”reddit.com” intext:”THM” intitle:”tryhackme
```
У нас снова было несколько результатов, и второй результат, похоже, оказался в нашу пользу.

```commandline
THM{50c14l_4cc0un7_15_p4r7_0f_051n7}
```

## Задание 13
Что это?

+++++++++[>++++++>++++++++>++++++++++<<<<-]>>>++++++ +++++++++.------------.+++++.>++++++++++++++++++++ +++.<<++++++++++++++++++.>>---.------------------- ------.++++++++++++++.++++++++++++.<++++++++++++++ ++++.++++++++++.<+++.+.>----.>++++.

### Ответьте на вопросы ниже
Можете ли вы это расшифровать?
#### Решение
Теперь это выглядит как интересная кодировка. Конечно, не обычная схема кодировки Base.

Я раньше с таким не сталкивался. Я подозревал, что это двоичное кодирование, но, похоже, у нас 8 символов или больше,
а не только два для двоичных 1 и 0. 
Для полного раскрытия мне пришлось воспользоваться подсказкой для этого задания, что нормально, и это все часть 
процесса обучения.

Намек указал, что это кодировка, известная как « binaryfuck » или BrainFuck .
В этот момент мы направляемся к нашему любимому онлайн-декодеру dCode .

```commandline
THM{0h_my_h34d}
```

## Задание 14
Эксклюзивные струны для всех!

S1: 44585d6b2368737c65252166234f20626d
S2: 1010101010101010101010101010101010

### Ответьте на вопросы ниже
Ты взломал его? Накорми меня сейчас же!
#### Решение
У нас есть две строки, одна в шестнадцатеричном формате, а другая в двоичном. Текст вызова предполагает, что они 
хотят, чтобы мы пошли по пути исключающего ИЛИ (XOR).

Прежде чем тратить много сил, вы всегда можете убедиться в этом, воспользовавшись подсказкой, которая 
предоставляется вам по мере возможности. 

Одним из способов решения этой проблемы является использование онлайн-калькулятора XOR.

Строка 1: 44585d6b2368737c65252166234f20626d
Строка 2: 10101010101010101010101010101010101010

Результат:

Двоичный: 101010001001000010011010111101100110011011110000110001101101100011101010011000101110110001100110101111100110000111001001111101

Шестнадцатеричный :
54484D7B3378636C75353176335F30727D

ASCII : }r0_3v15ulcx3{MHT

Наш вывод ASCII из онлайн-калькулятора выглядит как флаг, но кажется перевернутым. Легко позаботиться об этом в 
Linux, используя команду для переворота строки. Вы угадали, это называется « rev »! 
```commandline
echo "}r0_3v15ulcx3{MHT" | rev 
THM{3xclu51v3_0r}
```
Мы — кибер-маверики, поэтому давайте рассмотрим другой способ решения этой задачи самостоятельно, без использования 
онлайн-калькулятора: 
```commandline
python -c "s1 = bytes.fromhex('44585d6b2368737c65252166234f20626d'); s2 = bytes.fromhex('1010101010101010101010101010101010'); print(''.join(chr(a ^ b) for a, b in zip(s1, s2)))"

THM{3xclu51v3_0r}
```

`print(''.join(chr(a ^ b) for a, b in zip(s1, s2)))`
Выполняет операцию XOR над соответствующими байтами s1 и s2 . Он выполняет итерацию по каждой паре байтов с помощью 
zip(s1, s2) и применяет операцию XOR с помощью побитового оператора XOR ^ . 

`''.join(chr(a ^ b) for a, b in zip(s1, s2))`
Преобразует каждое значение XOR обратно в соответствующий ему символ ASCII с помощью функции chr(). Затем он 
объединяет все символы вместе, чтобы сформировать одну строку.

Давайте снова преобразуем его в скрипт, пригодный для повторного использования в любых будущих CTF, и постараемся 
быть более эффективными, попросив скрипт запрашивать у нас любые изменяющиеся строки вместо того, чтобы жестко 
кодировать эти значения - []  
```commandline
THM{3xclu51v3_0r}
```

## Задание 15
Пожалуйста, удалите мой файл :)

### Ответьте на вопросы ниже
Флаг! Флаг! Флаг!
```commandline
THM{y0u_w4lk_m3_0u7}
```
## Задание 16
Что-то таится в темноте.
### Ответьте на вопросы ниже
Что написано на флаге?
```commandline
THM{7h3r3_15_h0p3_1n_7h3_d4rkn355}
```

## Задание 17
Насколько хорошо вы умеете слушать?

P/S: Флаг отформатирован как THM{ Флаг прослушивания }, флаг должен быть написан ЗАГЛАВНЫМИ БУКВАМИ

### Ответьте на вопросы ниже
Что сказал бот?
```commandline
THM{SOUNDINGQR}
```

## Задание 18
Иногда нам нужна «машина», чтобы копаться в прошлом

Целевой веб-сайт: https://www.embeddedhacker.com/
Планируемое время: 2 января 2020 г.

### Ответьте на вопросы ниже
Вы нашли мое прошлое?
```commandline
THM{ch3ck_th3_h4ckb4ck}
```

## Задание 19
Можете ли вы решить следующее? Кстати, я потерял ключ. Извините >.<

МОЙКАХОДТК{RVG_YVGGK_FAL_WXF}

Формат флага: TRYHACKME{ФЛАГ ЗАГЛАВНЫМИ БУКВАМИ}

### Ответьте на вопросы ниже
Расшифрованный текст
```commandline
TRYHACKME{YOU_FOUND_THE_KEY}
```

## Задание 20
Расшифруйте следующий текст.

581695969015253365094191591547859387620042736036246486373595515576333693

### Ответьте на вопросы ниже
Что такое флаг?
```commandline
THM{17_ju57_4n_0rd1n4ry_b4535}
```
## Задание 21
Я только что взломал WiFi соседа и пытаюсь перехватить какой-то пакет. Он, должно быть, замышляет что-то нехорошее. 
Помогите мне найти его. 
### Ответьте на вопросы ниже
Вы захватили флаг моего соседа?

```commandline
THM{d0_n07_574lk_m3}
```
[>> вернуться на главную страницу](https://github.com/BEPb/tryhackme/blob/master/README.md)