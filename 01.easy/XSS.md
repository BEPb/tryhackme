[>> вернуться на главную страницу](https://github.com/BEPb/tryhackme/blob/master/README.md)

# Комната [XSS](https://tryhackme.com/r/room/axss) 

Всего 10 заданий:
## Задание 1
Межсайтовый скриптинг ( XSS ) остается одной из распространенных уязвимостей, угрожающих веб-приложениям по сей день. Атаки XSS основаны на внедрении вредоносного скрипта в безобидный веб-сайт для запуска в браузере пользователя. Другими словами, атаки XSS эксплуатируют доверие пользователя к уязвимому веб-приложению, отсюда и ущерб.

Одна из самых ранних уязвимостей XSS была обнаружена в 1999 году и привела к рекомендации CERT CA-2000-02 . За последние десятилетия различные надежные методы веб-безопасности стали частью современных фреймворков веб-приложений, защищая от многих уязвимостей XSS по умолчанию. С другой стороны, мотивы и сложность атак также выросли.

С ростом числа веб-приложений не будет преувеличением сказать, что каждый месяц обнаруживается и эксплуатируется несколько уязвимостей XSS. В рейтинге OWASP Top 10 XSS занял седьмое место в 2017 году. В отчете 2021 года XSS был сгруппирован с другими инъекционными атаками и вместе занял третье место.

В этом номере подробно рассматривается XSS , чтобы помочь вам обнаружить, использовать и устранить уязвимости XSS .

Предварительные условия для комнаты
Ожидается, что у вас будут базовые знания HTTP и принципов работы веб-сайтов. Если у вас нет этих знаний, мы рекомендуем сначала пройти модуль «Как работает веб» .

Если вы не знакомы с XSS, мы настоятельно рекомендуем вам пройти курс «Введение в межсайтовый скриптинг», поскольку этот курс основан на нем.

Наконец, в этой комнате используются фрагменты кода на PHP , JavaScript, Python и C-Sharp. Знание всех этих языков программирования не требуется. Вместо этого мы объясняем необходимые строки кода и фокусируемся на причинах и средствах устранения уязвимостей XSS .

Ниже приведен список комнат, которые вы можете использовать для заполнения пробелов в знаниях перед началом работы с этой комнатой:

- HTTP в деталях
- Как работают веб-сайты
- Основы JavaScript
- Введение в межсайтовый скриптинг
- Дополнительно: Основы Python
#### Цели обучения
По завершении этой комнаты пользователь должен получить более глубокое понимание XSS , в частности:

- Отражённый XSS
- Сохраненный XSS
- XSS на основе DOM
- Как защититься от XSS
Мы предоставляем фрагменты кода, использующие различные веб-фреймворки, чтобы лучше понять эксплуатацию и защиту от уязвимостей XSS . Мы не фокусируемся на самом коде; мы фокусируемся на причинах уязвимости и некоторых решениях. Цель состоит в том, чтобы помочь нам лучше понять, почему появился XSS и что делает его эксплуатируемым.

### Ответьте на вопросы ниже
Я завершил изучение темы «Введение в межсайтовый скриптинг» .
```commandline
Ответ не нужен
```

## Задание 2
Как уже говорилось, XSS — это уязвимость, которая позволяет злоумышленнику внедрять вредоносные скрипты в веб-страницу, просматриваемую другим пользователем. Следовательно, они обходят политику одного и того же источника ( SOP ) ; SOP — это механизм безопасности, реализованный в современных веб-браузерах для предотвращения получения вредоносным скриптом на одной веб-странице доступа к конфиденциальным данным на другой странице. SOP определяет источник на основе протокола, имени хоста и порта. Следовательно, вредоносная реклама не может получить доступ к данным или манипулировать страницей или ее функциональностью на другом источнике, например на странице интернет-магазина или банка. XSS обходит SOP , поскольку он выполняется из того же источника.

JavaScript для XSS
Базовые знания JavaScript имеют решающее значение для понимания эксплойтов XSS и адаптации их к вашим потребностям. Зная, что XSS — это атака на стороне клиента, которая происходит в веб-браузере цели, мы должны попробовать наши атаки на браузере, похожем на целевой. Стоит отметить, что разные браузеры обрабатывают определенные фрагменты кода по-разному. Другими словами, один код эксплойта может работать против Google Chrome, но не против Mozilla Firefox или Safari.

Предположим, вы хотите поэкспериментировать с каким-то кодом JavaScript в вашем браузере. В этом случае вам нужно открыть Консоль, которая находится в Инструментах веб-разработчика в Firefox, Инструментах разработчика в Google Chrome и Веб-инспекторе в Safari. В качестве альтернативы используйте соответствующие сочетания клавиш:

В Firefox нажмите Ctrl + Shift + K.
В Google Chrome нажмите Ctrl + Shift + J.
В Safari нажмите Command + Option + J.
Веб-браузер с готовой вкладкой «Консоль».

Давайте рассмотрим и попробуем некоторые основные функции JavaScript:

Оповещение : Вы можете использовать alert()функцию для отображения оповещения JavaScript в веб-браузере. Попробуйте alert(1)или alert('XSS')(или alert("XSS")), чтобы отобразить окно оповещения с числом 1 или текстом XSS .
Журнал консоли : Аналогично, вы можете отобразить значение в консоли JavaScript браузера с помощью console.log(). Попробуйте выполнить следующие два примера в журнале консоли: console.log(1)и , console.log("test text") чтобы отобразить число или текстовую строку.
Кодировка : Функция JavaScript btoa("string")кодирует строку двоичных данных для создания строки ASCII в кодировке base64. Это полезно для удаления пробелов и специальных символов или кодирования других алфавитов. Обратная функция — atob("base64_string").
Кроме того, вы можете поэкспериментировать с отображением значений, например, document.cookieиспользуя alert(document.cookie).

Веб-браузер с предупреждением Hello World!

Веб-браузер с вкладкой «Консоль», демонстрирующей примеры функций JavaScript.

Типы XSS
Подводя итоги раздела «Введение в межсайтовый скриптинг» , можно сказать, что существует три основных типа XSS :

Отраженный XSS : эта атака основана на контролируемом пользователем вводе, отраженном для пользователя. Например, если вы ищете определенный термин и на полученной странице отображается термин, который вы искали ( отраженный ), злоумышленник попытается внедрить вредоносный скрипт в поисковый термин.
Stored XSS : эта атака основана на пользовательском вводе, хранящемся в базе данных веб-сайта. Например, если пользователи могут писать обзоры продуктов, которые сохраняются в базе данных ( хранятся ) и отображаются для других пользователей, злоумышленник попытается вставить вредоносный скрипт в свой обзор, чтобы он был выполнен в браузерах других пользователей.
DOM-based XSS : эта атака использует уязвимости в Document Object Model ( DOM ) для манипулирования существующими элементами страницы без необходимости отражения или сохранения на сервере. Эта уязвимость является наименее распространенной среди трех.
### Ответьте на вопросы ниже
Какая XSS-уязвимость основана на сохранении вредоносного скрипта?
```commandline
Stored XSS
```
Какая распространенная XSS-уязвимость выполняется в сеансе браузера без сохранения?
```commandline
Reflected XSS
```
Что означает DOM?
```commandline
Document Object Model
```

## Задание 3
Межсайтовый скриптинг ( XSS ) — это уязвимость веб-безопасности, которая позволяет злоумышленнику внедрять 
вредоносные скрипты в веб-страницу, просматриваемую другими пользователями. В результате ничего не подозревающие 
пользователи в конечном итоге запускают несанкционированный скрипт в своих браузерах, хотя посещаемый ими веб-сайт 
считается безопасным. Таким образом, XSS может представлять серьезную угрозу, поскольку он эксплуатирует доверие 
пользователей к сайту.    

Что делает XSS возможным
Существует множество причин, по которым уязвимости XSS все еще встречаются в веб-приложениях. Ниже мы перечислим 
некоторые из них. 

Недостаточная проверка и очистка входных данных

Веб-приложения принимают пользовательские данные, например, через формы, и используют эти данные в динамической 
генерации HTML-страниц. Следовательно, вредоносные скрипты могут быть встроены как часть законного ввода и в 
конечном итоге будут выполнены браузером, если не будут надлежащим образом очищены.  

Отсутствие выходного кодирования

Пользователь может использовать различные символы, чтобы изменить то, как веб-браузер обрабатывает и отображает 
веб-страницу. Для HTML-части критически важно правильно кодировать такие символы, как <, >, ", 'и &в их 
соответствующую HTML-кодировку. Для JavaScript особое внимание следует уделить экранированию ', ", и \. Неправильное 
кодирование предоставленных пользователем данных является основной причиной уязвимостей XSS.

Неправильное использование заголовков безопасности

Различные заголовки безопасности могут помочь смягчить уязвимости XSS . Например, Content Security Policy (CSP) 
смягчает риски XSS , определяя, какие источники являются доверенными для исполняемых скриптов. Неправильно 
настроенный CSP , например, чрезмерно разрешительные политики или неправильное использование директив 
unsafe-inlineили unsafe-eval, может облегчить злоумышленнику выполнение своих полезных нагрузок XSS.

Уязвимости фреймворка и языка

Некоторые старые веб-фреймворки не предоставляли механизмов безопасности против XSS ; другие имеют неисправленные 
уязвимости XSS. Современные веб-фреймворки автоматически избегают XSS по своей сути и оперативно исправляют любую 
обнаруженную уязвимость.  

Сторонние библиотеки

Интеграция сторонних библиотек в веб-приложение может привести к появлению уязвимостей XSS , даже если основное 
веб-приложение не уязвимо. 

Злонамеренный хакер пишет комментарий на сайте, который начинается с приветствия и сообщает, что это его первый пост.
Кроме того, он включает URL, который выглядит так, будто крадет куки пользователя. 

Последствия XSS
Существует множество последствий XSS . Ниже мы перечислим некоторые из них.

Перехват сеанса

Поскольку XSS может использоваться для кражи сеансовых cookie-файлов, злоумышленники могут перехватить контроль над 
сеансом и в случае успеха выдать себя за жертву. 

Фишинг и кража учетных данных

Используя XSS , злоумышленники могут предоставить пользователю поддельное приглашение на вход. В одном из недавних 
случаев страница браузера была частично скрыта диалоговым окном, предлагающим пользователям подключиться к своему 
криптовалютному кошельку.  

Социальная инженерия

Используя XSS, злоумышленник может создать всплывающее окно или оповещение, выглядящее как легитимное, на доверенном 
веб-сайте. Это может заставить пользователей нажимать на вредоносные ссылки или посещать вредоносные веб-сайты. 

Манипулирование контентом и его искажение

Помимо фишинга и социальной инженерии, злоумышленник может использовать XSS для изменения веб-сайта в других целях, 
например, для нанесения ущерба репутации компании. 

### Утечка данных

XSS может получить доступ и извлечь любую информацию, отображаемую в браузере пользователя. Это включает 
конфиденциальную информацию, такую как персональные данные и финансовая информация. 

### Установка вредоносного ПО

Искусный злоумышленник может использовать XSS для распространения вредоносного ПО. В частности, он может 
осуществлять атаки drive-by download на уязвимый веб-сайт. 

### Ответьте на вопросы ниже
Какие операции следует выполнять с пользовательским вводом, исходя из основных причин уязвимостей XSS?
```commandline
validation and sanitization
```
Какие операции следует выполнять с данными перед их отправкой пользователю для предотвращения уязвимостей XSS?
```commandline
encoding
```

## Задание 4
Отраженный XSS — это тип уязвимости XSS , при котором вредоносный скрипт отражается в браузере пользователя, часто через созданный URL или отправку формы . Рассмотрим поисковый запрос, содержащий <script>alert(document.cookie)</script>; многие пользователи не будут подозревать такой URL, даже если посмотрят на него внимательно. Если он обрабатывается уязвимым веб-приложением, он будет выполнен в контексте браузера пользователя.

В этом безобидном примере он отображает cookie в окне оповещения. Очевидно, что злоумышленник хочет добиться большего, чем просто отобразить cookie в качестве оповещения для пользователя. Однако для того, чтобы такая атака стала возможной, нам нужно уязвимое приложение.

Злоумышленник включает вредоносный скрипт в URL и отправляет его целевому пользователю. Пользователь нажимает на URL и просматривает целевой веб-сайт. В результате вредоносная ссылка выполняется, и на его ноутбуке происходит что-то вредоносное.

Уязвимое веб-приложение
Одна из простых отраженных уязвимостей XSS возникает, когда пользователь ищет какой-то термин, а строка поиска дословно включается в страницу результатов. Этот простой сценарий предоставляет атакующему легкую цель для эксплуатации.

Хотя обнаружить такие уязвимости не всегда легко, исправить их просто. Пользовательский ввод, такой как, <script>alert('XSS')</script>должен быть очищен или закодирован в HTML в &lt;script&gt;alert('XSS')&lt;/script&gt;.

В следующих подразделах мы приводим примеры уязвимого кода на следующих языках и фреймворках:

- PHP
- JavaScript (Node.js)
- Питон (Flask)
- C# (ASP.NET)
#### PHP
Уязвимый код

Посмотрите на следующий фрагмент кода на PHP и выясните, почему он может быть уязвим для отраженного XSS .

```commandline
<?php
$search_query = $_GET['q'];
echo "<p>You searched for: $search_query</p>";
?>
```
Если вы не знакомы с PHP , $_GET— это массив PHP , содержащий значения из строки запроса URL. Кроме того, $_GET['q']относится к параметру строки запроса q. Например, в http://shop.thm/search.php?q=table, $_GET['q']имеет значение table.

Как вы могли догадаться, уязвимость вызвана тем, что поисковое значение отображается на странице результатов без очистки. Таким образом, злоумышленник может добавить вредоносный скрипт в URL, зная, что он будет выполнен. Например, в качестве доказательства концепции можно протестировать следующий URL: http://shop.thm/search.php?q=<script>alert(document.cookie)</script>и если сайт уязвим, появится окно оповещения, отображающее cookie пользователя.

Фиксированный код

К счастью, исправить этот код просто.

```commandline
<?php
$search_query = $_GET['q'];
$escaped_search_query = htmlspecialchars($search_query);
echo "<p>You searched for: $escaped_search_query</p>";
?>
```
Функция PHPhtmlspecialchars() преобразует специальные символы в HTML-сущности. Символы <, >, &, ", 'заменяются по умолчанию, чтобы предотвратить выполнение скриптов во входных данных. Вы можете прочитать ее документацию здесь .

#### JavaScript (Node.js)
Уязвимый код

Следующий фрагмент кода Node.js уязвим для отраженного XSS . Попробуйте найти уязвимую часть и придумать решение.

```commandline
const express = require('express');
const app = express();

app.get('/search', function(req, res) {
    var searchTerm = req.query.q;
    res.send('You searched for: ' + searchTerm);
});

app.listen(80);
```
Если вы не знакомы с Node.js, фрагмент кода выше использует Express, популярный фреймворк веб-приложений для Node.js. Извлечет req.query.qзначение q. Например, в http://shop.thm/search?q=tableимеет req.query.qзначение table. Наконец, ответ генерируется путем добавления поискового запроса, предоставленного пользователем, к «Вы искали:».

Поскольку значение берется у пользователя и вставляется в HTML-код ответа без очистки или экранирования, легко добавить вредоносный запрос. В качестве доказательства концепции мы можем протестировать следующий URL: http://shop.thm/search?q=<script>alert(document.cookie)</script>, и если сайт уязвим, появится окно оповещения, отображающее cookie пользователя.

Фиксированный код

```commandline
const express = require('express');
const sanitizeHtml = require('sanitize-html');

const app = express();

app.get('/search', function(req, res) {
    const searchTerm = req.query.q;
    const sanitizedSearchTerm = sanitizeHtml(searchTerm);
    res.send('You searched for: ' + sanitizedSearchTerm);
});

app.listen(80);
```
Решение достигается путем использования sanitizeHtml()из sanitize-htmlбиблиотеки. Эта функция удаляет небезопасные элементы и атрибуты. Это включает удаление тегов скрипта, среди других элементов, которые могут быть использованы в вредоносных целях. Вы можете прочитать документацию здесь .

Другой подход — использовать escapeHtml()функцию вместо sanitizeHtml()функции. Как следует из названия, escapeHtml()функция предназначена для экранирования таких символов, как <, >, &, ", и '. Вы можете проверить ее домашнюю страницу здесь .

#### Питон (Flask)
Уязвимый код

Рассмотрим следующее простое приложение Flask. Попробуйте найти уязвимую часть.
```commandline
from flask import Flask, request

app = Flask(__name__)

@app.route("/search")
def home():
    query = request.args.get("q")
    return f"You searched for: {query}!"

if __name__ == "__main__":
    app.run(debug=True)
```

Если вы не знакомы с Flask, request.args.get()используется для доступа к параметрам строки запроса из URL запроса. Фактически, request.argsсодержит все параметры строки запроса в объекте, похожем на словарь. Например, в http://shop.thm/search?q=tableимеет request.args.get("q")значение table.

Поскольку значение берется у пользователя и вставляется в HTML-код ответа без очистки или экранирования, легко добавить вредоносный запрос. В качестве доказательства концепции мы можем протестировать следующий URL: http://shop.thm/search?q=<script>alert(document.cookie)</script>, и если сайт уязвим, появится окно оповещения, отображающее cookie пользователя.

Фиксированный код
```commandline
from flask import Flask, request
from html import escape

app = Flask(__name__)

@app.route("/search")
def home():
    query = request.args.get("q")
    escaped_query = escape(query)
    return f"You searched for: {escaped_query}!"

if __name__ == "__main__":
    app.run(debug=True)
```

Главное изменение заключается в том, что пользовательский ввод теперь экранируется с помощью escape()функции из htmlмодуля. Обратите внимание, что html.escape()функция во Flask на самом деле является псевдонимом для markupsafe.escape(). Они обе взяты из библиотеки Werkzeug и служат одной и той же цели: экранированию небезопасных символов в строках. Эта функция преобразует символы, такие как <, >, ", 'в экранированные сущности HTML, обезвреживая любой вредоносный код, вставленный пользователем.

#### ASP.NET
Уязвимый код

Приведенный ниже фрагмент кода создан с использованием ASP.NET C#.
```commandline
public void Page_Load(object sender, EventArgs e)
{
    var userInput = Request.QueryString["q"];
    Response.Write("User Input: " + userInput);
}
```

Если вы не знакомы с ASP.NET и C#, код выше использует Request.QueryString, который возвращает коллекцию связанных строковых ключей и значений. В примере выше нас интересует значение, связанное с ключом q, и мы сохраняем его в переменной userInput. Наконец, ответ создается путем добавления userInputк другой строке.

Фиксированный код
```commandline
using System.Web;

public void Page_Load(object sender, EventArgs e)
{
    var userInput = Request.QueryString["q"];
    var encodedInput = HttpUtility.HtmlEncode(userInput);
    Response.Write("User Input: " + encodedInput);
}
```

Опять же, решение заключается в кодировании пользовательского ввода в HTML-безопасные строки. ASP.NET C# предоставляет метод HttpUtility.HtmlEncode(), который преобразует различные символы, такие как <, >, и &, в их соответствующую кодировку HTML-сущности.

### Ответьте на вопросы ниже
Какой из следующих символов, по вашему мнению, будет закодирован? ., ,, ;, &, или #?
```commandline
&
```
Какой из следующих символов, по вашему мнению, будет закодирован? +, -, *, <, =, или ^?
```commandline
<
```
Какую функцию можно использовать в JavaScript для замены (небезопасных) специальных символов на HTML-сущности?
```commandline
escapeHtml()
```
Какую функцию мы использовали в PHP для замены специальных символов HTML?
```commandline
htmlspecialchars()
```

## Задание 5
Запустите подключенную виртуальную машину , нажав Start Machineкнопку, чтобы завершить эту задачу.

Присоединенная виртуальная машина запускает уязвимую версию copyparty . Обнаруженная отраженная уязвимость XSS имеет идентификатор CVE -2023-38501 , и ее эксплойт опубликован здесь .

Код эксплойта представляет `?k304=y%0D%0A%0D%0A%3Cimg+src%3Dcopyparty+onerror%3Dalert(1)%3E` собой URL-кодировку:

?k304=y <img src=copyparty onerror=alert(1)>
Подключенная виртуальная машина имеет уязвимый сервер, работающий на порту 3923. Вы можете получить доступ к уязвимому серверу http://MACHINE_IP:3923через браузер AttackBox.

### Ответьте на вопросы ниже
Какой тип уязвимости это?
```commandline
Reflected XSS
```
Используйте указанный выше эксплойт против присоединенной виртуальной машины. Что вы видите во второй строке после 
go to? 
```commandline
/?h#cc
```
## Задание 6
Stored XSS или Persistent XSS — это уязвимость безопасности веб-приложений, которая возникает, когда приложение сохраняет введенные пользователем данные и затем встраивает их в веб-страницы, предоставляемые другим пользователям без надлежащей очистки или экранирования. Примерами служат сообщения на веб-форумах, обзоры продуктов, комментарии пользователей и другие хранилища данных. Другими словами, stored XSS происходит, когда ввод пользователя сохраняется в хранилище данных и затем включается в веб-страницы, предоставляемые другим пользователям без надлежащего экранирования.

Атакующий публикует вредоносный скрипт как часть своего комментария. Пользователь просматривает комментарий. Следовательно, на его ноутбуке происходит что-то вредоносное.

Хранимый XSS начинается с того, что злоумышленник внедряет вредоносный скрипт в поле ввода уязвимого веб-приложения. Уязвимость может заключаться в том, как веб-приложение обрабатывает данные в поле комментариев, сообщении на форуме или разделе информации профиля. Когда другие пользователи получают доступ к этому сохраненному контенту, внедренный вредоносный скрипт выполняется в их браузерах. Скрипт может выполнять широкий спектр действий, от кражи сеансовых cookie-файлов до выполнения действий от имени пользователя без его согласия.

### Уязвимое веб-приложение
Существует множество причин, по которым веб-приложение может быть уязвимо к хранимым XSS . Вот некоторые из лучших 
практик по предотвращению уязвимостей хранимого XSS : 

- Проверка и очистка ввода : определите четкие правила и обеспечьте строгую проверку всех предоставленных 
пользователем данных. Например, в имени пользователя можно использовать только буквенно-цифровые символы, а в полях возраста можно использовать только целые числа.
- Используйте экранирование вывода : при отображении введенных пользователем данных в контексте HTML кодируйте все 
  специфичные для HTML символы, такие как <, >и &.
- Применить контекстно-зависимое кодирование : например, в контексте JavaScript мы должны использовать кодирование 
  JavaScript всякий раз, когда вставляем данные в код JavaScript. С другой стороны, данные, помещенные в URL, должны использовать соответствующие методы кодирования URL, например процентное кодирование. Цель состоит в том, чтобы гарантировать, что URL остаются действительными, предотвращая внедрение скрипта.
- Практикуйте глубокую защиту : не полагайтесь на один уровень защиты; используйте проверку на стороне сервера вместо 
  того, чтобы полагаться исключительно на проверку на стороне клиента.
В следующих примерах мы перечисляем уязвимые фрагменты кода на разных языках. Это упражнение должно быть легким на этот раз, поскольку решения напоминают решения, реализованные ранее.

### PHP
Уязвимый код
Код ниже имеет несколько уязвимостей. Он делает две вещи:

Прочитайте комментарий пользователя и сохраните его в $commentпеременной.
Добавляет $commentк столбцу commentтаблицы commentsв базе данных.
Затем он перебирает все строки в столбце commentи отображает их на экране.
Пожалуйста, взгляните на это и подумайте, что может пойти не так.

// Storing user comment
```commandline
$comment = $_POST['comment'];
mysqli_query($conn, "INSERT INTO comments (comment) VALUES ('$comment')");

// Displaying user comment
$result = mysqli_query($conn, "SELECT comment FROM comments");
while ($row = mysqli_fetch_assoc($result)) {
    echo $row['comment'];
}
```
Нас беспокоит сохраненный XSS , поскольку SQL- инъекция выходит за рамки этой комнаты. Основная проблема в том, что комментарий сохраняется и позже отображается среди других комментариев без очистки.

Фиксированный код
```commandline
// Storing user comment
$comment = mysqli_real_escape_string($conn, $_POST['comment']);
mysqli_query($conn, "INSERT INTO comments (comment) VALUES ('$comment')");

// Displaying user comment
$result = mysqli_query($conn, "SELECT comment FROM comments");
while ($row = mysqli_fetch_assoc($result)) {
    $sanitizedComment = htmlspecialchars($row['comment']);
    echo $sanitizedComment;
}
```
Перед тем, как отображать каждый комментарий на экране, мы передаем его через htmlspecialchars()функцию, чтобы гарантировать, что все специальные символы преобразованы в HTML-сущности. Следовательно, любые попытки сохраненного XSS не дойдут до браузера конечного пользователя.

Это выходит за рамки данной комнаты; однако, если вам интересно узнать об уязвимости SQL- инъекции, ее можно устранить с помощью mysqli_real_escape_string(). Эта функция экранирует специальные символы во входной строке, поэтому ее можно безопасно использовать в операторе SQL .

### JavaScript (Node.js)
Уязвимый код
Следующий код JavaScript считывает комментарий, полученный от пользователя, который был сохранен в таблице базы данных. Мы предполагаем, что commentsмассив был заполнен из базы данных. Узнайте, что делает его уязвимым для сохраненного XSS и как это решить.

```commandline
app.get('/comments', (req, res) => {
  let html = '<ul>';
  for (const comment of comments) {
    html += `<li>${comment}</li>`;
  }
  html += '</ul>';
  res.send(html);
});
```
Основная проблема в коде выше заключается в том, что он считывает ввод пользователя, сохраненный в comment(из commentsмассива), и отображает его как часть HTML-кода. Следовательно, когда другой пользователь просматривает комментарий этого пользователя как HTML, браузер выполнит все скрипты, внедренные в него.

Фиксированный код
```commandline
const sanitizeHtml = require('sanitize-html');

app.get('/comments', (req, res) => {
  let html = '<ul>';
  for (const comment of comments) {
    const sanitizedComment = sanitizeHtml(comment);
    html += `<li>${sanitizedComment}</li>`;
  }
  html += '</ul>';
  res.send(html);
});
```
Часть решения заключается в очистке HTML перед его отображением пользователю. Мы можем удалить элементы HTML за пределами разрешенного списка с помощью этой sanitizeHTML()функции. В целом, мы ожидаем, что разрешаем базовое форматирование текста, такое как полужирный шрифт и курсив ( <b>и <i>), но мы бы удалили потенциально опасные или небезопасные элементы, такие как <script>и <onload>. Более подробную информацию можно найти на его официальной странице .

### Питон (Flask)
Уязвимый код
Подобно фрагментам кода, которые мы показали, следующий код использует фреймворк Flask. К настоящему моменту вы можете ожидать ошибок, преследующих этот код.

```commandline
from flask import Flask, request, render_template_string
from flask_sqlalchemy import SQLAlchemy

app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///site.db'
db = SQLAlchemy(app)

class Comment(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    content = db.Column(db.String, nullable=False)

@app.route('/comment', methods=['POST'])
def add_comment():
    comment_content = request.form['comment']
    comment = Comment(content=comment_content)
    db.session.add(comment)
    db.session.commit()
    return 'Comment added!'

@app.route('/comments')
def show_comments():
    comments = Comment.query.all()
    return render_template_string(''.join(['<div>' + c.content + '</div>' for c in comments]))
```
Первая проблема заключается в том, что comment_contentустановлено на отправку формы пользователем, извлеченную request.form['comment']без очистки. Это само по себе закладывает основу для сохраненных XSS и SQL-инъекций. Более того, когда пользователь хочет просмотреть комментарии, они отображаются без экранирования, еще один идеальный рецепт для сохраненных XSS .

Фиксированный код
Мы обеспокоены исправлением сохраненных уязвимостей XSS . Нам нужно убедиться, что в базе данных не сохранены вредоносные скрипты; кроме того, мы экранируем любой контент перед его отображением в виде HTML.

```commandline
from flask import Flask, request, render_template_string, escape
from flask_sqlalchemy import SQLAlchemy
from markupsafe import escape

app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///site.db'
db = SQLAlchemy(app)

class Comment(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    content = db.Column(db.String, nullable=False)

@app.route('/comment', methods=['POST'])
def add_comment():
    comment_content = request.form['comment']
    comment = Comment(content=comment_content)
    db.session.add(comment)
    db.session.commit()
    return 'Comment added!'

@app.route('/comments')
def show_comments():
    comments = Comment.query.all()
    sanitized_comments = [escape(c.content) for c in comments]
    return render_template_string(''.join(['<div>' + comment + '</div>' for comment in sanitized_comments]))
```
Мы использовали escape()функцию, чтобы гарантировать, что любые специальные символы в комментариях, отправленных пользователем, заменяются на HTML-сущности. Как и ожидалось, символы &, <, >, ', и "преобразуются в HTML-сущности ( &amp;, &lt;, &gt;, &#39;, и &quot;). Мы внесли два изменения:

Хотя введенные пользователем данные request.form['comment']сохраняются дословно, содержимое каждого сохраненного комментария cпроходит через функцию escape(), прежде чем оно будет отправлено в браузер пользователя для отображения в виде HTML.

#### C# (ASP.NET)
Уязвимый код
Следующий код C# имеет несколько уязвимостей. Взгляните на код ниже и подумайте, что нужно изменить.
```commandline
public void SaveComment(string userComment)
{
    var command = new SqlCommand("INSERT INTO Comments (Comment) VALUES ('" + userComment + "')", connection);
    // Execute the command
}

public void DisplayComments()
{
    var reader = new SqlCommand("SELECT Comment FROM Comments", connection).ExecuteReader();
    while (reader.Read())
    {
        Response.Write(reader["Comment"].ToString());
    }
    // Execute the command
}
```

Одна из уязвимостей, которую мы наблюдаем в коде выше, — это сохраненный XSS . Система сохраняет любой комментарий, введенный пользователем, без каких-либо изменений и позже отображает его другим пользователям. Другая уязвимость, выходящая за рамки этой комнаты, — это SQL- инъекция.

Фиксированный код
```commandline
using System.Web;

public void SaveComment(string userComment)
{
    var command = new SqlCommand("INSERT INTO Comments (Comment) VALUES (@comment)", connection);
    command.Parameters.AddWithValue("@comment", userComment);
}

public void DisplayComments()
{
    var reader = new SqlCommand("SELECT Comment FROM Comments", connection).ExecuteReader();
    while (reader.Read())
    {
        var comment = reader["Comment"].ToString();
        var sanitizedComment = HttpUtility.HtmlEncode(comment);
        Response.Write(sanitizedComment);
    }
    reader.Close();
}
```

С несколькими изменениями безопасность кода улучшилась. Stored- XSS устраняется с помощью HttpUtility.HtmlEncode()метода перед отображением userCommentкак части веб-страницы. (Если вам интересно, уязвимость SQL- инъекции устраняется с помощью параметризованных SQL- запросов со значениями, передаваемыми отдельно, вместо построения SQL- запроса посредством конкатенации строк. Этого можно добиться с помощью Parameters.AddWithValue()метода в SqlCommandобъектах.

### Ответьте на вопросы ниже
Как называется функция JavaScript, которую мы использовали для очистки введенных пользователем данных перед их сохранением?

```commandline
sanitizeHtml()
```
Какой метод мы вызвали в ASP.Net C# для очистки введенных пользователем данных?


```commandline
HttpUtility.HtmlEncode()
```

## Задание 7
Запустите подключенную виртуальную машину , нажав Start Machineкнопку, чтобы завершить эту задачу.

Прикрепленная виртуальная машина запускает уязвимый проект Hospital Management System . Проект был загружен несколько лет назад и с тех пор не обновлялся. Он полностью функционален. К сожалению, была обнаружена сохраненная уязвимость XSS, помеченная как CVE -2021-38757 , и был опубликован эксплойт , но приложение не было исправлено до момента написания статьи.

Чтобы воспользоваться уязвимостью, злоумышленнику нужно всего лишь нажать «Контакт», заполнить имя, адрес электронной почты, номер телефона и отправить полезную нагрузку в поле сообщения. Что-то простое, например, <script>alert("Simple XSS")</script>все равно сработает.

Любое сообщение, отправленное через страницу контактов, отображается администратору при входе в систему. Чтобы войти в систему как администратор через соответствующую вкладку, используйте следующие учетные данные:

Имя пользователя:admin
Пароль:admin123
Подключенная виртуальная машина имеет свой уязвимый сервер, работающий на порту 80. Вы можете получить к нему доступ по адресу http://MACHINE_IP.

Уязвимость кроется в contact.php . Хотя код работает хорошо, он небезопасен. Как мы видим в листинге ниже, отправленное пользователем сообщение сохраняется в таблице базы данных без очистки.
```commandline
<?php 
$con=mysqli_connect("localhost","root","","myhmsdb");
if(isset($_POST['btnSubmit']))
{
    $name = $_POST['txtName'];
    $email = $_POST['txtEmail'];
    $contact = $_POST['txtPhone'];
    $message = $_POST['txtMsg'];

    $query="insert into contact(name,email,contact,message) values('$name','$email','$contact','$message');";

//...
}
```

### Ответьте на вопросы ниже
Какой тип уязвимости это?
```commandline
Stored XSS
```
Перейдите на страницу контактов и отправьте следующее сообщение <script>alert(document.cookie)</script>. Затем войдите в систему как Receptionist. Каково имя ключа из отображаемой пары ключ-значение?

```commandline
PHPSESSID
```

## Задание 8
Если вы проверите любые обновленные рекомендации по безопасности, то легко найдете новые отраженные и сохраненные уязвимости XSS, обнаруживаемые ежемесячно. Однако то же самое не относится к XSS на основе DOM, которые в настоящее время становятся редкими. Причина в том, что XSS на основе DOM полностью основаны на браузере и не нуждаются в переходе на сервер и обратно к клиенту. В какой-то момент, пример доказательства концепции XSS на основе DOM мог быть создан с использованием статической HTML-страницы; однако, с улучшенной внутренней безопасностью веб-браузеров, XSS на основе DOM стал чрезвычайно сложным.

Прежде чем погрузиться в DOM-based XSS , давайте рассмотрим, что такое Document Object Model (DOM). DOM — это программный интерфейс, представляющий веб-документ в виде дерева. DOM позволяет программно получать доступ и управлять различными частями веб-сайта с помощью JavaScript. Давайте рассмотрим практический пример.

Рассмотрим HTML-код example.com на скриншоте ниже (полученный 1 февраля 2024 г.). Мы открыли Web Developer Tools с помощью веб-браузера Firefox и проверили вкладку Inspector.

Веб-браузер с вкладкой «Инспектор», отображающей пример веб-сайта.

Показанное выше дерево DOM похоже на следующий список с подсписками.

Дерево начинается с documentузла и разветвляется на DOCTYPEи html. htmlУзел разветвляется на headи body. Узел headимеет title, несколько metaтегов и style. В этом простом примере bodyу есть один div, который разветвляется на один h1и два p. Это краткая страница. Более практичные страницы имели бы десятки или сотни ветвей.

Мы можем просмотреть дерево DOM с помощью встроенных в веб-браузер инструментов веб-разработчика. Например, нажмите Ctrl + Shift + I в Firefox и проверьте вкладку Inspector.

В качестве альтернативы мы можем получить доступ к консоли JavaScript, как упоминалось в Задании 2. Используя JavaScript, вы можете управлять деревом DOM. Например, вы можете создать новый элемент с помощью document.createElement()и добавить дочерний элемент к любому элементу с помощью element.append(). Вот пример из документации MDN .
```commandline
let div = document.createElement("div");
let p = document.createElement("p");
div.append(p);

console.log(div.childNodes); // NodeList [ <p> ]
```

В примере кода выше мы создали два элемента divи p. Затем мы добавили последний элемент к divэлементу .

Уязвимые веб-приложения
Уязвимости XSS на основе DOM происходят в браузере. Им не нужно идти на сервер и возвращаться в веб-браузер клиента. Другими словами, злоумышленник попытается воспользоваться этой ситуацией, внедрив вредоносный скрипт, например, в URL, и он будет выполнен на стороне клиента без какой-либо роли сервера в этом. Мы представим простейший и минимальный статический сайт, не полагаясь на код бэкенда, чтобы продемонстрировать эту концепцию.

Уязвимый «статичный» сайт
Давайте рассмотрим следующий базовый пример. Он слишком прост, чтобы быть нереалистичным, однако его достаточно для демонстрации DOM-based XSS .

```commandline
<!DOCTYPE html>
<html>
<head>
    <title>Vulnerable Page</title>
</head>
<body>
    <div id="greeting"></div>
    <script>
        const name = new URLSearchParams(window.location.search).get('name');
        document.write("Hello, " + name);
    </script>
</body>
</html>
```
Страница выше ожидает, что пользователь введет свое имя после ?name=. На снимке экрана ниже:

Пользователь ввел Web Tester после ?nameURL-адреса.
Приветствие сработало так, как и ожидалось, и вывело сообщение «Привет, веб-тестер».
Наконец, структура DOM справа остается нетронутой; у нее <body>есть три прямых дочерних элемента.
Веб-браузер с вкладкой «Инспектор», отображающей исходную структуру DOM примера статического сайта.

Пользователь может попытаться внедрить вредоносный скрипт. На скриншоте ниже мы видим следующее:

Пользователь добавил <script>alert("XSS")</script>вместо только Web Testerсвоего имени.
Скрипт был выполнен, и появилось диалоговое окно с предупреждением.
Самое главное, мы можем видеть, как дерево DOM получило новый элемент. <body>Теперь у него четыре дочерних элемента.
Веб-браузер с вкладкой «Инспектор», отображающей измененную структуру DOM примера статического сайта.

Этот простой пример иллюстрирует несколько вещей:

Сервер не играет прямой роли в уязвимостях на основе DOM. В этой демонстрации все происходило в браузере клиента без использования бэкенда.
DOM был небезопасно изменен с помощью document.write().
Фиксированный «статичный» сайт
```commandline
<!DOCTYPE html>
<html>
<head>
    <title>Secure Page</title>
</head>
<body>
    <div id="greeting"></div>
    <script>
        const name = new URLSearchParams(window.location.search).get('name');
        // Escape the user input to prevent XSS attacks
        const escapedName = encodeURIComponent(name);
        document.getElementById("greeting").textContent = "Hello, " + escapedName;
    </script>
</body>
</html>
```
Один из способов исправить эту страницу — избегать добавления пользовательского ввода напрямую с помощью document.write(). Вместо этого мы сначала экранировали пользовательский ввод с помощью encodeURIComponent(), а затем добавили его в textContent.

Предыдущая попытка сейчас не работает. Мы видим, что:

Пользователь добавил JavaScript как часть своих входных данных.
Код JavaScript отображается в виде закодированных символов и не представляет угрозы в текущем контексте.
Структура DOM больше не затрагивается, когда пользователь пытается добавить код как часть своего отправленного имени.
Веб-браузер с вкладкой «Инспектор», отображающей структуру DOM исправленного статического сайта.

### Ответьте на вопросы ниже
XSS на основе DOM отражается через сервер. (Да/Нет)
```commandline
Nay
```
XSS на основе DOM происходит только на стороне клиента. (Да/Нет)
```commandline
Yea
```
Какой метод JavaScript использовался для экранирования пользовательского ввода?
```commandline
encodeURIComponent()
```

## Задание 9
Контекст
Вероятнее всего, введенная полезная нагрузка попадет в одно из следующих мест:

Между тегами HTML
В тегах HTML
Внутри JavaScript
Когда XSS происходит между тегами HTML, злоумышленник может запустить <script>alert(document.cookie)</script>.

Однако, когда инъекция находится внутри HTML-тега, нам нужно завершить HTML-тег, чтобы дать скрипту возможность загрузиться. Следовательно, мы можем адаптировать нашу полезную нагрузку к ><script>alert(document.cookie)</script>или "><script>alert(document.cookie)</script>или к чему-то подобному, что будет соответствовать контексту.

Нам может потребоваться завершить скрипт, чтобы запустить внедренный, если мы можем внедрить наш XSS в существующий JavaScript. Например, мы можем начать с , </script>чтобы закончить скрипт и продолжить оттуда. Если ваш код находится в строке JavaScript, вы можете закрыть строку с помощью ', завершить команду точкой с запятой, выполнить вашу команду и закомментировать оставшуюся часть строки с помощью //. Вы можете попробовать что-то вроде этого ';alert(document.cookie)//.

Этот пример должен дать вам несколько идей, как избежать контекста, с которого вы начинаете. Вообще говоря, знание контекста, в котором выполняется ваша полезная нагрузка XXS, очень важно для успешного выполнения полезной нагрузки.

#### Уклонение
Различные репозитории могут быть использованы для создания вашей собственной полезной нагрузки XSS. Это дает вам много места для экспериментов. Одним из таких списков является список полезной нагрузки XSS .

Однако иногда существуют фильтры, блокирующие полезные нагрузки XSS. Если есть ограничение на длину полезной нагрузки, то Tiny XSS Payloads может стать отличной отправной точкой для обхода ограничений на длину.

Если полезные нагрузки XSS блокируются на основе определенных списков блокировки, существуют различные уловки для обхода. Например, горизонтальная табуляция, новая строка или возврат каретки могут разбить полезную нагрузку и обойти механизмы обнаружения.

Горизонтальная табуляция (TAB) 9в шестнадцатеричном представлении
Новая строка (LF) Aв шестнадцатеричном представлении
Возврат каретки (CR) имеет Dшестнадцатеричное представление.
Следовательно, основываясь на памятке по обходу фильтра XSS , мы можем разбить полезную нагрузку <IMG SRC="javascript:alert('XSS');">различными способами:
```commandline
<IMG SRC="jav&#x09;ascript:alert('XSS');">
<IMG SRC="jav&#x0A;ascript:alert('XSS');">
<IMG SRC="jav&#x0D;ascript:alert('XSS');">
```

Существуют сотни методов уклонения; выбор будет зависеть от уровня безопасности цели и потребует проб и ошибок, прежде чем будет достигнут успешный результат.

### Ответьте на вопросы ниже
Какой персонаж &#x09представляет?


```commandline
Tab
```

## Задание 10
Цель этой комнаты — дать вам более глубокое понимание основ работы XSS -скриптов. Мы рассмотрели причины и множество 
средств для исправления XSS- скриптов. Понимание того, что происходит за кулисами, должно дать вам преимущество в 
исследовании существующих эксплойтов и адаптации их к вашим потребностям.  

### Ответьте на вопросы ниже
В этой комнате использовался вымышленный статический сайт для демонстрации одной из уязвимостей XSS. Какой тип XSS 
это был? 

```commandline
DOM-based XSS
```
[>> вернуться на главную страницу](https://github.com/BEPb/tryhackme/blob/master/README.md)