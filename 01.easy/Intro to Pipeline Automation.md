[>> вернуться на главную страницу](https://github.com/BEPb/tryhackme/blob/master/README.md)

# Комната [Intro to Pipeline Automation](https://tryhackme.com/r/room/introtopipelineautomation) 

Всего 9 заданий:
## Задание 1
Люди всегда ищут более простые и эффективные способы делать что-то. Как только мы начали программировать и 
разрабатывать программное обеспечение, мы искали способы автоматизировать некоторые задачи. Сегодня автоматизация 
прочно укоренилась в жизненном цикле разработки программного обеспечения ( SDLC ) и процессах DevOps . Хотя это 
невероятно хорошо для производства, позволяя ускорить разработку и развертывание, однако это вносит новые риски 
безопасности. Когда эти процессы выполняются вручную, злоумышленнику придется скомпрометировать учетные данные или 
рабочую станцию человека, который выполнил соответствующий процесс. Однако с автоматизацией злоумышленник теперь 
может заняться самим конвейером.       

Цели обучения

В этой комнате вы познакомитесь со следующими концепциями:
- Введение в конвейер DevOps
- Введение в инструменты и автоматизацию DevOps
- Введение в принципы безопасности для конвейера DevOps
Это вводная комната. Таким образом, большинство этих концепций будут представлены только в этой комнате и будут 
  рассмотрены более подробно в остальных комнатах этого модуля. 

### Ответьте на вопросы ниже
Я готов узнать об автоматизации трубопроводов и о том, как обеспечить ее безопасность!

```commandline
Ответ не нужен
```

## Задание 2
Прежде чем изучать безопасность автоматизации, мы должны начать с определения конвейера и показать, где может 
происходить автоматизация. На схеме ниже показано, как может выглядеть типичный конвейер, а также программное 
обеспечение, которое может использоваться для этой цели:

Схема трубопровода

Для каждого из этих пунктов мы рассмотрим, что они собой представляют, общие инструменты, используемые для них, 
введение в их безопасность и пример того, что может произойти, когда безопасность дает сбой. Каждый из этих 
компонентов будет подробно рассмотрен в следующих комнатах этого модуля.  

### Ответьте на вопросы ниже
На каком этапе конвейера будет развернут наш конечный продукт?

```commandline
Environments
```

## Задание 3
Давайте рассмотрим исходный код и контроль версий. Это начало нашего конвейера. Нам нужно место, где мы можем хранить наш код. Кроме того, мы часто хотим хранить несколько версий нашего кода, поскольку мы постоянно вносим улучшения и добавляем функции.

Хранилище исходного кода

При выборе места хранения кода необходимо учитывать несколько факторов:
- Как мы можем осуществлять контроль доступа к нашему исходному коду?
- Как мы можем гарантировать, что внесенные изменения отслеживаются?
- Можем ли мы интегрировать нашу систему хранения исходного кода с нашими инструментами разработки?
- Можем ли мы хранить и активно использовать несколько различных версий нашего исходного кода?
- Должны ли мы размещать наш исходный код внутри компании или мы можем воспользоваться услугами третьей стороны для 
  размещения нашего кода?

Ответы на эти вопросы помогут нам выбрать правильное решение для хранения исходного кода для нашего проекта.

#### Контроль версий

Контроль версий нам необходим по двум основным причинам:
- Мы часто интегрируем новые функции в наше программное обеспечение. Современные подходы к разработке, такие как Agile, подразумевают, что мы постоянно обновляем наш код. Чтобы держать все эти обновления под контролем, нам нужен контроль версий.
- Над кодом работает целая команда разработчиков, а не один разработчик. Чтобы гарантировать, что мы можем 
  интегрировать изменения от нескольких разработчиков, требуется контроль версий.
Контроль версий позволяет нам хранить несколько версий кода. Это может быть конкретная версия, над которой работает 
  каждый разработчик, но это могут быть и совершенно разные версии нашего приложения, включая второстепенные и 
  основные версии.  

#### Общие инструменты

Две наиболее распространенные системы хранения исходного кода и контроля версий — это Git и SubVersion (SVN). Git — 
это распределенный инструмент контроля исходного кода, что означает, что у каждого участника будет своя собственная 
копия исходного кода. С другой стороны, SVN — это централизованный инструмент контроля исходного кода, что означает, 
что контроль над репозиторием осуществляется централизованно.   

GitHub — это, безусловно, крупнейший поставщик интернет-хостинга для разработки программного обеспечения и 
управления версиями с использованием Git. Вы можете создать учетную запись GitHub и использовать ее для управления 
репозиториями исходного кода (repo). Однако вы также можете разместить свой собственный сервер git с помощью такого 
программного обеспечения, как Gitlab. Для SVN два самых популярных инструмента — TortoiseSVN и Apache SVN.   

Однако следует отметить, что решения для хранения исходного кода, такие как Gitlab, предоставляют гораздо больше 
возможностей, чем простое хранение и контроль версий. Сегодня эти инструменты можно использовать практически для 
всего конвейера!  

Соображения безопасности

Наш исходный код часто является нашим секретным соусом. Поэтому мы хотим быть уверены, что он не будет раскрыт. Вот 
почему аутентификация и контроль доступа к нашему исходному коду так важны. Мы также хотим быть уверены, что 
изменения и обновления адекватно отслеживаются, что позволяет нам всегда вернуться к предыдущей версии, если что-то 
случится.   

Однако нам также нужно быть осторожными с тем, что мы храним как часть нашего исходного кода. Исходный код не может 
быть полностью секретным, так как разработчикам нужен доступ к нему. Таким образом, нам следует быть осторожными, 
чтобы не путать хранение исходного кода с управлением секретами. Нам нужно убедиться, что мы не храним секреты, 
такие как строки подключения к базе данных и учетные данные, в нашем исходном коде. Поскольку мы храним все версии 
нашего исходного кода, даже если мы удалим секреты в более новой версии, они все равно будут раскрыты в предыдущих 
версиях.     

Пример из практики: Git никогда не забывает

Как упоминалось ранее, контроль версий может плохо для нас закончиться, если мы совершим ошибку. Это 
распространенная проблема при использовании инструментов контроля версий, таких как Git . Есть поговорка: «Git 
никогда не забывает» . Код «коммитится» в репозиторий Git. Когда это происходит, Git определяет изменения, 
внесенные в файлы, и создает новую версию на основе этих изменений. Любой пользователь, имеющий доступ к репозиторию,
может просмотреть исторические коммиты и внесенные изменения.     

Часто может случиться так, что разработчик случайно фиксирует секреты, такие как учетные данные или строки 
подключения к базе данных, в репозитории Git. Осознав свою ошибку, он удаляет секреты и создает другой коммит. 
Однако теперь в репозитории будут оба коммита. Если злоумышленник получит доступ к репозиторию, он может 
использовать такой инструмент, как GittyLeaks, который просканирует коммиты на предмет конфиденциальной информации. 
Даже если эта информация больше не существует в текущей версии, эти инструменты могут просканировать все предыдущие 
версии и раскрыть эти секреты.

### Ответьте на вопросы ниже
Кто является крупнейшим онлайн-поставщиком Git?
```commandline
Github
```
Какой популярный продукт Git используется для размещения вашего собственного сервера Git?
```commandline
Gitlab
```
Какой инструмент можно использовать для сканирования коммитов репозитория на предмет наличия конфиденциальной информации?
```commandline
GittyLeaks
```

## Задание 4
Давайте поговорим о зависимостях. Хотя мы можем думать, что пишем большой объем кода при разработке, правда в том, 
что это только верхушка айсберга. Если вы не кодируете в двоичном формате, скорее всего, вы на самом деле пишете 
только часть фактического кода. Это потому, что большая часть кода уже написана для нас в виде библиотек и 
комплектов разработки программного обеспечения (SDK). Даже такие переменные, как String в приложении, имеют за собой 
целую библиотеку! Управление этими зависимостями является важной частью конвейера.     

Внешние и внутренние зависимости

Внешние зависимости — это общедоступные библиотеки и SDK. Они размещаются на внешних менеджерах зависимостей, таких 
как PyPi для Python, NuGet для .NET и библиотеки Gems для Ruby. Внутренние зависимости — это библиотеки и SDK, 
которые организация разрабатывает и поддерживает внутри себя. Например, организация может разработать библиотеку 
аутентификации. Затем эта библиотека может использоваться для всех приложений, разработанных организацией.    

#### Общие инструменты
Менеджер зависимостей, также называемый менеджером пакетов, необходим для управления библиотеками и SDK. Как 
упоминалось ранее, для внешних зависимостей используются такие инструменты, как PyPi, NuGet и Gems. Управление 
внутренними зависимостями немного сложнее. Для них мы можем использовать такие инструменты, как JFrog Artifactory 
или Azure Artifacts, чтобы управлять этими зависимостями.   

Соображения безопасности

Некоторые соображения безопасности уже упоминались ранее. Однако основная проблема безопасности заключается в том, 
что зависимости — это код, находящийся вне нашего контроля. Особенно в наше время, когда используется так много 
различных зависимостей, невероятно сложно отслеживать зависимости. Если в этих зависимостях есть уязвимости, это 
может привести к уязвимостям в нашем приложении.

Пример использования: Log4Shell

В 2021 году была обнаружена уязвимость 0day в зависимости Log4j под названием Log4Shell. Log4j — это утилита ведения 
журнала на основе Java. Она является частью Apache Logging Services, проекта Apache Software Foundation. Уязвимость 
может позволить неаутентифицированному злоумышленнику получить удаленное выполнение кода в системе, которая 
использует регистратор. В чем настоящая проблема? Эта маленькая зависимость использовалась буквально везде, как 
показано в этой карикатуре XKCD:

Зависимости

Это не преувеличение. Посмотрите здесь, чтобы увидеть, сколько различных продуктов были уязвимы, поскольку они 
использовали эту зависимость. Список стал таким большим, что его пришлось разделить в алфавитном порядке. Это 
показывает влияние того, что может произойти, когда уязвимость обнаружена в зависимости.

### Ответьте на вопросы ниже
Как мы называем тип зависимости, созданный нашей организацией? (Внутренняя/Внешняя)
```commandline
Internal
```
Какой тип зависимости имеет JQuery? (Внутренняя/Внешняя)
```commandline
External
```
Как называется репозиторий публичных зависимостей Python?
```commandline
PyPi
```
Какая уязвимость 0day повергла мир в шок в 2021 году?
```commandline
Log4j
```

## Задание 5
Давайте подробнее рассмотрим автоматизированное тестирование. В старые времена тестирование было довольно 
утомительным и ручным процессом. Тестировщику приходилось вручную запускать и документировать каждый тестовый случай 
и надеяться, что покрытие было достаточным для того, чтобы гарантировать, что приложение или сервис работает и 
останется стабильным. Однако в современных конвейерах автоматизированное тестирование может выполнять значительную 
часть этой работы.    

Тестирование модулей

Когда речь идет об автоматизированном тестировании в конвейере, это будет первый тип тестирования, с которым знакомы 
большинство разработчиков и инженеров-программистов. Модульный тест — это тестовый случай для небольшой части 
приложения или сервиса. Идея заключается в том, чтобы тестировать приложение по частям, чтобы убедиться, что все 
функции работают так, как надо.   

В современных конвейерах модульное тестирование может использоваться в качестве качественных ворот. Тестовые случаи 
могут быть интегрированы в часть непрерывной интеграции и непрерывного развертывания ( CI / CD ) конвейера, где 
сборка будет остановлена, если эти тестовые случаи не пройдут. Однако модульное тестирование обычно фокусируется на 
функциональности, а не на безопасности.    

#### Тестирование интеграции

Другим распространенным методом тестирования является интеграционное тестирование. В то время как модульные тесты 
фокусируются на небольших частях приложения, интеграционное тестирование фокусируется на том, как эти небольшие 
части работают вместе. Подобно модульным тестам, тестирование будет выполняться для каждой из интеграций и также 
может быть интегрировано в часть CI / CD конвейера. Подмножеством интеграционного тестирования является 
регрессионное тестирование, цель которого — гарантировать, что новые функции не окажут отрицательного влияния на 
существующие функции и функциональность. Однако, подобно модульному тестированию, интеграционное тестирование, 
включая регрессионное тестирование, обычно не выполняется в целях безопасности.       

#### Тестирование безопасности

Итак, если первые два типа автоматизированного тестирования не предназначены для тестирования безопасности, то какие 
из них предназначены? Существует два основных типа автоматизированного тестирования безопасности.  

#### САСТ

Статическое тестирование безопасности приложений (SAST) работает путем проверки исходного кода приложения или 
сервиса для выявления источников уязвимостей. Инструменты SAST могут использоваться для сканирования исходного кода 
на наличие уязвимостей. Это может быть интегрировано в процесс разработки, чтобы уже сейчас выявлять потенциальные 
проблемы для разработчиков, пока они пишут код. Мы также можем интегрировать это в процесс CI / CD . Не как ворота 
качества, а как ворота безопасности, предотвращая продолжение конвейера, если инструмент SAST все еще обнаруживает 
уязвимости, которые не были помечены как ложные срабатывания.     

#### ДАСТ

Динамическое тестирование безопасности приложений ( DAST ) похоже на SAST, но выполняет динамическое тестирование, 
выполняя код. Это позволяет инструментам DAST обнаруживать дополнительные уязвимости, которые были бы невозможны при 
простом просмотре исходного кода. Один из методов, который инструменты DAST используют для обнаружения 
дополнительных уязвимостей, таких как межсайтовый скриптинг (XSS), заключается в создании источников и приемников. 
Когда инструмент DAST предоставляет входные данные для поля в приложении, он отмечает его как источник. Когда 
приложение возвращает данные, он снова ищет этот конкретный параметр и, если находит его, отмечает его как приемник. 
Затем он может отправлять потенциально вредоносные данные в источник и, в зависимости от того, что отображается в 
приемнике, определять, есть ли уязвимость, такая как XSS. Подобно SAST, инструменты DAST могут быть интегрированы в 
конвейер CI / CD в качестве шлюзов безопасности.         

#### Тестирование на проникновение

К сожалению, инструменты SAST и DAST не могут полностью заменить ручное тестирование, например, тесты на 
проникновение. В автоматизированном тестировании достигнуты значительные успехи, и даже в некоторых случаях эти 
методы были объединены с более современными подходами для создания новых методов тестирования, таких как 
интерактивное тестирование безопасности приложений (IAST) и самозащита приложений во время выполнения (RASP). Однако 
главной проблемой остается то, что эти инструменты, включая эти современные методы тестирования, неэффективны против 
контекстных уязвимостей. Возьмем, к примеру, процесс оплаты. Распространенной уязвимостью является то, что часть 
процесса можно обойти, например, этап проверки кредитной карты. Это простой тестовый случай для выполнения вручную, 
но поскольку он требует контекста, даже инструментам DAST будет сложно обнаружить обходной путь. Аналогично, 
недостатки бизнес-логики и контроля доступа трудно обнаружить с помощью автоматизированных инструментов, тогда как 
ручное тестирование может обнаружить их довольно быстро. Дело не в том, что автоматизированные инструменты никогда 
не смогут найти эти недостатки, просто ручное тестирование более экономически эффективно.           

#### Общие инструменты
Существует несколько распространенных инструментов, которые можно использовать для автоматизированного тестирования. 
И GitHub , и Gitlab имеют встроенные инструменты SAST. Такие инструменты, как Snyk и Sonarqube , также популярны для 
SAST и DAST .  

Пример: Она не может больше терпеть капитана, она взорвется!
Распространенная проблема с инструментами SAST и DAST заключается в том, что инструмент просто внедряется в конвейер,
даже просто для проверки концепции ( PoC ). Однако вам нужно принять во внимание несколько вещей:  
- Стоимость производительности
- Точки интеграции
- Калибровка результатов
- Реализация ворот качества и безопасности


Первый и последний пункты очень важны и могут быть дорогостоящими, если их игнорировать. Первоначальный PoC 
инструмента, вероятно, должен быть выполнен после окончания рабочего дня, поскольку ему придется сканировать весь 
код. Этот процесс может значительно повлиять на производительность вашего инструмента управления исходным кодом. 
Представьте, что это происходит прямо перед большим релизом, и разработчики не могут подготовить и отправить свои 
последние коммиты.    

Кроме того, поскольку все больше организаций переходят на более гибкий подход к разработке ПО, большинство 
репозиториев получают несколько сотен коммитов ежедневно. Если вы вводите новый шлюз безопасности, даже просто для 
PoC , который сканирует каждый запрос на слияние на наличие уязвимостей перед одобрением, это может иметь серьезные 
потери производительности вашей инфраструктуры и скорости, с которой разработчики могут выполнять запросы на слияние.   

При внедрении новых автоматизированных инструментов тестирования следует тщательно продумать, как следует выполнять 
PoC , чтобы не допустить сбоев, а также чтобы PoC был репрезентативным для того, как инструментарий будет 
взаимодействовать, когда он будет окончательно интегрирован. Тонкий баланс, которого стоит попытаться достичь!  

### Ответьте на вопросы ниже
Какой тип инструмента сканирует код на предмет потенциальных уязвимостей?
```commandline
SAST
```
Какой тип инструмента запускает код и внедряет тестовые случаи для поиска потенциальных уязвимостей?
```commandline
DAST
```
Можно ли использовать SAST и DAST в качестве замены тестам на проникновение? (Да, нет)
```commandline
Nay
```

## Задание 6
В современных конвейерах программное обеспечение не перемещается вручную между различными средами. Вместо этого можно использовать автоматизированный процесс для компиляции, сборки, интеграции и развертывания новых функций программного обеспечения. Этот процесс называется CI / CD .

Примечание: Термин CI /CD за последние годы довольно сильно изменился. Изначально основное внимание уделялось обеспечению того, чтобы разработка выполнялась с использованием подхода Agile, в то время как поставка продукта по-прежнему осуществлялась с использованием каскадной модели развертывания только финальных релизов. В то время было принято, что CI / CD означало непрерывную интеграцию и непрерывную разработку. Однако быстро стало понятно, что само развертывание также можно сделать гибким, и аббревиатура изменилась на Continuous Integration и Continuous Deployment, а разработка теперь стала частью компонента Integration. Наконец, они поняли, что это не только развертывание, но и все аспекты, связанные с поставкой решения и тем, как мы отслеживаем его после поставки, и аббревиатура была снова изменена, чтобы теперь окончательно означать Continuous Integration и Continuous Delivery. Таким образом, вы можете слышать, как эти термины используются взаимозаменяемо, но на самом деле все они относятся к одному и тому же.

CI / CD

Поскольку мы постоянно создаем новые функции для нашей системы или сервиса, нам нужно убедиться, что эти функции будут работать с текущим приложением. Вместо того, чтобы ждать окончания цикла разработки, когда все функции будут интегрированы, теперь мы можем непрерывно интегрировать новые функции и тестировать их по мере разработки.

Мы можем создать то, что называется конвейером CI / CD . Эти конвейеры обычно имеют следующие отдельные элементы:
- Starting Trigger — действие, которое запускает процесс конвейера. Например, push-запрос отправляется в определенную ветку.
- Действия по созданию — действия, предпринимаемые для создания как проекта, так и новой функции.
- Тестовые действия — действия, которые позволят протестировать проект, чтобы убедиться, что новая функция не мешает 
  работе текущих функций приложения.
- Действия по развертыванию — если конвейер будет успешным, действия по развертыванию подробно описывают, что должно 
  произойти со сборкой. Например, затем ее следует отправить в среду тестирования.
- Действия по доставке - По мере развития процессов CI / CD внимание теперь сосредоточено не только на самом 
  развертывании, но и на всех аспектах доставки решения. Это включает такие действия, как мониторинг развернутого решения.
- Для выполнения действий этих элементов конвейеры CI /CD требуют инфраструктуру сборки. Обычно мы называем эту 
инфраструктуру оркестраторами и агентами сборки. Оркестратор сборки направляет различных агентов для выполнения 
действий конвейеров CI / CD по мере необходимости.  

Эти конвейеры CI / CD обычно являются тем местом, где можно найти большую часть автоматизации. Таким образом, это 
обычно самая большая поверхность атаки и самый большой шанс для проникновения неправильных конфигураций.

#### Общие инструменты

GitHub и Gitlab предоставляют возможности конвейера CI /CD и довольно популярны в использовании. GitHub 
предоставляет агенты сборки, тогда как Gitlab предоставляет приложение Gitlab runner, которое можно установить на 
хосте, чтобы сделать его агентом сборки. Для более сложных сборок можно использовать программное обеспечение 
оркестратора сборки, такое как Jenkins . Мы рассмотрим эти инструменты и их распространенные неправильные 
конфигурации в следующих комнатах.

Пример из практики: путаница между разработкой и производством

Одной из распространенных ошибок конфигурации конвейеров CI / CD является использование одних и тех же агентов 
сборки для сборок Development (DEV) и Production (PROD). Это создает интересную проблему, поскольку большинство 
разработчиков будут иметь доступ к стартовому триггеру для сборки DEV, но не для сборки PROD.

Если один из этих разработчиков был скомпрометирован, злоумышленник мог бы использовать его доступ, чтобы вызвать 
вредоносную сборку DEV, которая скомпрометирует агента сборки. Это не было бы большой проблемой, если бы агент 
сборки использовался только для сборок DEV. Однако, поскольку этот агент также используется для сборок PROD, 
злоумышленник мог бы просто оставаться на этом агенте сборки до тех пор, пока сборка PROD не будет активирована, 
чтобы внедрить свой вредоносный код в сборку, что позволило бы ему скомпрометировать производственную сборку 
приложения.

### Ответьте на вопросы ниже
Что означает CI в аббревиатуре CI/CD?
```commandline
Continuous Integration
```
Что означает CD в аббревиатуре CI/CD?
```commandline
Continuous Delivery
```
Как мы называем элемент инфраструктуры сборки, который управляет всеми сборками?
```commandline
Build Orchestrator
```
Как мы называем элемент инфраструктуры сборки, который выполняет сборку?
```commandline
Build Agent
```

## Задание 7
Другие примечательные места
Есть и другие среды, о которых вы можете услышать, говоря о DevOps .

#### Зелёная и синяя среда

Зеленые и синие среды используются для стратегии развертывания Blue/Green при отправке обновления в PROD. Вместо 
одного экземпляра PROD их два. Синяя среда запускает текущую версию приложения, а зеленая среда запускает более 
новую версию. Используя прокси или маршрутизатор, весь трафик можно переключить в зеленую среду, когда команда будет 
готова. Однако синяя среда сохраняется в течение некоторого времени, что означает, что если возникнут какие-либо 
непредвиденные проблемы с новой версией, трафик можно просто снова направить в синюю среду. Мы можем думать об этом 
как о резервных копиях высокой доступности PROD во время нового развертывания, которые можно использовать для отката,
если что-то пойдет не так, что быстрее, чем выполнять откат фактической среды PROD.

#### Окружающая среда Канарских островов

Подобно средам Green и Blue, цель сред Canary — сгладить процесс развертывания PROD. Снова создаются две среды, и 
пользователи постепенно перемещаются в новую среду. Например, в начале можно перенести 10% пользователей. Если новая 
среда остается стабильной, можно перенести еще 10%, пока 100% пользователей не окажутся в новой среде. Опять же, они 
обычно классифицируются как среды PROD, но используются для снижения риска, связанного с обновлением PROD, чтобы 
ограничить потенциальные проблемы и время простоя.

#### Общие инструменты

Среды значительно изменились в наше время. Такие прорывы, как виртуализация и контейнеризация, изменили ландшафт. 
Вместо того, чтобы среды были просто компьютерами, теперь мы можем создавать виртуальные компьютеры с помощью таких 
инструментов, как Vagrant или Terraform. Мы также могли бы полностью отказаться от хостов в пользу таких вещей, как 
контейнеры с использованием Docker или pods с использованием Kubernetes . Эти инструменты могут использовать такие 
процессы, как инфраструктура как код (IaC), чтобы даже создавать программное обеспечение, которое может создавать и 
управлять этими средами.

#### Соображения безопасности

Как упоминалось ранее, соображения безопасности становятся тем важнее, чем ближе среда к PROD. Базовая 
инфраструктура приложения также является частью поверхности атаки фактического приложения. Любые уязвимости в этой 
инфраструктуре могут позволить злоумышленнику взять под контроль хост и приложение. Таким образом, инфраструктура 
должна быть защищена от атак. Этот процесс защиты обычно требует следующих вещей:
- Удаление ненужных услуг
- Обновление хоста и приложений
- Использование брандмауэра для блокировки неиспользуемых портов
- Пример из практики — обходные пути разработчиков в PROD

Одна из распространенных проблем, которая может возникнуть в разных средах, заключается в том, что часто то, что 
должно оставаться в DEV, не остается. Обходы разработки обычны в средах DEV для таких функций, как: 
- Многофакторная аутентификация
- CAPTCHA
- Сброс пароля
- Вход в порталы

Обходы разработчиков позволяют разработчикам быстро тестировать различные функции приложения, обходя трудоемкие 
функции, такие как запросы MFA . Распространенным примером является наличие определенного одноразового кода PIN (OTP)
, который всегда принимается, независимо от кода OTP, отправленного приложением.  

Однако, если не будет проведена адекватная очистка этих обходов до того, как приложение будет перемещено в следующую 
среду, это может привести к тому, что обход разработчика проникнет в PROD. Что за обход OTP? Теперь он может быть 
использован злоумышленником для обхода MFA и компрометации учетных записей пользователей.  

Вот почему среды должны быть разделены, и, подобно шлюзам качества, должны быть реализованы шлюзы безопасности, 
чтобы гарантировать перемещение чистого приложения в следующую среду.  

### Ответьте на вопросы ниже
Какая среда обычно имеет самую слабую конфигурацию безопасности?
```commandline
DEV
```
Какая среда используется для тестирования приложения?
```commandline
UAT
```
Какая среда похожа на PROD, но используется для проверки работоспособности всего перед отправкой в PROD?
```commandline
PrePROD
```
Какой распространенный класс уязвимостей обнаруживается в PROD из-за проникновения небезопасного кода из DEV?
```commandline
Developer Bypasses
```

## Задание 8
Откройте сайт и создайте свой собственный конвейер, чтобы получить свой флаг. Используйте то, чему вы научились, 
чтобы определить, какие опасения обоснованы на каких этапах конвейера! 
### Ответьте на вопросы ниже
Какой флаг вы получаете после успешного строительства трубопровода?

```commandline
THM{Pipeline.Automation.Is.Fun}
```

## Задание 9
Автоматизация в конвейере значительно увеличила возможности процессов SDLC . Она позволила разработчикам быстро создавать и развертывать обновления приложений. Однако эта новая автоматизация может также привести к увеличению поверхности атаки, поскольку злоумышленник теперь может косвенно атаковать приложение, скомпрометировав его конвейер. Поэтому необходимо реализовать безопасную автоматизацию, чтобы гарантировать, что автоматизированный конвейер не увеличит риск компрометации приложения.

В различных комнатах этого модуля мы более подробно рассмотрим элементы, из которых состоит трубопровод, и покажем, 
как можно обеспечить безопасность каждого из них, чтобы создать безопасный автоматизированный трубопровод. 
### Ответьте на вопросы ниже
Я понимаю базовую структуру конвейера и готов глубоко погрузиться в каждый элемент!
```commandline
Ответ не нужен
```
[>> вернуться на главную страницу](https://github.com/BEPb/tryhackme/blob/master/README.md)