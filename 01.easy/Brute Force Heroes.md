[>> вернуться на главную страницу](https://github.com/BEPb/tryhackme/blob/master/README.md)

# Комната [Brute Force Heroes](https://tryhackme.com/r/room/bruteforceheroes) 

Всего 9 заданий:
## Задание 1
Запустите виртуальную машину, прикрепленную к этой задаче. Это запустит измененную версию DVWA по  адресу   MACHINE_IP  . Это то, что мы будем использовать для отработки навыков и инструментов брутфорса.

Запуск виртуальной машины и связанной с ней службы может занять до 5 минут, поэтому дайте ей немного времени на раздумья. Продолжайте и прочитайте введение ниже. Не волнуйтесь, мы также включим туда ссылку для вас.
### Ответьте на вопросы ниже
Заводите моторы! Извините... ВМ!
```commandline
Ответ не нужен
```

## Задание 2
Добро пожаловать в Brute Force Hero's. Мы рассмотрим подход brute force от нуля до героя. Охватываем, что такое brute force, различные инструменты, которые мы можем использовать (несмотря на то, что вы можете подумать, что Hydra  — не  единственный вариант, который у нас есть), а также когда и почему стоит использовать эти различные инструменты.

Если вы уже знакомы с концепциями brute force, пожалуйста, пропустите этот раздел и приступайте к следующему заданию. Остальным из нас понадобится 5 минут, чтобы рассмотреть, что именно представляет собой brute force.

Что такое brute force? 

Проще говоря, brute force — это просто догадки. Хотя мы стараемся изо всех сил, чтобы сделать это понятным:



разница между тем, чтобы сделать это лично, и попыткой войти в службу или ресурс, заключается в том, что мы должны попытаться убедиться, что наши догадки не только верны, но и что мы также говорим на правильном языке и правильно отформатировали нашу догадку.

Представьте, что в приведенном выше сценарии старый школьный товарищ говорил с нами на другом языке (это была программа обмена иностранными языками). Мы могли бы гадать весь день, но мы никогда не узнаем, правильно ли мы это сделали, особенно если у нас неправильное произношение или мы строим предложения по-другому:

    Тебя зовут Дэйв?
    Тебя зовут Дэйв?
    Ты Дэйв, верно?

Если вы посмотрите на популярные инструменты, такие как Hydra,  то увидите целый ряд поддерживаемых форматов:

Поддерживает следующие форматы:  Cisco AAA, Cisco auth, Cisco enable, CVS, FTP, HTTP(S)-FORM-GET, HTTP(S)-FORM-POST, HTTP(S)-GET, HTTP(S)-HEAD, HTTP-Proxy, ICQ, IMAP, IRC, LDAP, MS-SQL, MySQL, NNTP, Oracle Listener, Oracle SID, PC-Anywhere, PC-NFS, POP3, PostgreSQL, RDP, Rexec, Rlogin, Rsh, SIP, SMB(NT), SMTP , SMTP Enum, SNMP v1+v2+v3, SOCKS5, SSH (v1 и v2), SSHKEY, Subversion, Teamspeak (TS2), Telnet, VMware-Auth, VNC и XMPP.

Обычно именно здесь у людей возникают проблемы — необходимо убедиться, что их запросы на перебор паролей соответствуют ожидаемому формату и будут приняты и обработаны принимающей службой или ресурсом так, как и ожидалось. 

Другая проблема, с которой мы можем столкнуться при попытке взломать логин методом подбора, заключается в том, что он не скрытный.

Возвращаясь к нашему сравнению с одноклассниками, после пары попыток люди поблизости начнут замечать, что вы просто называете кому-то случайные имена. То же самое произойдет, если вы будете делать случайные попытки входа пользователя в систему в сети.

Любой, кто следит за трафиком, заметит внезапное увеличение попыток входа, большинство из которых будут неверными. Это вызовет некоторые опасения. Кроме того, если у них включена автоматическая блокировка или защита от неудачных попыток, это усложнит вам задачу.

GUI против CLI

Существует множество инструментов, которые можно использовать для брут-форса. Одним из самых распространенных является популярная  Hydra .

Но это не единственный инструмент или не обязательно лучший выбор, в зависимости от ситуации. В ходе этой лабораторной работы мы рассмотрим четыре инструмента, которые можно использовать для брут-форса. Два будут основаны на графическом интерфейсе ( Burp Suite и OWASP ZAP ), а два других будут на основе CLI ( Hydra и Patator ). 

Нет необходимости иметь предыдущий опыт использования этих инструментов, так как мы рассмотрим соответствующие шаги для каждого в этой комнате. Но мы привели ссылки на несколько других комнат THM , которые могут оказаться полезными. Продолжайте и играйте!

Patator  не так известен, как Hydra. Так что если вы используете его впервые, не бойтесь! Мы расскажем обо всем, что вам нужно знать, чтобы быстро ввести вас в курс дела. Если вы используете Kali или Parrot OS, то, скорее всего, он у вас предустановлен. Если нет, вы можете установить его с помощью apt:

 sudo apt install patator

Или посетите страницу github

Если вы используете attack box, который идет с THM , и   sudo apt install patator , то для того, чтобы patator работал правильно, вам нужно будет связать его с исполняемой средой python2. Один из способов сделать это — настроить виртуальную среду python. Если вы не уверены, как это сделать, выполните следующие шаги (которые предполагают, что вы используете THM box и работаете как root):

 apt install virtualenv

 cd ~ virtualenv -p `which python2` venv

 

источник venv/bin/activate

 Затем вы должны увидеть, что перед приглашением оболочки стоит  (venv) , и что patator запускается без проблем, как в этом примере: 




Это гарантирует, что Patator связан с версией Python, которую ему нужно запустить (иначе возникнет ошибка). Если вы используете Attack Box и клонируете репозиторий GitHub, то вам не нужно будет вносить это изменение.

После установки Patator (а также других инструментов) продолжайте и переходите к следующей задаче, где мы начнем использовать Burp Suite .

### Ответьте на вопросы ниже
Прочитайте вышеизложенное и убедитесь, что вы готовы начать
```commandline
Ответ не нужен
```

## Задание 3
Первым делом загрузите прикрепленный файл паролей. Это пользовательский файл паролей, созданный специально для этой комнаты. Убедитесь, что вы сохранили его в легкодоступном месте, так как он будет часто использоваться в этой комнате.

Далее запустите Burp Suite. Начнем с использования этого для проксирования нашего веб-трафика к цели и от нее ( измененный экземпляр DVWA на  MACHINE_IP ). В зависимости от вашей версии Burp Suite вы можете использовать встроенный браузер: 



Или настройте свой браузер на использование Burp Suite в качестве прокси-сервера - Port Swigger (люди, стоящие за Burp Suite) имеют отличное руководство здесь , так что если вы не уверены, следуйте ему. Какой бы браузер вы ни использовали, ваши настройки прокси-сервера должны выглядеть примерно так:



При условии, что вы не вносили никаких изменений в настройки Burp Suite по умолчанию.

После того, как Burp Suite будет запущен и запущен, перейдите к экземпляру DVWA, указав в веб-браузере http:// MACHINE_IP . Вы должны увидеть экран входа в систему. Я рекомендую отключить перехват (он находится на вкладке Proxy->Intercept и его можно увидеть на первом снимке экрана выше). Для этой задачи он нам не нужен, и это будет очень раздражать, если вам придется вручную пересылать каждый запрос. Вместо этого мы сможем делать все, что захотим, на вкладке HTTP history. Итак, ваш экран должен выглядеть так:




Теперь попробуйте войти - Мы дадим вам имя пользователя admin - Пароль мы попробуем придумать сами. Для тех из вас, кто уже игрался с DVWA, учетные данные по умолчанию были изменены. Он уязвим, но не настолько . Сделайте несколько попыток входа и посмотрите на трафик на вкладке истории HTTP в Burp Suite . Он должен выглядеть примерно так:



Каждая попытка входа, выполненная с помощью запроса POST, встречает сообщение с кодом ответа 302, прежде чем мы будем перенаправлены обратно на страницу входа... Вы также заметите, что каждый ответ на нашу попытку входа по сути пустой. Но мы можем видеть сообщение на самой странице входа, которое гласит Login Failed . Это сообщение на самом деле является частью следующего запроса, как мы можем видеть здесь:

 
Это важно, и мы вернемся к тому, почему немного позже... Но пока. Пришло время Brute Force!

### Ответьте на вопросы ниже
Что означает код ответа HTTP 302?
```commandline
Found
```

## Задание 4
Итак, теперь у нас есть несколько реальных запросов, которые мы можем исследовать. Мы можем использовать их для шаблонизации наших запросов brute force. В нашей предыдущей аналогии у нас есть язык и то, как отформатировано предложение, нам просто нужно продолжать менять имена. Щелкните правой кнопкой мыши запрос на попытку входа в нашу историю HTTP , а затем щелкните Отправить злоумышленнику :


Затем вы должны заметить, что вкладка Intruder вверху мигает. Щелкните по вкладке, а затем щелкните  Positions  , которые будут вверху вкладки Intruder:


Далее в окне Positions нажмите  кнопку Clear  — это удалит все предустановленные позиции, которые Burp Suite предварительно заполнит для нас. Burp Suite автоматически выберет любое значение справа от '='. В нашем случае единственное значение, которое мы хотим установить в качестве позиции, которую Burp Suite будет заменять при каждой попытке, — это значение пароля. Щелкните значение пароля (в данном случае это password  , но в зависимости от того, что вы ввели, оно может быть другим) и щелкните  Add . Это установит позицию полезной нагрузки, и мы будем готовы перейти к следующему этапу.



Вкладка Intruder- >Payloads — это то место, где мы добавляем полезную нагрузку, которая будет использоваться при замене.  Burp Suite возьмет предоставленную нами полезную нагрузку и использует ее значения для замены нашего отмеченного значения.  Здесь есть несколько вариантов загрузки полезных нагрузок. Мы загрузим файл паролей, предоставленный в этой комнате, нажав  Load ...  в  разделе Payload Options [Simple List]  . Выберите загруженный вами файл passwords.txt, и вы должны увидеть загруженное содержимое, которое должно выглядеть следующим образом:



Теперь на этом этапе мы готовы начать нашу атаку. Нажмите « Начать атаку»;  если (как и я) вы используете Community Edition, то появится всплывающее окно. Вкратце, поскольку вы используете бесплатную версию, ваша атака будет ограничена. Нажмите «ОК», и затем появится само диалоговое окно атаки. Оно покажет значение полезной нагрузки, использованное в каждой попытке, код ответа и длину ответа. Это наши индикаторы того, что наши попытки входа были или не были успешными. Если мы заметим другой код ответа или другую длину ответа, мы должны исследовать эти ответы подробнее, чтобы подтвердить, была ли это успешная попытка или это была какая-то ошибка. Примером ошибки может быть использование большого файла паролей с некоторыми специальными символами, которые конечная служба не смогла правильно обработать.

Теперь. Вот где я должен признаться. На скриншоте ниже показано, как я пытаюсь взломать вход в систему методом перебора. Значение, которое я скрыл, является правильным паролем. Заметили что-нибудь странное в успешном пароле?



( Примечание для тех из вас, кто собирается просто просмотреть файл паролей, чтобы узнать правильное значение — я заменил значение в этом месте файла на правильный пароль. Мне нравится ход ваших мыслей, но это будет не так просто. Попробуйте, если не верите мне. )

Странно то, что коды ответов и длины ответов все одинаковы, даже для успешного пароля. У вас нет доказательств из диалогового  окна атаки, что это правильный пароль, но это так, я обещаю, и я даже могу это доказать (вроде как).

На изображении ниже показано, как на самом деле выглядит успешная попытка входа. Первоначальный  ответ на вход на самом деле такой же, как мы видели при наших неправильных входах, ответ перенаправления 302. Но следующий  запрос отличается! Он не перенаправляет нас на login.php (проверьте предыдущие скриншоты). Вместо этого мы переходим на страницу index.php  . Мы также видим, что в ответе на успешный  вход заголовок ответа местоположения отличается. Поэтому мы можем посмотреть на пункт назначения перенаправления, чтобы узнать, была ли наша попытка входа успешной или нет. Одна проблема: Intruder показывает нам только первоначальный ответ (само перенаправление), а не пункт назначения...




Те из вас, кто внимателен, могли заметить, что на нашем снимке экрана успешной атаки злоумышленника ответ на попытку ввода правильного пароля имел заголовок ответа с именем Location, который был установлен на  login.php . Что ж, одна из других проблем с Burp Suite заключается в том, что он повторно использует тот же исходный запрос. Это может сработать в некоторых случаях, но не для всех. Если сервер ожидает уникальный user_token для каждой попытки входа и получает один и тот же повторно используемый несколько раз, мы не сможем войти даже с правильным паролем. Возвращаясь к тому, что мы сказали в начале — формат нашего запроса должен быть таким, каким его ожидает сервер. Если это не так, мы не продвинемся далеко.

Но не теряйте надежды прямо сейчас! Мы знаем, что не сработает, и, что важно, мы знаем почему (или можем сделать несколько довольно обоснованных предположений относительно этого). Все, что нам нужно сделать сейчас, это изменить тактику. Помните, Try Harder — это хорошо и хорошо, но иногда нам нужно сочетать это с Try Smarter.

Кроме того, если вы зашли так далеко, а Burp Suite все еще выполняет  вашу попытку перебора, я бы отключил его. На данный момент, по крайней мере.

Примечание: можно использовать такие вещи, как макросы Burp Suite , чтобы помочь нам обойти использование таких вещей, как уникальный user_token . Однако это выходит за рамки этой комнаты. Я бы рекомендовал посетить  Burp Suite Basics  для получения дополнительной информации.

### Ответьте на вопросы ниже
Как проще всего отличить неудачную попытку входа в систему от успешной в приведенном выше примере?
```commandline
Location Response Header
```
Можем ли мы использовать Burp Suite для эффективного подбора пароля в этом случае? (Да/Нет)
```commandline
Nay
```

## Задание 5
Итак, мы попробовали с Burp Suite - Но оказалось, что это не тот инструмент для этой работы. 

Но это все равно была отличная отправная точка, мы смогли разработать синтаксис запроса (как формируется запрос на вход), и мы можем использовать эту информацию в дальнейшем, чтобы попробовать другой инструмент. 

Итак, это комната для брутфорса - Так что теперь мы наверняка воспользуемся Hydra , верно? 

Нет! (Кстати, вы явно не прочитали название задачи). На помощь приходит Patator!



Я выбрал Patator по нескольким причинам. Во-первых, это не очень широко используемый инструмент, несмотря на то, что (я думаю) он отлично справляется со своими задачами. Во-вторых, Hydra тоже не лучший выбор. Достаточно просто выполнить быстрый поиск, чтобы узнать, что у людей было много проблем с попытками взломать DVWA с помощью Hydra (например, эта тема здесь ) . Мы могли бы использовать другую версию Hydra, например 8.1 на Ubuntu, но давайте посмотрим, не сможем ли мы найти другой инструмент для выполнения этой работы и, надеюсь, добавим что-то новое и полезное в ваш арсенал CTF. Итак, начнем.

Итак, первым делом — давайте немного рассмотрим Patator, прежде чем начнем. Если вы запустите  patator -h , вы получите следующий вывод со списком доступных модулей  (не забудьте выполнить команду, которую мы дали вам в разделе «Введение»  , чтобы Patator мог правильно работать на AttackBox) : 



Модулей много. Мы не будем играть со всеми (сегодня), но мы видим один, который представляет для нас непосредственный интерес  http_fuzz , так что давайте рассмотрим его.  Введите  patator http_fuzz -h  и просмотрите опции для этого модуля. Рассмотрев доступные  опции, мы можем разбить нашу команду на требуемые части:

patator http_fuzz метод=< HTTP МЕТОД> \
url=<целевой URL> \
тело=<данные> \
заголовок=<заголовки> \
-x выход:<условие>

А теперь давайте оглянемся на наши запросы на Burp Suite (видите ли, не зря я заставил нас сначала использовать Burp Suite ). 


Итак, используя наши знания, мы можем составить следующую команду:

patator http_fuzz метод=POST \
url= "http:// IP_МАШИНЫ /login.php" \
body= "имя пользователя=администратор&пароль=пароль&Логин=Логин&токен_пользователя=21e0ad6d56fa24f77647ef7dabd21be8" \
header= "Cookie: PHPSESSID=lq805gkohiamc501riahr6jltk; безопасность=невозможно" \
-x выход:fgrep!=login.php

Поля url , body и header можно скопировать непосредственно из окна Burp Suite . Условие выхода проверяет, что возвращенный ответ не
содержат текст login.php .

Но нам все еще не хватает пары шагов, прежде чем мы сможем использовать это для взлома страницы методом перебора:
Нам нужно добавить нашу полезную нагрузку, чтобы мы могли постепенно заменять пароль каждый раз на пароль из нашего списка.
Мы не хотим повторно отправлять тот же user_token и значение Cookie .
К счастью, с небольшой магией bash мы можем создать скрипт для динамической генерации этих значений для нас - и нам даже не придется делать всю тяжелую работу самим, благодаря g0tm1lk  . Мы можем взять скрипт, который они сделали, и адаптировать его для наших собственных попыток перебора. Теперь наш скрипт должен выглядеть так:


```commandline
IP= IP_МАШИНЫ

CSRF= $(curl -s -c dvwa.cookie " ${IP} /login.php" | awk -F 'value=' '/user_token/ {print $2}' | cut -d "'" -f2)

SESSIONID= $(grep PHPSESSID dvwa.cookie | awk -F ' ' '{print $7}')

echo  " CSRF : $ CSRF "

echo  "PHPSESSID: $SESSIONID "

patator http_fuzz метод=POST --threads=64 время ожидания=10 \
url= "http:// ${IP} /login.php" \
0=пароли.txt \
body= "имя пользователя=администратор&пароль=FILE0&Логин=Логин&токен_пользователя= ${ CSRF } " \
header= "Cookie: PHPSESSID= ${SESSIONID} ; безопасность=невозможно" \
-x выход:fgrep!=login.php
```
NB Если вы обнаружите, что при запуске вышеприведенного кода возникают ошибки о парах k,v, попробуйте изменить 
скрипт так, чтобы вся команда patator находилась на одной строке. Например:

`
patator http_fuzz method=POST --threads=64 timeout=10 url= "http:// ${IP} /login.php" 0=passwords.txt body= "username=admin&password=FILE0&Login=Login&user_token= ${ CSRF }  header= "Cookie: PHPSESSID= ${SESSIONID} ; security=impossible" -x quit:fgrep!=login.php
`

При запуске этого скрипта вы можете заметить кое-что: когда он останавливается, нелегко сказать, какой пароль на 
самом деле правильный. Мы можем отфильтровать все неправильные пароли с помощью действия -x ignore:. Синтаксис и 
формат в основном такие же, как у действия quit. Так что все, что вам нужно сделать, это протестировать и настроить..
. Я даже сделал правильную команду ответом на вопрос 1. Так что если вы сделаете это правильно, вы знаете, что все 
готово. Если вы застряли, подумайте, какой текст будет в ответе, если результат был неверным. Мы можем игнорировать 
эти ответы и не выводить их на экран.     

Добавьте действие -x ignore: в конец существующей команды patator (сразу после действия quit), и единственным 
результатом, который вы получите, будет пароль администратора! 

### Ответьте на вопросы ниже
Какое действие мы можем использовать, чтобы отобразить только правильный пароль (ответ включает « »)?

```commandline
-x ignore:fgrep='Location: login.php'
```

Какой пароль администратора? 
```commandline
1qaz@WSX
```

## Задание 6
Поздравляем! Вы не только взломали основной логин администратора, но и сделали это, когда безопасность была установлена ​​на «Невозможно» — если вы впервые используете брутфорс, будьте впечатлены собой, время для чая и медалей всем вокруг. 

Но мы не можем долго почивать на лаврах. Помните, мы потерпели поражение на первом же препятствии с помощью инструмента с графическим интерфейсом. Так что давайте посмотрим, сможем ли мы искупить свою вину в этой области. Загрузите прикрепленный нами файл userlist.txt и начнем. Эта задача будет посвящена использованию OWASP ZAP, отличного инструмента для тестирования веб-приложений на проникновение; просто помните, что нужно воспринимать автоматические предупреждения и оповещения с долей скепсиса. Хороший пентестер должен вручную проверять перечисленные уязвимости, о которых сообщают автоматизированные инструменты, вы будете выглядеть глупо, если придет время отчета, и окажется, что инструмент (а теперь, как следствие, и вы) ошибался.

Но мы не будем здесь вдаваться в различные применения OWASP ZAP (хотя я рекомендую поиграться с инструментом и заглянуть в комнату, ссылку на которую вы найдете во введении). Мы сосредоточимся на том, как он может помочь нам в брутфорсе.  

Первым делом запустите приложение OWASP ZAP. В зависимости от используемой платформы, оно может находиться в разных местах. Если вы используете THM AttackBox, его можно найти в  меню Applications->Web-> OWASP ZAP  . В последних версиях Kali этот инструмент предустановлен и находится в Applications->Web Application Analysis-> ZAP . В более старых версиях Kali или других дистрибутивах он может быть не предустановлен. Если нет, вы можете установить его со страницы загрузки ZAP .

После запуска нажмите Manual Explore . В URL для исследования введите  MACHINE_IP , а затем нажмите Launch Browser (у вас есть выбор между Firefox и Chrome, не имеет значения, какой из них вы выберете). Это перенесет вас на главную страницу входа. Используйте учетные данные администратора, которые мы обнаружили в предыдущей задаче, и войдите в систему.   

Оттуда перейдите на страницу безопасности DVWA ( MACHINE_IP/security.php ) - измените уровень безопасности на низкий и нажмите «Отправить» :



Уровень безопасности установлен на низкий уровень (как вы можете видеть здесь)

Оттуда перейдите в раздел Brute Force ( MACHINE_IP/vulnerabilities/brute/  ). Теперь ваш экран должен выглядеть так: 




Здесь мы займемся вторым раундом грубой силы. Давайте попробуем выполнить тестовый вход с помощью ZAP, как мы делали это раньше с Burp Suite . Только на этот раз у нас есть некоторые действительные учетные данные для использования. Войдите, используя имя пользователя: admin  и пароль из последнего задания. Вы должны получить сообщение о том, что вы вошли в область администратора. Затем попробуйте выполнить тестовый вход с некоторыми неправильными учетными данными, такими как test/testing:



На вкладке «История» ZAP  мы можем сравнить два наших запроса на вход. (В нашем примере это ID 96 и 100). Один был действительным (96), а другой — нет (100) — оба получили код ответа 200, но каждый был разного размера. Поэтому мы можем это использовать. Мы знаем, что есть второй набор учетных данных для входа — но на этот раз мы даже не знаем имени пользователя, не говоря уже о пароле... Но не бойтесь. ZAP может спасти день!

В нашей последней попытке входа в запросе дважды щелкните по использованному имени пользователя (в данном случае test), затем щелкните правой кнопкой мыши и выберите Fuzz 



Это затем вызовет появление всплывающего окна с выделенным именем пользователя. Нажмите Payloads... и это откроет второе всплывающее окно. Нажмите Add...  . Это... Вы угадали , еще одно  всплывающее окно. Здесь выберите File из раскрывающегося списка вверху и выберите файл userlist.txt  , который мы предоставили:



Нажмите «Добавить» , а затем «ОК» (мы вернемся к этому первоначальному всплывающему окну). Теперь в поле Fuzzer выделите пароль, который мы использовали, а затем нажмите « Добавить»...




Вернитесь к различным всплывающим окнам, но на этот раз выберите passwords.txt, который мы использовали в предыдущей задаче. В конце у вас должно быть выделено две позиции и две полезные нагрузки. Ваше поле Fuzzer должно выглядеть так:



Не волнуйтесь, если цвета отличаются. ZAP любит быть декоративным, вот и все. Теперь нажмите Start Fuzzer . Это 
создаст новую вкладку внизу, которая показывает, что Fuzzer находится в процессе... Вы должны увидеть загрузку из 
200 ответов, все с одинаковым размером ответа (4237 байт). Щелкните один наугад, когда они проносятся мимо, и 
проверьте ответ. Прокрутите вниз, и вы увидите, что это сообщения " Имя пользователя и/или пароль неверны". Нажмите 
на столбец Size Resp. Body и организуйте результаты так, чтобы самый большой размер ответа был вверху. Через 
несколько минут вы должны обнаружить, что вы получаете другой размер ответа... Вот так:

Похоже, у нас здесь может быть победитель... Приостановите фаззер (или оставьте его работать... Но сейчас в этом, 
вероятно, нет особой необходимости. Он просто будет генерировать ненужный трафик) и проверьте ответ на наш 
выдающийся фаззинговый запрос. Он должен сказать « Добро пожаловать в защищенную паролем область <имя пользователя> 
» вместо предыдущего неверного сообщения. Вы можете либо посмотреть вкладку «Запрос»  , либо дополнительно изучить 
столбец «Полезная нагрузка», чтобы увидеть пароль, который использовался с этим именем пользователя.

Мы сделали это! Мы получили имя пользователя и пароль с нуля (вроде как). Теперь, если хотите, вы можете поиграть с 
различными настройками безопасности. Попробуйте Burp Suite снова (хотя, возможно, с меньшим, тщательно отобранным 
списком паролей и имен пользователей, если вы используете бесплатную версию). Вы даже можете попробовать свои силы в 
использовании инструментов CLI. Хотя имейте в виду, что люди сообщали о проблемах с использованием Hydra, 
поставляемой с Kali, против перебора DVWA раньше. Поэтому вам нужно убедиться, что у вас рабочая версия (не 9.1).

### Ответьте на вопросы ниже
Какое имя пользователя вы нашли?
```commandline
buster
```
Какой у них пароль?
```commandline
rhymes
```

## Задание 7
Вы думали, мы закончили? О нет! Пока нет . В конце концов, нам так весело. Верно? Верно!

Предпоследняя часть этой лабораторной работы — брутфорс SSH для самой виртуальной машины. Мы не знаем имени пользователя, но знаем пароль — в некотором роде.

Мы установили его на один из двух паролей, которые мы уже восстановили, но изменили его на закодированный  формат. Так что у нас есть несколько способов подойти к этому. Начнем с Hydra, это последний инструмент, который мы еще не использовали.

Прежде всего, мы знаем, что у нас есть два пароля, которые могут быть, поэтому нам нужно преобразовать их в закодированный формат. Помните, что это будет закодировано, поэтому не шифруйте пароли. Например, hex, base64, URL — все это примеры кодирования (и один из них я бы рекомендовал вам попробовать). Хороший ресурс, который вы можете использовать для этого, это Cyber ​​Chef  - для безопасности убедитесь, что в начале и в конце паролей нет пробелов; в противном случае вы можете перебирать их целый день, и это не сработает.

Возьмите два пароля, которые мы нашли в Задании 5 и Задании 6, закодируйте их с помощью предложенных выше форматов и создайте файл с именем encoded_passwords.txt , который содержит все закодированные варианты этих паролей, по одному в каждой строке. Как только у нас будет этот файл, вы можете использовать команду ниже для перебора входа в SSH .

 hydra -f -L список_пользователей.txt -P закодированные_пароли.txt IP_МАШИНЫ -t 4 ssh -V 

Те, кто использовал Hydra, наверняка знакомы с этим синтаксисом, но для тех, кто не знаком, давайте разберем его:
 

 -f  это заставит hydra прекратить работу, как только найдет совпадение
 -L userlist.txt   это путь к файлу имени пользователя. Если бы мы знали имя пользователя и хотели бы получить статическое значение, мы бы использовали   -l username 
 -P encoded_passwords.txt   это путь к файлу паролей. Опять же, если бы мы знали пароль и хотели получить статическое значение, мы бы использовали   -p password 
 MACHINE_IP  наша цель
 -t 4 ssh  количество потоков и режим атаки ( кажется, Hydra можно использовать не только для http_post). Вы можете указать больше потоков, но он выдаст предупреждение и предложит только 4 - Так что давайте придерживаться этого.
 -V  подробный режим — мы могли бы не включать этот параметр, если бы не хотели видеть распечатки попыток.
Вы также можете запустить  hydra help  , чтобы просмотреть различные параметры, но, на мой взгляд, он не столь информативен, как patator.   

С командой Hydra, работающей в фоновом режиме, не остается ничего, кроме как ждать, так как может потребоваться несколько сотен попыток подобрать пароль, а это может занять несколько минут... И пока мы ждем, мы можем использовать это время с пользой. Давайте посмотрим, как сделать то же самое с Patator:

patator ssh_login host=MACHINE_IP user=FILE0 password=_@@_FILE1_@@_ 0=userlist.txt 1=found_passwords.txt -x ignore:mesg='Authentication failed.' -x quit:mesg!='Authentication failed.' -e _@@_:<encoding_type> 

Давайте разберем это, как и в случае с нашей командой «Гидра»:

 ssh_login  метод, который мы будем использовать
 host=MACHINE_IP   наша цель
 user=FILE0 password=_@@_FILE1_@@_   заполнители файлов для наших паролей и имен пользователей. Если бы нам нужно было статическое значение, мы бы просто указали имя пользователя/пароль, например  user=username.  Главное, что следует отметить, это то, что наш файл паролей заключен в скобки  _@@_   . Это связано с нашей кодировкой.
 1=userlist.txt 0=found_passwords.txt  файлы для наших заполнителей. Не размещайте их в неправильном порядке!
 -x ignore:mesg='Authentication failed.'  По умолчанию patator выводит подробные данные, поэтому, если мы хотим игнорировать неудачные попытки, нам нужно включить условие  игнорирования  .
 -x quit:mesg!='Authentication failed.'  эквивалент  hydras -f, устанавливает условие выхода  . В этом случае мы выйдем, когда получим сообщение this is not  Authentication failed.
 -e _@@_:<encoding_type>  тип кодировки. Есть несколько вариантов на выбор, поэтому проверьте меню справки patator (введите patator ssh_login -h )
Patator работает немного иначе, чем Hydra . С Hydra нам пришлось указать текстовый файл, в котором уже были наши закодированные пароли. Для Patator мы можем создать текстовый файл found_passwords.txt  и передать тип кодировки в качестве параметра. Затем Patator закодирует для нас текстовый пароль с помощью этого типа кодировки. Поэтому перед запуском указанной выше команды вам нужно будет создать файл found_passwords.txt  , содержащий два пароля, найденных в Задании 5 и Задании 6, без  какой-либо кодировки. При запуске команды вы не увидите никаких выходных данных, пока мы не найдем пароль, поскольку мы игнорируем любой ответ, который возвращает Authentication failed. Однако помните, что Patator отобразит текстовый пароль без  кодировки.

Недостатком является то, что мы можем указать только один тип кодировки за раз, когда запускаем команду, поэтому вам нужно будет запустить ее несколько раз, один раз для каждой кодировки, или попробовать ее после того, как вы определитесь с типом кодировки. Но всегда полезно знать, что существует несколько способов взломать логин. 

### Ответьте на вопросы ниже
Какое имя пользователя SSH?
```commandline
tommyboy1
```
Какой у них пароль (зашифрованная версия)?
```commandline
1qaz%40WSX
```
Что это за кодировка? 
```commandline
URL
```

## Задание 8
Взлом хеша? Но я думал, что это лаборатория по перебору паролей?

Ну, это так - взлом хэша на самом деле является формой грубой силы. Это не комната взлома хэша / алгоритма, но основы, которые вам нужно знать:

Хэш-функции являются односторонними функциями. Это означает, что их легко вычислить и их должно быть трудно обратить (мы не будем здесь вдаваться в такие вещи, как SHAttered , но это стоит рассмотреть, если вам интересно)
Один и тот же ввод создаст один и тот же вывод (мы рассмотрим использование солей далее)
Так как мы не можем обратить хэш-функцию, для взлома хеша пароля, если мы знаем, какой алгоритм использовался, мы можем создать список хешей, используя общие или известные пароли (например, список слов). Затем мы можем сравнить наш созданный хэш с хешем, который мы пытаемся «взломать». Если у вас есть совпадение, вы знаете пароль. 

Так что, видите ли, когда вы взламываете хэш, вы на самом деле участвуете в атаке методом перебора, просто испытывая свою удачу, создавая хеши, пока не найдете совпадение.  Мало того, грубая сила — это тип взлома хеша — Brute force-ception.  Наиболее распространенный вариант использования взлома хеша — вы предоставляете список слов (например, популярный rockyou) и позволяете взломщику циклически проходить его, пока он не найдет совпадение для хеша. Но если у вас нет списка слов или вы уже пробовали это и ничего не добились, вы можете удвоить грубую силу и заставить взломщика создавать свои собственные пароли на лету для хэширования. Это то, что мы рассмотрим в этой задаче. 

Конечно, это не единственные методы взлома хэшей. Таблицы поиска со всеми предварительно взломанными хэшами (например, crackstation ) и радужные таблицы  — это другие методы взлома хэшей, но они также выходят за рамки этой комнаты.  Итак, вернемся к комнате и задаче — начнем!

Теперь у нас есть полный доступ SSH к нашей виртуальной машине в виде нашего имени пользователя и закодированного пароля из Задачи 7, поэтому мы можем войти через SSH и осмотреться, нет ли чего-нибудь интересного. Одна из первых вещей, которую мы можем захотеть, — это посмотреть, что может делать наш текущий пользователь, а что нет. В этом случае давайте попробуем выполнить команду sudo от имени нашего пользователя:

sudo cat /etc/shadow

Файл shadow — отличное место для начала (особенно если нам нужны какие-то хэши для взлома) — но не тут-то было... Давайте проверим права доступа к файлам shadow. Возможно, есть несколько способов cat для файла.

Если мы проверим права доступа с помощью команды ls -l /etc/shadow , то, похоже, кто угодно может прочитать файл shadow... Их ошибка — наша выгода. Кроме того, похоже, что если мы прочитаем файл, в системе есть другой пользователь. Скопируйте всю строку, начинающуюся с имени пользователя, и добавьте ее в файл на вашей машине Kali или AttackBox. В этом случае я создал файл hash.txt. Имя пользователя на скриншоте намеренно закрашено, чтобы вы могли определить правильного пользователя.



Теперь есть два инструмента, которые (по крайней мере, я так думаю) являются синонимами взлома хэшей - John the ripper и Hashcat . У обоих есть свои плюсы и минусы, и мы не будем здесь увязать в этом подробно. Можно с уверенностью сказать, что любой из них подойдет для нашей цели. Давайте начнем с Hashcat.

Если мы хотим использовать Hashcat, первое, что нам нужно сделать, это определить тип хеша, который у нас есть. Некоторым Linux-ниндзя, возможно, даже не нужно беспокоиться об этом. Но полезно знать, как  это сделать. Так что давайте начнем с этого. Если мы посмотрим на вики Hashcat, там есть ссылка, например, на Пример хешей . Если мы перейдем на эту страницу, то увидим, что она перечисляет режим хеша, имя хеша и показывает нам пример. Ваша первая задача — определить тип хеша, с которым мы имеем дело здесь, и последующий режим.

Как только у нас есть режим, мы можем построить нашу команду Hashcat. Если мы посмотрим на команду помощи Hashcat ( hashcat -h ) в конце, она покажет несколько базовых примеров. Мы можем использовать их для построения нашей команды. Сейчас обычное использование Hashcat — это использование списка слов, например

hashcat -a 0 -m <режим> hash.txt <список слов>

Но в этом случае мы не знаем, есть ли наш пароль в списке слов, и такие случаи использования очень широко распространены. Поэтому вместо этого мы воспользуемся атакой методом подбора hashcat.

hashcat -a 3 -m <режим> hash.txt <маска>

Теперь маска, по сути, является тем, как мы сообщаем Hashcat ключевое пространство для перебора. Для этого нам нужно знать несколько деталей о взламываемом пароле заранее, например, сколько символов и что это за символы (в идеале). Чем больше у нас информации, тем больше мы можем быть уверены в точности нашей маски и сократить ключевое пространство, делая нашу попытку взлома хеша методом перебора быстрее. Используя эту информацию,  мы можем использовать встроенные в hashcat  наборы символов  , чтобы создать маску, соответствующую нашему паролю, и взломать его. Например , используя наборы символов, предоставленные hashcat, если мы хотим перебрать пароль из 5 символов, состоящий  из всех цифровых символов, кроме среднего, который является заглавным символом, наша маска будет выглядеть так:

?d?d?u?d?d

Создаем нашу полную команду (если это, скажем, хэш SHA1):

hashcat -a 3 -m 100 hash.txt  ?d?d?u?d?d

Затем это будет циклически создавать пароли, соответствующие этой маске, например, 11A11, 21A11, 31A11 и т. д. Хэшируя их (используя предоставленный тип хеша, в данном случае SHA1), а затем проверяя их, чтобы увидеть, соответствуют ли они предоставленному хешу. Так что если наш хешированный пароль был 12E45, в конечном итоге это произойдет:


11A11-> Хэшировано =  1F4A4922FFFDB189E4D3D479C1376C69CC24026A  - Неверно!

11A12 -> Хэш = 6DCD18DD86B0B6350BF82EEF98A1256B0AEC7026 - Неверно!
...

...

...

11E45 -> Хэш =  3B88EF20F8305D09681CB6CF0F9EAC9963B8947E - Неверно!

12E45 -> Хэш = BBB1BD3B59508DBC913D758ECF492F3327F7B634 - Правильно!



Способ поиска пространства ключей будет зависеть от количества предоставленных символов и подробно описан в предоставленной ссылке выше. Это просто для иллюстрации того, как будет работать процесс при использовании атаки методом подбора по маске.

В нашем случае мы можем сказать вам, что пароль состоит из 5 символов и состоит из строчных символов, за исключением среднего, который является цифрой. Если вам интересно, как мы это узнали, мы использовали проверенный и испытанный метод, чтобы вычислить его, лучше всего проиллюстрированный  здесь . Вооружившись этой информацией, мы можем создать нашу маску.  Проверьте страницу, ссылку на которую вы привели выше, чтобы узнать, как отформатировать маску для проверки двух строчных символов, цифры, за которой следуют еще два строчных символа.

Теперь, когда у нас есть все  части головоломки  , пришло время взломать ее — методом перебора! Это может занять некоторое время, но это сработает, я обещаю. Если вы превысите 10% прогресса (вы можете увидеть это, введя   s  во время взлома Hashcat, чтобы просмотреть статус), что-то пошло не так. Убедитесь, что вы скопировали правильную строку и используете правильный режим, маску и т. д.

После взлома пароля Hashcat отобразит на экране найденный хэш, за которым последует двоеточие и пароль. В качестве альтернативы Hashcat запоминает найденные пароли, и вы можете выполнить следующую команду, чтобы отобразить взломанные хэши:

hashcat -m <режим> --show hash.txt

Итак, hashcat рассмотрен - что насчет Джона-риппера? Ну, команда для использования Джона не сильно отличается. Единственное важное отличие в том, что с Джоном нам не нужно  указывать тип хеша. Однако мы можем указать тип с  флагом формата или запустить его без него, и Джон сделает все возможное, чтобы  автоматически  вычислить тип хеша. Для нашего хеша мы можем просто запустить следующее:

джон хэш.txt --mask=<маска>

Используя ту же маску, что и в Hashcat (для просмотра параметров маски обратитесь к соответствующим документам ), Джон взломает хеш так же, как Hashcat. Из-за того, как он исследует пространство поиска, ему может потребоваться до 50% прогресса, чтобы найти пароль. Аналогично, вы можете передать Джону опцию --show  , чтобы снова отобразить взломанные пароли  после того, как пароль будет найден .


БОНУС :
В домашнем каталоге нового пользователя есть папка, содержащая скрипт Python и файл .txt. Если вы хотите еще немного поиграться с использованием масок и взломом хэшей, смело используйте содержимое этих файлов.

Если вы прочитаете скрипт Python, вы увидите, что он использует хэш и соль — помните, что мы говорили ранее о том, как одни и те же входные данные создают одни и те же выходные данные? Что ж, один из способов, с помощью которого люди обошли эту проблему, — это использование соли. Соль — это значение, которое не является частью начального значения/пароля, но которое может быть добавлено или добавлено в начало во время процесса хэширования, так что тот же пароль создает другой  хэш. 

Имейте в виду, если вы хотите попытаться перебрать этот хэш с помощью атаки по маске, это займет много времени  , поэтому мы не включили его сюда. Но это может дать вам представление о том, сколько времени займет попытка перебрать хэш в реальной пользовательской ситуации. Вы также можете использовать атаку по списку слов для этого (предоставленный файл паролей отлично подойдет в качестве списка слов). Просто убедитесь, что у вас правильный режим (см. Примеры  хэшей ) .

Последнее замечание - если вы посмотрите на страницу, например, хэши, вы заметите, что их много . Различные используемые алгоритмы снова могут быть сделаны разными в зависимости от использования солей и даже того, где находится соль (до или после пароля). Вы можете получить представление об этом, просто просматривая страницу. Очевидно, что в этой теме много всего, что выходит за рамки этой комнаты, но если вы хотите узнать больше, хорошим местом для начала может быть Хеширование против шифрования против кодирования  , а также Как работает хеширование . 

### Ответьте на вопросы ниже
Пароль какого пользователя мы можем взломать?
```commandline
crackme
```

Какой режим нам нужен для хэша пользователя?

```commandline
1800
```

Что такое взломанный пароль?

```commandline
cr4ck
```

Какое значение маски нам нужно использовать?

```commandline
?l?l?d?l?l
```

## Задание 9
Вот и все. Вы достигли конца, и если вы справились со всем вышеперечисленным, теперь вы можете называть себя героем грубой силы и в вашем поясе для инструментов есть еще несколько инструментов. 

Самое главное, вы, надеюсь, знаете не только, как использовать эти инструменты, но и какие инструменты можно использовать, когда и почему их следует (или не следует) использовать. Знать, какую команду запускать или как ее запускать, это здорово. Но если вы знаете, почему , это самое главное, потому что вы обнаружите, что застреваете гораздо меньше.

Так что спасибо за то, что прошли комнату. Материал, рассмотренный в этой комнате, был частично взят (с разрешения) из курса магистратуры по кибербезопасности.

Эту комнату создали я ( kafaka157 ) и Гейзенберг .
### Ответьте на вопросы ниже
Прочитайте выше
```commandline
Ответ не нужен
```

[>> вернуться на главную страницу](https://github.com/BEPb/tryhackme/blob/master/README.md)