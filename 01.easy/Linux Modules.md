[>> вернуться на главную страницу](https://github.com/BEPb/tryhackme/blob/master/README.md)

# Комната [Linux Modules](https://tryhackme.com/r/room/linuxmodules) 

Всего 14 заданий:
## Задание 1
Эта комната полностью основана на, можно сказать, повторении, или может помочь вам лучше ознакомиться с терминалом. 

Примечание: Эта комната предназначена исключительно для ознакомления с командной строкой (поэтому никаких первых 
кровей; только баллы), поэтому не нужно торопиться, не торопитесь, выполняя эту комнату. Подсказки с заданиями могут 
содержать прямые ответы, поэтому заглядывайте туда на свой страх и риск.  

Коротко о том, что нас ждет впереди:
- du
- grep, egrep, fgrep
- tr
- awk
- sed
- xargs
- curl
- wget
- xxd
и еще кое-что...

Я создал этот список, чтобы иметь возможность читать их документацию по одной, и эта комната для того, чтобы 
избавить вас от чтения всех этих длинных страниц руководства, где (во время чтения) вы можете не знать точного 
значения используемого флага, так как вы могли только что начать использовать Linux или, возможно, не использовали 
его до такой степени, чтобы столкнуться с этой конкретной темой. Надеюсь, вы поняли идею...    

Область применения этой комнаты

Эта комната основана на понимании этих инструментов, чтобы они могли сократить наши усилия при работе с командной 
строкой. Кроме того, этот навык, который вы разовьете, поможет вам эффективно управлять сеансами терминала при 
работе над пентестом или любым проектом.  

Просто убедитесь, что вы используете виртуальную машину Linux, чтобы вы могли приступить к работе, если захотите. 
Или просто запустите attackbox (бесплатные пользователи могут развернуть attackbox на час, что, я думаю, вполне 
достаточно для завершения этой комнаты). Я настоятельно рекомендую завершить комнаты «Основы Linux», прежде чем 
продолжать изучать эти темы.    

Приятного обучения ;)

Изображение баннера — фотография Майкла Дзедзича на Unsplash
### Ответьте на вопросы ниже
Прочитайте вышеизложенное.
```commandline
Ответ не нужен
```

## Задание 2
О Командовании

du это команда в linux (сокращение от disk usage), которая помогает вам определить, какие файлы/каталоги занимают 
сколько места. Если вы выполните простую команду du в терминале... 

Вывод терминала после запуска команды du, показывающий размер и путь><br></p><p style=

Папки в соответствующих папках перечислены здесь с размером, который они занимают на диске. Размер здесь указан в КБ.
Примечание: файлы внутри папки не отображаются, только папки перечислены с помощью команды du /<directory>.

#### Важные флаги
Флаг	Описание
- -а	Также будет выведен список файлов вместе с папкой.
- -h	Перечислит размеры файлов в удобном для чтения формате (Б, МБ, КБ, ГБ)
- -с	Использование этого флага выведет общий размер в конце. Jic вы хотите найти размер каталога, который вы перечисляли
- -d <number> 	Флаг, указывающий глубину каталога, для которого вы хотите просмотреть результаты (например, -d 2)
- --time 	Чтобы получить результаты с отметкой времени последнего изменения.


Примеры

`du -a /home/` выведет список всех файлов в каталоге /home/ с указанием их размеров в КБ.

Если вывода много, то, конечно, можно использовать grep...

`du -a /home/ | grep user` выведет список всех файлов/каталогов, имена которых содержат строку « user ».

Заключительные слова

Команда du может чередоваться lsсо следующими флагами:

`du --time -d 1 .`

Однако он не будет указывать владельца файла, поэтому вы можете использовать stat команду для файла, который вы 
хотите узнать, кто является владельцем этого конкретного файла.  

Синтаксис:stat

### Ответьте на вопросы ниже
Прочитайте вышеизложенное
```commandline
Ответ не нужен
```

## Задание 3
ВАЖНО: Чтобы продолжить выполнение этой задачи, убедитесь, что вы завершили комнату " Регулярные выражения " по  
concatenate . Эта комната расскажет вам о регулярных выражениях, которые могут пригодиться при работе с egrep.  

Есть много комнат, в которых вы, должно быть, уже много раз использовали grep, так что большая часть этой задачи 
покажется вам знакомой, или это ваша первая попытка прочитать о grep, в любом случае, 5-минутное чтение не повредит 
вашему насыщенному дню...  

Введение

Это инструмент, который должен знать каждый, и поэтому модули Linux не будут полными, если не упомянуть его 
удивительную харизму. Этот инструмент — то, что отфильтровывает нужный нам хороший вывод из остатка. Официальная 
документация гласит:  Фильтр grep ищет в файле определенный шаблон символов и отображает все строки, содержащие этот 
шаблон. Шаблон, который ищется в файле, называется регулярным выражением.  Шаблон — это то, о чем я собираюсь вас 
проинформировать.    

Синтаксис: grep "PATTERN" file.txtбудет искать в файле file.txt указанную строку «PATTERN», если строка найдена в 
строке, grep вернет всю строку, содержащую строку «PATTERN».   

Генеалогическое древо

egrep и fgrep ничем не отличаются от grep (кроме двух флагов, которые можно использовать с grep для работы в обоих 
режимах). Проще говоря, egrep сопоставляет регулярные выражения в строке, а fgrep ищет фиксированную строку внутри 
текста. Теперь grep может выполнять обе свои функции, используя флаги -E и -F соответственно.   

Другими словами, grep -Eфункции такие же, как egrep и grep -F функции такие же, как fgrep.

Важные флаги

Флаги	Описание
- -R	Выполняет ли grep рекурсивный поиск файлов внутри папок (если они найдены по указанному пути для поиска по 
шаблону; в противном случае grep не будет обходить каталоги для поиска по указанному шаблону)
- -h	Если вы выполняете рекурсивный поиск в каталоге, этот флаг отключает префикс имен файлов в результатах.
- -с	Этот флаг не выведет вам шаблон, а только целочисленное значение, указывающее, сколько раз шаблон был найден в 
  файле/папке.
- -i	Я предпочитаю использовать этот флаг большую часть времени, он указывает grep искать ШАБЛОН, ИГНОРИРУЯ регистр. 
- -l 	отобразит только имя файла, а не найденный в нем шаблон.
- -n	Он выведет список строк с их номерами в файле, содержащем шаблон.
- -v	Этот флаг выводит все строки, НЕ содержащие шаблон.
- -E	Этот флаг, о котором мы уже говорили выше, будет рассматривать ШАБЛОН как регулярное выражение для поиска 
  совпадающих строк. 
- -е	В официальной документации говорится, что его можно использовать для указания нескольких шаблонов, и если 
  какая-либо строка соответствует шаблону(ам), она будет выведена в список.

Вам может быть интересно, в чем разница между флагами -E и -e. Я предлагаю понимать это следующим образом:

Флаг -e можно использовать для указания нескольких шаблонов с помощью многократного использования флага -e (grep -e 
PATTERN1 -e PATTERN2 -e PATTERN3 file.txt), тогда как -E можно использовать для указания одного единственного 
шаблона (нельзя использовать -E несколько раз в одном операторе grep).  
Другой момент, который можно использовать для понимания разницы, заключается в том, что -e работает с BRE (базовыми 
регулярными выражениями), а -E работает с ERE (расширенными регулярными выражениями). 

BRE, как правило, соответствуют одному шаблону в файле (простейшими примерами могут быть прямые слова, такие как «солнце», «комический»).
ERE, как правило, соответствуют 2 или более шаблонам в файле (чтобы выбрать несколько слов, например (sun sunyon sandston), шаблон может быть "^s.*n$"). 
Надеюсь, вы поняли, как это работает. 

Вот действительно короткая заметка, которую вы, возможно, захотите прочитать, в официальной документации GNU:  Basic 
vs Extended (GNU Grep 3.5) . Если вы не поняли многого из этого параграфа, убедитесь, что вы хорошо попрактиковались 
в использовании регулярных выражений.

### Ответьте на вопросы ниже
Прочитайте выше
```commandline
Ответ не нужен
```
Есть ли разница между egrep и fgrep? (Да/Нет)
```commandline
Yea
```
Какой флаг использовать для вывода списка всех строк, НЕ содержащих «ШАБЛОН»?
```commandline
-v
```
Загрузите указанный выше файл и ответьте на следующие вопросы.
```commandline
Ответ не нужен
```
Какого пользователя вы нашли в этом файле?
```commandline
bobthebuilder
```
Какой пароль у этого пользователя?
```commandline
LinuxIsGawd
```
Можете ли вы найти комментарий, который только что оставил этот пользователь?
```commandline
fs0ciety
```

## Задание 4
Я думаю, что с этого момента все будет немного по-другому, кроме поиска шаблонов. Чтобы все было максимально просто, 
мы начнем с короткой заметки о том, что и где. 

Манипуляции со строками (STRing OPerationS)

Многие люди отказываются от этой темы в своих руководствах/курсах, что, по моему мнению, оставляет позади истинную 
мощь Linux и его терминального интерфейса. Вы когда-нибудь видели, как кто-то набирает очень длинную команду, 
передавая свои выходные данные в другие команды? Ну, поверьте мне, когда я говорю, вы можете выбрать один байтовый 
символ из массива строковых байтов длиной в ГБ, если вы сможете это освоить.    

Если вы программист, то, возможно, использовали индексацию в массивах, срезы в python или даже grepping в терминале..
. Все это средства манипуляции строками. Особенно в bash, у нас есть ТОННА инструментов для выполнения одного и того 
же типа операций с различными флагами или указанными шаблонами строк, но, очевидно, мы выберем тот, который 
предоставляет нам самый короткий и простой синтаксис.    

Для ремней у меня есть следующие инструменты, которые я всегда держу в своем арсенале, и вам тоже стоит их иметь:
- tr
- awk
- sed
- xargs


Другие команды, с которыми следует ознакомиться:
- sort
- uniq


Я покажу вам команды, упомянутые выше, в следующих заданиях.  

### Ответьте на вопросы ниже
Нажмите любую клавишу, чтобы продолжить...
```commandline
Ответ не нужен
```

## Задание 5
Команда Translate( tr) может помочь вам несколькими способами, начиная от изменения регистра символов в строке и 
заканчивая заменой символов в строке. Она великолепна в своем использовании. Плюс, это самая простая команда и 
обязательный модуль для быстрых операций со строками.  

Синтаксис:
`tr [flags] [source]/[find]/[select] [destination]/[replace]/[change]`

Я полагаю, это подходящее представление того, как можно использовать этот инструмент. Более того, у нас есть 
следующие флаги, предлагаемые этой командой: 



#### Флаги

Описание
-d	Чтобы удалить заданный набор символов
-t	Для объединения исходного набора с целевым набором (целевой набор идет первым; t означает усечение)
-s	Чтобы заменить исходный набор на целевой набор (s означает сжатие)
-с	Это карта REVERSE в этой игре, например. Если вы укажете -c с -d для удаления набора символов, то будут удалены все остальные символы, оставляя исходный набор, который мы указали (c означает дополнение; как при выполнении обратного действия).
Вы, должно быть, заметили слово "набор" при чтении флагов. Ну, это правда... команда tr работает с наборами символов.

Примеры

Если вы хотите преобразовать все буквенные символы в заглавные.
Терминальный вывод простой команды cat, а также преобразованный в верхний регистр вывод><span style=

Или я не уверен, если вы когда-либо использовали эмодзи в Discord, потому что в приложении для ПК вы можете 
использовать эмодзи, используя :keyword:. Аналогично, tr позволяет нам выбрать набор по этим ключевым словам. В этом 
случае вывод будет таким же.  

`cat file.txt | tr -s '[:lower:]' '[:upper:]'`

Есть еще больше таких (интерпретированных последовательностей), которые вы можете просмотреть, просто tr 
--helpнабрав команду. Я не включаю их сюда, потому что они просто прямые, и вы использовали большинство из них, если 
вы знакомы с (в основном) каким-либо языком программирования.   

Если вы хотите просмотреть учетные данные пользователя, представленные в цифрах.
### Терминал

Вы можете видеть, что я использовал здесь регулярное выражение и удалил все строчные и заглавные символы, включая 
символ (:) и пробел. 

Примечание: Это краткая заметка о том, как вы можете использовать этот инструмент. Теперь попробуйте эти функции 
самостоятельно и привыкните к этому инструменту. Вы также можете обратиться к следующим сайтам для получения 
дополнительной информации об инструменте:  
- Команда tr в Unix/ Linux с примерами - GeeksforGeeks
- Команда Tr в Linux с примерами | Linuxize
### Ответьте на вопросы ниже
Прочитайте вышеизложенное.
```commandline
Ответ не нужен
```
Запустите команду tr --help и скажите, как выделить любой цифровой символ в строке?
```commandline
:digit:
```
Какая последовательность эквивалентна набору [a-zA-Z]?
```commandline
:alpha:
```
Какая последовательность эквивалентна выбору шестнадцатеричных символов?
```commandline
:xdigit:
```
## Задание 6
Команда AWK

Это самый мощный инструмент в моем арсенале, я не могу вспомнить ни одной другой команды, которая может что-то 
делать, кроме awk. Это как инструмент «все в одном». Если вы когда-нибудь играли в CSGO, вы можете полностью связать 
AWK с AWP.  

«Awk — это язык сценариев, используемый для обработки данных и создания отчетов. Язык программирования команд awk не 
требует компиляции и позволяет пользователю использовать переменные, числовые функции, строковые функции и 
логические операторы». 

Si обозначает: Просто потому, что это супер-инструмент, не обязательно, что нет необходимости изучать другие 
инструменты. Команды awk могут быть довольно длинными для решения операции, чем команды sed или xargs.  Проект GNU 
awk (а именно gawk), который также установлен в каждом дистрибутиве Linux, совместим как с awk, так и с nawk 
(New-awk; также проект AT&T).    

Синтаксис:awk `[flags] [select pattern/find(sort)/commands] [input file]`

Примечание: awk поддерживает получение вывода через конвейер.

Если написанные вами команды находятся в скрипте, вы можете выполнить команды скрипта, используя флаг -fи указав имя 
файла скрипта. `( awk -f script.awk input.txt) `

#### Использование AWK

Чтобы просто распечатать файл с помощью awk.
Вывод одного и того же файла, один раз с помощью cat и один раз с помощью awk

Вы можете увидеть, что это просто распечатанные данные из file.txt.

Чтобы найти шаблон внутри файла, вы заключаете шаблон в косые черты /pattern/. Например, если я хочу узнать, кто 
участвует в соревнованиях CTF, команда должна быть такой:awk `'/ctf/' file.txt` 

#### Встроенные переменные в AWK

Давайте немного поговорим о некоторых встроенных переменных. Встроенные переменные включают переменные поля ($1, $2, 
$3 .. $n). Эти переменные поля используются для указания фрагмента данных (данных, разделенных разделителем, по 
умолчанию пробелом). Если я запущу его, awk '{print $1 $3}' file.txtон выведет мне список слов, которые находятся в 
1-м и 3-м полях.   

Вы видите, он объединил слова вместе, потому что мы не указали разделитель вывода. Мы вернемся к этому позже в этой 
задаче. Прямо сейчас давайте просто используем "," (запятую), чтобы добавить пробел. 

Примечание: Вы можете заметить использование {} вокруг оператора print, именно там мы использовали функцию. Чтобы 
использовать команды в скриптах awk, вам нужно упомянуть их внутри функции. 

Отлично, это кажется немного милым.

Примечание: переменная $0 указывает на всю строку.   Также обязательно используйте одинарные кавычки ('') для 
указания шаблонов , awk обрабатывает двойные кавычки ("") как необработанную строку. Чтобы использовать двойные 
кавычки, обязательно экранируйте каждый знак ($) обратной косой чертой (\), чтобы все работало правильно.  

Подробнее о переменных

NR: (Number Record) — это переменная, которая ведет подсчет строк после выполнения каждой строки... Вы можете 
использовать команду NR для нумерации строк (awk '{print NR,$0}' file.txt). Обратите внимание, что awk рассматривает 
строки как записи.  

FS: (Разделитель полей) — это переменная, которую нужно задать, если вы хотите определить поле для входного потока. 
Разделитель полей (по умолчанию — пробел), о котором мы говорили выше, можно изменить на любой другой при указании 
шаблона. FS можно определить как другой символ(ы) (да, может быть во множественном числе) в BEGIN{команда}.


Если вы еще не знаете BEGIN, воспринимайте его как шаблон, который мы указываем, а следом следует действие по этому 
шаблону. Аналогично, есть команда END, это также шаблон, который мы указываем, следом следует действие, которое 
нужно выполнить по этому шаблону, и просто мы используем их для определения действий , таких как разделитель полей, 
разделитель записей и т. д., которые должны быть выполнены в начале и в конце скрипта соответственно.

`awk "BEGIN {FS='o'} {print $1,$3} END{print 'Total Rows=',NR}"`

Вывод странный, потому что я разделил поля, используя букву, которая имела смысл со словами в тексте. Короче говоря, 
это то, как на самом деле пишется полный скрипт в awk. 

RS : (Разделитель записей): По умолчанию строки разделяются символом «\n», вы можете указать и другой символ.


Обратите внимание, что была создана новая строка везде, где использовалось 'o'. Она также интерпретировала '\n', 
использованное в текстовом файле, поэтому есть новые строки после окончания каждого числа. 

OFS : (Разделитель выходных полей) Вы, должно быть, уловили некоторую идею по полной форме, она заключается в 
указании разделителя при выводе...  

Я использовал OFS в обеих командах, вы можете видеть, что только во второй из них был использован разделитель. 
Обратите внимание, что разделитель выходных полей будет разделять поля с помощью (:) только когда поля определены с 
помощью оператора print. С $0 у меня не было ничего другого, если бы это было $0,$0, то строки бы соединяли свое 
отражение (не боковое) двоеточием (:).    


ORS: (Разделитель выходных записей) Я не думаю, что мне действительно нужно указывать его использование...


Моим разделителем был двойной символ новой строки.

Это не то... В AWK есть еще много всего, можно выполнять операции, находить длину строки, использовать условия для 
сортировки, регулярные выражения в awk и другие забавные вещи. Но я думаю, что задача уже и так затянулась. Давайте 
быстро перейдем к некоторым важным флагам, которые могут пригодиться при выполнении strops.    

JIC, если вы хотите узнать больше об этом инструменте, вот несколько замечательных ресурсов по написанию скриптов на awk.

AWK - Рабочий процесс - Tutorialspoint  (Для быстрого и краткого изучения сценариев awk)
Оператор printf в awk (если вы хотите сделать больше с форматированием строк, вы также можете использовать функцию printf)
Команда AWK в Unix/ Linux с примерами - GeeksforGeeks
А если вы действительно хотите глубоко изучить этот инструмент, ознакомьтесь с man-страницами на gawk. 
Важные флаги

Флаги	Описание
- -F	С помощью этого флага вы можете указать РАЗДЕЛИТЕЛЬ ПОЛЕЙ (FS), и, таким образом, вам не нужно использовать 
правило BEGIN.
- -v	Может использоваться для указания переменных (как мы это делали в BEGIN{OFS=":"}
- -D Вы можете отлаживать свои .awk-скрипты, указав этот флаг( awk -D script.awk) 
- -о	Указать выходной файл (если после флага не указано имя, то по умолчанию используется файл awkprof.out)

Есть и другие флаги, но они не очень полезны. Особенно если вы изучаете это как новичок

Просто расслабьтесь, если вы не получаете многого от этой задачи, изучение языка сценариев в рамках одной задачи - 
нелегкая работа. Просто убедитесь, что вы хорошо поняли вышеизложенный синтаксис и следовали ресурсам, остальное - 
практика :-).  

Завершая эту задачу забавным фактом, AWK сокращенно назван в честь его создателей ( Ахо, Вайнбергер и Керниган).



### Ответьте на вопросы ниже
Прочитайте вышеизложенное.
```commandline
Ответ не требуется
```
Загрузите указанный выше файл и используйте команду awk, чтобы вывести следующий вывод:

IPPSEC: 34024
Джон: 50024
thecybermentor: 25923
liveoverflow: 45345
nahamsec: 12365
сток: 1234

```commandline
awk 'BEGIN{FS=" "; OFS=":"} {print $1,$4}' awk.txt
```
Как вы сделаете вывод следующим (их может быть несколько; ответьте, используя указанные выше переменные в шаблоне BEGIN):

IPPSEC, Джон, Thecybermentor, LiveOverflow, Nahamsec, Сток,
```commandline
awk 'BEGIN{ORS=", "} {print $1}' awk.txt
```

## Задание 7
Напоминает мне диалог "Вот что она сказала". Но это было у меня на уме с тех пор, как я начал создавать эту комнату. 
Nvm, так что sed. - это. 2-й по мощности инструмент из всех. Я особенно рассматриваю использование sed большую часть 
времени, потому что это то, что она сказала... шутка, это потому, что он предлагает большое количество strops в 
коротких командах. Просто в использовании, как только выработается привычка.

#### Жизнь седа

sed (Stream EDitor) — это инструмент, который может выполнять ряд строковых операций. Вот несколько из них: НАЙТИ И 
ЗАМЕНИТЬ, поиск, вставка, удаление. Я думаю, что sed — это потоково-ориентированный редактор vi... Итак, возникло 
несколько вопросов, например, как? и что такое потоково-ориентированный? Давайте не будем углубляться в потоки, 
просто помните, что я сказал это в противовес «ориентации с входным потоком». Вы не можете назвать vi 
потоко-ориентированным, потому что он не работает ни с входным, ни с выходным потоком. Так что пользователи vi могут 
свободно использовать свой предыдущий опыт работы с vim, чтобы связать все воедино.

С другой стороны, вы можете легко выполнять операции с командой sed, либо перенаправляя ввод, либо перенаправляя(<) 
ввод из файла. Я предпочитаю sublime, а не vim для создания заметок (без обид фанатам/фанаткам vim, я просто 
использую sublime, чтобы хранить такие вещи, как форматирование заметок в GUI :).

Синтаксис:sed [flags] [pattern/script] [input file]

#### Важные флаги

Флаги	Описание
- -е	Чтобы добавить скрипт/команду, которую необходимо выполнить с шаблоном/скриптом (при поиске шаблона)
- -f	Укажите файл, содержащий шаблон строки
- -E	Используйте расширенные регулярные выражения 
- -n	Подавить автоматическую печать или интервал между шаблонами

#### Команда sed

Существует бесконечное множество способов использования sed. Я собираюсь провести вас через очень подробный общий 
синтаксис (в основном всех) шаблонов sed с некоторыми общими примерами. Остальное — ваше мышление и креативность, то,
как ВЫ используете этот инструмент.  

' [условие(я)(необязательно)]  [команда/режим(необязательно)] / [исходный/искомый шаблон(обязательно)] / [заменяемый шаблон(зависит от используемой команды/режима)] / [аргументы/флаги для работы с искомым шаблоном(необязательно)] '

Надеюсь, эти цвета помогли вам идентифицировать части. Если у вас есть какие-либо предыдущие знания о sed, не 
стесняйтесь сопоставлять. Опять же, это просто шаблон внутри команды sed (исключая внешние флаги). Также обратите 
внимание на одинарные кавычки в начале/конце.  

Хм, но может быть, это все еще не ясно. Хорошо, давайте возьмем простой пример, чтобы связать это.

`sed -e '1,3 s/john/JOHN/g' file.txt`

Давайте не будем беспокоиться о значении 1,3, всех этих слешей, s,g. И сосредоточимся на цветовых кодах. Надеюсь, 
синтаксис теперь немного проясняется  ...  Отлично. Переходим к режимам и аргументам. 

Режимы/Команды

Команды	Описание
- s	- (Наиболее используемый)Режим замены (режим поиска и замены)
- у	- Работает так же, как и подстановка; единственное отличие в том, что она работает с отдельными байтами в 
  предоставленной строке (этот режим не принимает аргументов/условий)

[Обновление] Я использовал слово «режим» в остальной части задания, чтобы избежать путаницы с использованием команды
(s/y) внутри команды(sed). Но для ясности, официальная документация перечисляет их как команды, используемые в sed. 

#### Аргс

Флаги/Аргументы	Описание
- /g	- глобально (любое изменение шаблона будет затронуто глобально, т.е. по всему тексту; обычно работает с 
  режимом s) 
- /i	- Чтобы сделать поиск по шаблону нечувствительным к регистру (можно комбинировать с другими флагами)
- /d	- Удалить найденный шаблон (удаляет всю строку; не принимает никаких параметров, таких как 
  условия/режимы/строка для замены)
- /р	- выводит соответствующий шаблон (если не подавлено флагом -n, в выводе будет обнаружен дубликат).
- /1,/2,/3../n	- Выполнить операцию над n-ным вхождением в строке (работает в режиме s)
Давайте посмотрим на это в действии... Объясняем ранее принятую команду  ( sed -e  ' 1,3 s / john / JOHN / g '  file.txt) 

#### Начиная с ключевого слова sed, инициализирует команду sed.
- С флагом -e, указывающим, что далее следует команда скрипта. (Вам не нужно указывать -e, если это одна команда, так 
как она будет автоматически интерпретирована sed как позиционный аргумент)
- Затем идет шаблон. Начиная с  желтой  части, идет условие (или выбор диапазона, если быть точным), указывающее, что 
  нужно взять диапазон строк 1, 3 (индекс строки начинается с 1) и выполнить следующий код в этом диапазоне строк. 
  После пробела идет режим  , указывающий, что нам нужно использовать режим подстановки (поскольку мы подставляем 
  значение) с помощью s. Затем мы указываем / в качестве разделителя, чтобы различать части кода. После первой косой 
  черты идет шаблон,  над  которым мы хотим выполнить подстановку (вы также можете использовать regex в этой области)
  . После второй косой черты идет строка,  на  которую мы хотим заменить шаблон. Наконец, после последней косой 
  черты идет аргумент/флаг, /g указывает, что эту операцию нужно выполнять глобально, где бы ни был найден шаблон.      
- Наконец, было указано имя файла, из которого мы хотим получить входные данные, и применить указанную нами рядом 
  операцию/код.
- Надеюсь, что не возникнет путаницы в отношении sed.  Следовательно, вывод для указанной выше команды будет таким:


Давайте рассмотрим еще несколько примеров, чтобы прояснить концепцию:

Просмотр ряда линий


Флаг -n подавил вывод, и мы получили дубликаты, созданные аргументом p.

Просмотр всего файла, за исключением указанного диапазона


Просмотр нескольких диапазонов строк внутри файла


Чтобы начать поиск с n-го вхождения шаблона в строке, можно использовать комбинацию /g с /1,/2,/3.


Вы можете видеть, что когда я указал /1, это дало изменение в тексте, с /2 — нет. Это потому, что было только 1 
вхождение строки "youtube", а 2-е вхождение не удалось найти. Также я не использовал 1g или 2g, потому что не было 
дальнейших вхождений шаблона, поэтому нет необходимости использовать его. Тем не менее, это сработало бы так же, 
если бы использовалось. Попробуйте сами.    

Если у вас есть файлы журналов для просмотра, в которых есть конечные пробелы, и их трудно прочитать, то вы можете 
исправить это с помощью регулярных выражений. 


Давайте рассмотрим последний пример использования команды sed. 

Подробнее о регулярных выражениях можно узнать: Сделать так, чтобы каждая строка начиналась с маркера и заключать 
цифры в квадратные скобки... Хорошо, но как? Давайте сначала рассмотрим его, а затем рассмотрим объяснение.  


 «Что это?! Откуда взялось это :alpha:? Я понимаю, что \b — это часть регулярного выражения, которое вы использовали,
 после них неопознанные экранированные символы и некоторые \1 и \2, на которые ссылаются неправильно, так как /1, /2 
 идентифицируют n-ное вхождение. Я имею в виду, это так сбивает с толку».  

Согласен, это так шумно и трудно читать. Но поверьте, 70% этого не имеет никакого отношения к  sed, это все 
регулярные выражения, так что не торопитесь. Постарайтесь понять, что делает регулярные выражения. Остальная часть 
"to-be-replaced" - это просто способ, которым sed назначает группы своим переменным по умолчанию, которые мы создали 
в регулярных выражениях.   

Объяснение

`sed ' s / \(^\b[ [:alpha:] ]*\)\([ [:digit:] ]*\) / \=\> \1 \[ \2 \] / g ' file.txt`

Надеюсь, что все немного прояснилось, если принять во внимание знания предыдущего цветового кодирования. Вы можете 
легко отличить режим, шаблон, строку, которую нужно заменить. Позже я удалил фон из части, принадлежащей ключевым 
словам в sed. Поскольку возникла некоторая проблема с изменением цвета шрифта, он просто не сохраняется.

Начинаем с части регулярного выражения. Открываем группу с помощью escape-символа, ^ для установки курсора в начало 
строки, а затем \b представляет поиск начала слова, а затем определяет набор символов для включения, за которым 
следует "*", чтобы указать 'n' количество символов. Затем закрываем группу, экранируя закрывающие скобки. Создавая 
другую группу регулярных выражений, используя escape-последовательность, мы затем инициализируем другой набор и 
указываем * в конце набора, чтобы взять n символов этого набора, наконец, группа закрывается с помощью 
escape-последовательности.      
В замененном конце мы используем управляющие последовательности для создания маркера (это просто хорошая практика — 
использовать управляющие последовательности с каждым символом, даже если вывод тот же), затем у нас есть управляющие 
символы для квадратных скобок, заключающих в себе переменную sed /2 (после /1, которая будет показана далее).   
Теперь очередь за ключевыми словами sed. Мы использовали [:alpha:] в наборе, определенном regex, что является ничем 
иным, как другим представлением использования a-zA-Zв regex, что означает захват любых буквенных символов. sed 
предлагает такие ключевые слова (называя их «выражениями в скобках»), которые мы можем использовать, чтобы сделать 
входной код более чистым. Аналогично мы использовали выражение в скобках для указания цифры, которую мы указали с 
помощью [:digit:].    
Примечание: после первого выражения в скобках внутри набора регулярных выражений есть пробел ([[:alpha:]{space}]). 
Как видите, этот пробел должен был обозначать набор регулярных выражений, чтобы * мог занимать несколько слов, пока 
цифры не начнут встречаться в тексте (логика регулярных выражений).

Затем есть некоторые встроенные переменные, как мы видели в awp awk, которые мы использовали в части to-be-replace 
sed. \1 изображает первую группу, которая выбирает все, пока не встретится первый символ. Вторая группа состоит из 
набора, состоящего из десятичных символов, которые были заключены в [\2] с использованием escseq.  
На этом мы закончили изучение переменных sed. Количество групп, которые вы создаете с помощью регулярных выражений, 
впоследствии может быть проиндексировано как переменная \n в sed. 

Ну, это почти все, о команде sed. Если вы хотите узнать больше, ознакомьтесь с ресурсами по команде sed.

Ресурсы:

Команда Sed в Linux /Unix с примерами - GeeksforGeeks
sed, потоковый редактор (gnu.org)  (Официальная документация)
15 полезных советов и рекомендаций по использованию команды 'sed' для повседневных задач администрирования системы 
Linux (tecmint.com) 
Опять же, если вы не смогли многому научиться об этой команде, не расстраивайтесь, просто изучите ресурсы и 
попробуйте попрактиковаться, создавая свои собственные тексты и играя с этой командой.  

### Ответьте на вопросы ниже
Как бы вы заменили каждое третье вхождение слова «hack» на «back» в каждой строке файла file.txt?
```commandline
sed 's/hack/back/3g' file.txt
```
Как вы выполните ту же операцию только для 3-й и 4-й строк в file.txt?
```commandline
sed '3,4 s/hack/back/3g' file.txt
```
Загрузите указанный файл и попробуйте отформатировать конечные пробелы в sed1.txt с помощью двоеточия (:).
```commandline
sed 's/  */:/g' sed1.txt
```
Просмотрите файл sed2 в каталоге. Попробуйте сложить все алфавитные значения вместе, чтобы получить ответ на этот вопрос.
```commandline
CONGRATULATIONS YOU MADE IT THROUGH THIS SMALL LITTLE CHALLENGE
```
Какой шаблон вы использовали, чтобы получить эту строку ответа?
```commandline
's/[[:digit:]]//g'
```
В качестве альтернативы можно использовать tr для удаления всех цифр, а затем передать вывод в sed для удаления 
конечных пробелов. 
`cat sed2.txt | tr '[:digit:]' ' ' | sed 's/ *//g'`
[Обновление] Еще один хороший способ, предложенный комнатным мастером. Вы можете просто использовать команду `tr -d`,
чтобы удалить все цифры из файла. 
`cat sed2.txt | tr -d '[:цифра:]'`
```commandline
Ответ не нужен
```
Что она сказала?(В двойных кавычках)
```commandline
"That's What"
```

## Задание 8
xargs, очень простая команда для использования, когда нужно сделать переданную строку аргументом команды, технически,
позиционным аргументом. В официальной документации говорится, что xargs — это инструмент командной строки, 
используемый для построения и выполнения команды из стандартного ввода.

#### Важные флаги

Флаги	Описание
- -0	Завершит аргументы нулевым символом (помогает обрабатывать пробелы в аргументе)
- -a file	Эта опция позволяет xargs читать элемент из файла.
- -d delimiter	Чтобы указать разделитель, который будет использоваться при различении аргументов в stdin
- -L int	Указывает максимальное количество непустых входных данных на командную строку
- -s int	Рассматривайте это как размер буфера, который вы выделяете при запуске xargs, он устанавливает максимальное 
количество символов для команды, включая ее начальные аргументы и завершающие нули. (Вы не будете использовать это большую часть времени, но это полезно знать). Размер по умолчанию составляет около 128 КБ (если не указано иное).
- -х	Этот флаг прервет выполнение команды, если указанный размер будет превышен. (В целях безопасности.)
- -E str	Это нужно для указания строки конца файла (Вы можете использовать это в случае, если вы считываете 
  аргументы из файла)
- -I str	(Заглавная i) Используется для замены вхождения str в аргументах на то, которое передается через stdin 
  (больше похоже на создание переменной для использования в дальнейшем)
- -p запрашивать у пользователя подтверждение перед выполнением любой команды.
- -r	Если стандартный ввод пуст (т.е. не переданы аргументы), то команда не будет выполнена.
- -n целое число	Это указывает предел max-args, который будет взят из ввода команды за один раз. После достижения 
  предела max-args оставшиеся аргументы будут переданы в новую командную строку с теми же флагами, которые были установлены для ранее запущенной команды. (Больше похоже на цикл) 
- -t	verbose; (Выведите команду перед ее выполнением).Примечание: это не запрашивает подсказку

xargs упаковывается с очень большой опцией флагов, хотя это очень простой инструмент для работы. Вам не нужно 
слишком сильно зацикливаться на xargs, это всего лишь небольшой инструмент, как sort, uniq (скоро). Просмотрите 
следующие примеры, а затем у меня есть полезное замечание об использовании флагов в качестве позиционных аргументов.

#### Примеры
Что делать, если мы хотим запустить несколько команд с xargs в одной строке?

Вы можете видеть, что я определил переменную argVar для дальнейшего использования в двух командах, которые я запустил `bash -c`.

Вы можете использовать xargs совместно с командой find для улучшения результатов поиска.

Примечание:  команда  find  по умолчанию выводит результаты на стандартный вывод, поэтому-print опция обычно не 
требуется, но-print0 разделяет имена файлов байтом \0 (NULL), чтобы имена, содержащие пробелы или символы новой 
строки, могли быть интерпретированы правильно.  

Вы можете использовать команду xargs для извлечения текста из любого файла в любом каталоге, соответствующего 
определенному шаблону/критериям. 


Вы можете видеть, что я использовал xargs для grep шаблона, соответствующего чему угодно, начинающемуся с r с любым 
набором символов [:alnum:] и заканчивающемуся на 0. Что вернуло мне эту строку. Если вы хотите попрактиковаться 
самостоятельно, вы можете найти файл flag.txt внутри загруженного zip-архива. Выберите строку, найдите для нее 
уникальный шаблон, а затем выполните grep. Мир.   

Примечание:  Если xargs имеет те же флаги, это также может быть интерпретировано следующим модулем, в этом случае 
вам не нужно беспокоиться, потому что флаги, используемые после команды, являются теми, которые интерпретируются. 
Просто помните об этом, и все будет хорошо.  

Заметка о XARGS (и почти каждом модуле командной строки в системах Linux/Unix)

Давайте рассмотрим пример из одной из комнат, которую я решил, по повышению привилегий с помощью tar, запущенного 
как суперпользователь. Комната: Linux PrivEsc | Задача 10 

`Gtfobins сказал: " tar -cf /dev/null /dev/null --checkpoint=1 --checkpoint-action=exec=/bin/sh "`

Отлично, но загвоздка в задаче была в том, что sudo не было предоставлено tar, разрешения SUID были предоставлены 
файлу, который не мог редактировать ни один другой пользователь (владелец: root). Поэтому, если этот скрипт должен 
был быть запущен, он будет запущен с привилегиями root. Что мы могли сделать, так это сделать файлы в этом каталоге 
в формате флага, который tar мог бы интерпретировать как свой флаг. Поэтому, когда в нашем случае tar начал бы 
сканировать каталог, чтобы получить обзор файлов для их сжатия и объединения, он интерпретировал бы эти флаги и 
предоставил бы нам оболочку root.     

Потрясающая техника. Не так ли? Ну, не в этом суть. Суть в том, что я обнаружил небольшую трудность в создании этих 
файлов (через командную строку) с --, добавленным к ним. Я попробовал xargs, но не сработало. Затем я нашел статью 
здесь , которая помогла мне, и я решил эту проблему. Затем, когда я начал с 5-й фазы взлома (заметание следов). Я, 
похоже, не мог удалить эти ранее созданные --checkpointфайлы с помощью rm. Я пытался около часа, но не смог и ушел. 
Ну, я не знал этого, пока не начал читать документацию и страницы руководства. Назовите это инстинктом или просто 
удачей, что я нашел способ экранировать флаги командной строки как позиционный аргумент . Зачем вся эта теория, 
когда я могу просто добраться до этой точки? Ну, я считаю, что это просто лучший способ обучения, когда вы можете 
добавить свои знания к событию, которое произошло ранее. Поэтому позже я смог удалить файлы с помощью следующей 
команды.        

`rm -- --checkpoint=1`

`rm -- --checkpoint-action=exec=sh`

Заметили что-то другое? Мне удалось экранировать следующие флаги, используя пустую нотацию флага. Фактически. Этот 
метод заполнения работает ПОЧТИ в КАЖДОМ модуле командной строки, доступном для систем Linux, Unix. Давайте 
посмотрим на это в действии с xargs и узнаем, работает ли эта теория на самом деле.  

Вы можете видеть, что rm не интерпретировал файлы внутри каталога как флаг при использовании -- padding. Также, 
прежде чем мы двинемся дальше, я хочу показать еще одну вещь... 


Что за фигня? Я указал заполнение, но оно все равно выдало ошибку. Хм... Вы нашли, в чем проблема? Ну, даже если вы 
укажете это заполнение для экранирования флагов, внутри этой строки есть '/', которые заставляют touch их 
интерпретировать как создание файла bash внутри каталога bin , который находится внутри, некоторого каталога 
--checkpoint-action=exec= . Вы можете попробовать использовать \/bin\/bash для экранирования слешей, но это тоже не 
сработает, потому что файлы не могут содержать слеши в своем имени.    

Мы можем легко обойти это, просто используя bash или sh вместо указания полного пути, но убедитесь, что ваш путь 
установлен в значение normal. Двигаемся дальше... 



Сосредоточьтесь на -n2, который я использовал после xargs. 2 аргумента сразу, в первом цикле touch -- --checkpoint=1,
затем touch -- --checkpoint-action=exec=sh. Теперь давайте попробуем запустить tar. 



О, ладно, я понял, в чем проблема. Те два файла флагов, которые мы создали, были интерпретированы как флаги, и tar 
нечего было сжимать. Это не проблема. Давайте создадим тестовый файл... 



Бинго, мы получили оболочку (не как root, потому что она была запущена от моего пользователя. Она могла бы дать нам 
root, если бы мы запустили ее от имени). 

Надеюсь, что это последний пример использования xargs. Помните, xargs — отличная команда, когда дело касается 
обработки аргументов командной строки. Это не очень обширный инструмент, в который вы могли бы погрузиться. Хотя он 
максимально охватывает все области в своей области передачи и обработки аргументов другим модулям/командам. Как 
помощник, он может помочь вам облегчить ваши ежедневные задачи. Так что оставьте место для этого инструмента в вашем 
арсенале.    

### Ответьте на вопросы ниже
Прочитайте вышеизложенное.
```commandline
Ответ не требуется
```
Вы работаете в команде, и ваш руководитель группы отправил вам список файлов, которые необходимо создать как можно 
скорее в текущем каталоге, чтобы он мог подделать синопсисный отчет (который необходимо отправить в течение минуты 
или двух) наблюдателю и изменить разрешения на чтение только для вас (числовое представление). Вы можете найти 
список файлов в папке «one».   

Используйте следующие флаги в порядке ASCII:

Многословный
Принимать аргументы как «файлы»

```commandline
cat file | xargs -I files -t sh -c "touch files; chmod 400 files"
```

Ваш друг, пытаясь запустить несколько команд в одной строке и желая создать короткую версию rockyou.txt, напутал, 
создав файлы вместо того, чтобы перенаправить вывод в "shortrockyou". Теперь он напутал в своей домашней директории, 
создав кучу файлов. Он удалил список слов rockyou в этой строке и, похоже, не может загрузить его и выполнить весь 
этот длинный процесс снова.   

Теперь он ищет помощи у вас, чтобы создать список слов и удалить лишние файлы в его каталоге. Вы, будучи 
профессионалом в Linux, покажите ему, как это делается в одну строку. 

Используйте следующие флаги в порядке ASCII:
- Примите аргумент как «слово»
- Многословный
- Максимальное количество аргументов должно быть 1 для каждого файла.
Файлы для этой задачи вы можете найти в двух папках.

```commandline
ls | xargs -I word -n 1 -t sh -c 'echo word >> shortrockyou; rm word'
```
Какой флаг использовать для указания максимального количества аргументов в одной строке.
```commandline
-n
```
Как экранировать флаги командной строки в позиционных аргументах?
```commandline
--
```

## Задание 9
Это задание станет быстрым введением в две замечательные команды: uniqи sort.

уникальная команда

Команда Unique фильтрует вывод (из файла или stdin), чтобы удалить все дубликаты. Таким образом, мы получаем все 
уникальные строки и более короткий вывод, на котором можно сосредоточиться. Эта команда значительно снижает нагрузку 
на поиск в файле с повторяющимися выводами строк.   
Но есть одна загвоздка, команда uniq, ТОЛЬКО, определяет дублирующиеся строки, если они соседствуют друг с другом. 
Так что вы знаете, почему нам нужна команда для sortстрок в первую очередь. 
команда сортировки

Команда sort, как следует из названия, сортирует строки в алфавитном и числовом порядке автоматически. Все, что вам 
нужно сделать, это передать stdin в команду sort.


#### Важные флаги для uniq

Флаги	Описание
- -с	Подсчет вхождений каждой строки в файле или stdin
- -d	Будут выведены только повторяющиеся строки, а не уникальные.
- -u	Будут печататься только те строки, которые уже уникальны.
- -i	Игнорирует регистр (по умолчанию регистр учитывается)

#### Важные флаги для сортировки

Флаги	Описание
- -r	Сортирует в обратном порядке
- -с	Этот флаг используется для проверки того, отсортирован ли файл или нет (если нет, то будет указано, где начался 
  беспорядок)
- -u Для сортировки и удаления дубликатов строк (работает так же, как stdin, перенаправленный в uniq)
- -o save.txt	Чтобы сохранить в выходной файл


И это все для этих 2 коротких команд. Теперь, если вы хотите удалить любые дублирующиеся строки, power combo будет 
sortстроками, а затем использовать uniqна выходе. 

`sort file.txt | uniq`

ВАЖНО : Если вы не получаете правильный ответ на следующий вопрос, это может быть из-за этой переменной $LANG 
(которая задается во время установки вашей ОС Linux ; когда вы выбираете язык для установки и раскладку клавиатуры). 
Пошаговое решение — изменить значение переменной $LANG на 'en_US.UTF-8'. После этого ваш терминал будет выводить 
точные результаты.   
`export LANG='en_US.UTF-8'`

### Ответьте на вопросы ниже
Прочитайте вышеизложенное.
```commandline
Ответ не нужен
```
Загрузите файл, указанный для этой задачи, найдите уникальные элементы после сортировки файла. Какое 2271-е слово в выводе.
```commandline
lollol
```
Какой индекс у термина «мишель»?
```commandline
2550
```

## Задание 10
#### Вступление

cURL (расшифровывается как Crawl URL; выводит данные URL-адресов веб-страницы в необработанном формате). Еще одна 
удивительная команда для выполнения действий, которые вы можете выполнять с помощью своего браузера, просто в 
терминальном режиме. Вы не можете загрузить фотографии кошек из прямого поиска Google и щелкнуть правой кнопкой мыши 
 сохранить изображение. Но с небольшим grepping и сопоставлением шаблонов iframes это тоже возможно. Есть много 
 вещей, которые вы можете сделать с помощью curl, начиная от получения автономной копии веб-страницы (позже 
 grepping конфиденциальной информации) до загрузки больших файлов или активации веб-оболочек (для обратного 
 соединения) просто curl-url.      

curl — очень простая в использовании команда, как только вы разберетесь с ее флагами, остальное не требует пояснений.

Синтаксис:curl https://google.com/

#### Важные флаги

Флаги Описание

- -#	Отобразит индикатор прогресса, чтобы вы знали, насколько продвинулась загрузка. (или используйте флаг --silent 
для тихого сканирования)
- -о	Сохраняет загруженный файл с именем, указанным после флага.
- -О	Сохраняет файл под тем именем, под которым он был сохранен на сервере.
- -С -	Этот флаг может возобновить прерванную загрузку без указания смещения.
- --limit-rate	Ограничивает скорость загрузки/выгрузки до значения, близкого к указанному диапазону (единицы измерения: 100K, 
     100M, 100G)
- -u	Обеспечивает аутентификацию пользователя (Формат: -u пользователь:пароль)
- -Т	Помогает загрузить файл на какой-либо сервер (в нашем случае php-reverse-shell)
- -х	Если вам нужно просмотреть страницу через ПРОКСИ. Вы можете указать прокси-сервер с помощью этого флага. (-x 
  proxy.
server.com -u user:password(Аутентификация для прокси-сервера)) 
- -I	(Caps i) Запрашивает заголовок, а не веб-страницу.
- -А	Вы можете указать пользовательский агент для отправки запроса на сервер
- -L	Сообщает curl следовать перенаправлениям
- -b	Этот флаг позволяет вам указывать файлы cookie при выполнении запроса curl (файл cookie должен иметь формат 
  «NAME1=VALUE1;NAME2=VALUE2»).
- -d	Этот флаг можно использовать для отправки данных на сервер методом POST (обычно используется для отправки 
  данных формы).
- -Х	Указать метод HTTP в URL-адресе. (GET,POST,TRACE,OPTIONS)

Примеры

Продолжение загрузки

Вы можете видеть, что я продолжил загрузку, установив --continue-at <смещение> на - (дефис; это означает продолжение 
загрузки путем автоматического определения смещения) 

Сохранение файла под тем именем, под которым он был сохранен на сервере.


Да, мой интернет *****. Скорость в байтах.

Последние заметки

Вышеприведенная таблица — это просто список нескольких флагов, которые можно использовать с curl. Я рекомендую вам 
самостоятельно прочитать man-страницу по curl . 
curl работает не только с протоколами HTTP/HTTPS/FTP, но и с Telnet, POP, IMAP и многими другими. Полный список 
протоколов можно найти на странице руководства или здесь . 
Замечание: вы можете использовать curl в качестве альтернативы wget при передаче скриптов privesc из атакующего 
компьютера в хост-систему. 

#### Ресурсы

Команда curl в Linux с примерами - GeeksforGeeks
локон - как использовать
15 советов по использованию команды «Curl» в Linux (stecmint.com)
### Ответьте на вопросы ниже
Прочитайте выше
```commandline
Ответ не нужен
```
Какой флаг позволяет ограничить скорость загрузки/выгрузки файла?
```commandline
--limit-rate
```
Как вы будете закручивать веб-страницу https://tryhackme.com/, указав user-agent как «juzztesting»
```commandline
curl -A 'juzztesting' https://tryhackme.com/
```
Может ли curl выполнять операции загрузки? (Да/Нет)
```commandline
Yea
```
## Задание 11
Вы наверняка знакомы со способом загрузки данных из командной строки с помощью команды wget(web-get), и поэтому это 
будет кратким руководством по этому инструменту. 

Синтаксис:
`wget protocol://url.com/`

Важные флаги

Флаги	Описание
- -b	Для фонового процесса загрузки
- -с	Чтобы перейти к частично загруженному файлу (будет выполнен поиск частично загруженного файла в каталоге и 
  начнётся добавление; аргументы не требуются)
- -t int	Чтобы указать повторные попытки доступа к URL-адресу
- -O download.txt	Чтобы указать выходное имя загруженного файла
- -o file	Чтобы перезаписать журналы в другой файл
- -a file	Чтобы добавить журналы в уже существующий файл, не удаляя предыдущее содержимое 
- -i file	Прочитать список URL-адресов из файла.
- --user=username	Чтобы указать имя пользователя для входа (используйте --ftp-user и --http-user, если не 
  работает)
- --password=password	Чтобы задать пароль для входа (используйте --ftp-password и --http-password, если не работает)
- --ask-password	Запросить пароль, если необходим вход в систему. (Я рекомендую использовать этот флаг вместо 
  --password, поскольку есть вероятность, что пароль может начинаться с $ или чего-то другого, что может быть 
  интерпретировано как что-то другое в вашем терминале)
- --limit-rate=10k	Аналогично curl (поддерживает обозначения k и m для kB и mB соответственно)
- -w=<int>	Это позволяет указать время ожидания перед извлечением из URL-адреса. (Занимает время в секундах)
- -T=<int>	Завершить извлечение по истечении указанного времени (время указывается в секундах).
- -N	Включает отметку времени 
- -U Чтобы указать user-agent при загрузке файла


Примечание: wget поддерживает ftp, http и https. Флагов гораздо больше, чем в текущем списке, проверьте страницу man 
в Интернете, чтобы узнать больше об этом. 

Примеры

Загрузка файла с другим именем

Указание файла журнала как log.txt с включенной отметкой времени

### Ответьте на вопросы ниже
Прочитайте выше
```commandline
Ответ не нужен
```
Как вы включите регистрацию времени для каждого нового действия, инициируемого этим инструментом?
```commandline
-N
```
Какую команду вы будете использовать для загрузки https://xyz.com/mypackage.zip с помощью wget, добавляя журналы в 
существующий файл с именем «package-logs.txt»?
```commandline
wget -a package-logs.txt https://xyz.com/mypackage.zip
```
Напишите команду для чтения URL-адресов из «file.txt» и ограничьте скорость загрузки до 1 Мбит/с.
```commandline
wget -i file.txt --limit-rate=1m
```

## Задание 12
xxd, который хорошо известен для hexdumps или даже наоборот. Эта команда не очень обширна для изучения, но все же ее 
доскональное знание поможет вам работать с шестнадцатеричными строками и шестнадцатеричными цифрами. Независимо от 
того, играете ли вы в ctfs или обходите JWT с помощью автоматизации, xxd может сделать все это. Эта команда может 
принимать входные данные из файла или передавать их через конвейер или перенаправление.   

#### Важные флаги

Флаги	Описание
- -b	даст двоичное представление вместо шестнадцатеричного
- -E	Измените кодировку символов в правом столбце с ASCII на EBCDIC (можете оставить этот флаг, если не знакомы с 
  нотацией BCD)
- c int	Устанавливает количество байтов, которые будут представлены в одной строке. (т.е. устанавливает размер 
  столбца в байтах; по умолчанию 16) 
- -g	Этот флаг устанавливает, сколько байтов/октетов должно быть в группе, т.е. разделенных пробелом (по умолчанию 2 
  байта; установите -g0, если пробел не нужен).
- -i	Для вывода шестнадцатеричного дампа в формате C include (целые числа '0xff')
- -l	Укажите длину вывода (если строка больше указанной длины, шестнадцатеричная часть оставшейся части строки не 
  будет выведена)
- -p	Второй наиболее используемый флаг; преобразует переданную строку в простой шестнадцатеричный формат 
  (непрерывная строка шестнадцатеричных байтов).
- -r	Наиболее используемый флаг, преобразует шестнадцатеричный дамп в двоичный (интерпретируется как обычный текст).
- -u	Используйте заглавные шестнадцатеричные буквы (по умолчанию строчные)
- -s	искать по смещению (обсудим это вкратце на примерах)
На всякий случай, если вам было интересно, флаг -g устанавливает количество байтов в одном столбце строки, а флаги 
  -c устанавливают количество байтов в одной строке. Теперь, если -g установлено на 10, а -c установлено на 9 
  (означает, что байты, указанные в одной строке, меньше размера группы), то будет только один столбец, а размер 
  группы снизится до предела, указанного байтами столбца. Флаг -c предшествует -g.   

Примеры

Использование флага -E (для пытливых умов)


Также, просто чтобы вы знали, EBCDIC — это расширенный двоично-десятичный обмен данными.

  Вывод в двоичном формате и формате C include


Указание длины


Обратите внимание, что остальные слова были отброшены, поскольку их длина составляла всего 12 байт (включая пробел в конце #0x20).

Ищу компенсацию 


Обратите внимание, что вывод достиг 0x10-го (16-го) байта и начал выгрузку файла.

Поиск по смещению от конца файла.


Просто добавив дефис к значению смещения, команда начнет выгрузку с конца файла.

Примечание: есть разница между -s +offset и -s offset при поиске через stdin. Я не собираюсь вдаваться в краткие 
объяснения разницы, просто помните, что если при поиске смещения через stdin возникает ошибка, попробуйте 
перенаправить stdin в файл, а затем выполнить hexdump с xxd, что может решить вашу проблему.  

### Ответьте на вопросы ниже
Прочитайте вышеизложенное.
```commandline
Ответ не нужен
```
Как вы будете искать 10-й байт (в шестнадцатеричном формате) в file.txt и отображать только 50 байт?
```commandline
xxd -s 0xa -l 50 -b file.txt 
```
Как отобразить байты шестнадцатеричного дампа в 3 столбцах с группой из 3 октетов в строке из file.txt? (Используйте 
флаги в алфавитном порядке) 
```commandline
xxd -c 9 -g 3 file.txt
```
Какой флаг имеет больший приоритет: -c или -g?
```commandline
-c
```
Загрузите файл и найдите значение флага.
```commandline
flag{wh3sdw0lw1gl9oqasad2fs48as}
```

## Задание 13
Начнем с команд, которые я нашел после поиска  | sort | uniq по первому слову в каждой строке в моем ~/.bash_history 
(было перечислено 31337 команд. В эту задачу не будут включены команды nmap/gobuster, поскольку эта комната не об 
этом ).   


Если вам интересно, как я получил пользовательский размер .bash_history, я отредактировал свой файл .bashrc в 
домашнем каталоге. 

команда gpg

Примечание: GPG (Gnu Privacy Guard) и PGP (Pretty Good Privacy) — это два разных типа шифрования. PGP основан на 
шифровании RSA, тогда как GPG (open-source) — это переписанный PGP, который по умолчанию использует шифрование AES . 

Вы должны знать о ключах PGP и GPG , когда вы найдете файл, зашифрованный с помощью шифрования GPG . Таким образом, 
ниже приведены некоторые ресурсы, чтобы легко узнать больше о gpg: инструмент командной строки. 
Ресурсы

gpg - команда Unix, Linux - Tutorialspoint
Шпаргалка GPG (hawaii.edu)

команда tar

Независимо от того, является ли это архивом gzip или bzip, шифрование и дешифрование могут быть легко выполнены этим 
инструментом. Проверьте страницу руководства для tar man tar.  
Ресурсы :

Шпаргалка по командам Linux Tar | Never Ending Security (wordpress.com)
Команда tar в Linux с примерами - GeeksforGeeks
команды id/pwd/uname

Давайте не будем забывать легенды, которые мы развертываем на поле боя после получения доступа к init shell на машине.
команды ps/kill

Список процессов и завершение процессов с PID. Чтобы узнать больше о команде ps, вы можете найти помощь здесь .
команда netstat

Эта удивительная команда выводит список любой сетевой активности в текущей системе. Любые 
открытые/прослушиваемые/неустановленные порты, соединение может быть выведено с помощью этой команды.  
Обязательно ознакомьтесь с справочной страницей этой команды и прочтите о ней больше.
Также знайте, что существует альтернатива команде netstat, которая делает практически то же самое, что и netstat, то 
есть ss команда (статистика сокетов) (выводит список активности портов в реальном времени). 
Ресурсы

Полная шпаргалка по Netstat — освойте Netstat за 20 минут (rekha.com)
netstat(8) - страница руководства Linux (die.net)
SS – Памятка по командам статистики сокетов | Never Ending Security (wordpress.com)
меньше/больше команд

Это еще 2 замечательные команды, которые предлагают альтернативу для открытия и чтения файла. В чем разница? more — 
старая команда, а less была создана для улучшения команды more. С одной стороны, More имеет ограниченную обратную 
прокрутку, тогда как less имеет прямую и обратную навигацию, включая улучшенные параметры поиска (/).  
Опять же, more по-своему прекрасен, я помню, что получил shell, когда делал box из vulnhub , используя команду more 
(эта ssh shell постоянно закрывалась после успешного входа, я передал сеанс в команду more и получил shell через !
/bin/sh. Эта задача была примерно такой: сократите размер вашего term до одной строки и откройте сеанс ssh, 
перенаправив его в команду more, а затем запустите !/bin/sh в палитре команд more, которую я, похоже, не могу сейчас 
воссоздать). К сожалению, я больше не помню box. Если вы каким-то образом его помните, свяжитесь со мной, пожалуйста.
Есть еще одна команда, которая была создана для улучшения некоторых lessфункций, большинство команд; она не 
установлена по умолчанию в некоторых дистрибутивах Linux, вы можете установить ее с помощью sudo apt install most.  
#### Ресурсы

Разница между командами more, less и most - OSTechNix
Команда «Меньше и больше» (объяснение)
команда diff

В самом простом использовании эта команда сравнивает символы байт за байтом и пытается найти разницу между 2 файлами.
Хотя это может сравнивать ТОЛЬКО 2 файла одновременно. Хотите узнать больше об этой команде, ознакомьтесь с ресурсами. 
Есть еще одна команда, известная как comm. Эта команда сравнивает 2 отсортированных файла построчно. В то время как 
diff пытается найти любые различия между файлами, comm больше сосредоточена на том, чтобы найти, что общего между 2 
файлами. Ознакомьтесь с ресурсами, чтобы узнать больше.  
#### Ресурсы

Сравнение файлов и каталогов с помощью команд Linux diff и comm | Network World
Команда diff в Linux с примерами - GeeksforGeeks
Команда comm в Linux с примерами - GeeksforGeeks
команда base64



Зачем заходить на сайты, если можно декодировать base32 и base64 на собственном терминале.
команда тройника

Вы когда-нибудь задумывались, что хотите просматривать вывод в реальном времени и одновременно сохранять вывод в 
файл? Что ж, стандартное перенаправление не позволяет этого сделать. Не беспокойтесь, команда tee придет на помощь. 
Она считывает данные со stdin и записывает их в stdout и файлы.  
Небольшой удобный инструмент, который я каждый раз использую вместе с linpeas для чтения результатов моего скрипта в 
реальном времени, а также для сохранения вывода в каталоге /tmp машины. 


Вы можете использовать его с флагом -a, чтобы не перезаписывать существующий файл, а просто добавить новый.
команды file/stat

Команда File считывает заголовки файлов и сообщает вам, что это за файл на самом деле (независимо от используемого 
расширения). Аналогично работает команда stat, которая выдает вам статус файла/файловой системы.  


экспортировать команду

Эта команда используется для установки переменных окружения (переменных, которые устанавливаются при открытии сеанса 
оболочки/пользователя). Подробнее об этой команде можно прочитать здесь . 
команда сброса

Допустим, ваш терминал работает неправильно, возникла какая-то проблема, но вы не можете позволить себе закрыть 
оболочку, вам достаточно одной resetкоманды, чтобы вернуть оболочку в нормальное состояние.  
команда systemctl/service

servicecommand — это обычная команда для инициализации служб, присутствующих в /etc/init.d, не заставляя 
администратора слишком беспокоиться о постоянных изменениях системы, systemctlс другой стороны, это тяжелая команда 
(выполняющая практически ту же работу, только на уровне systemd; systemd — это менеджер служб в системах Linux), 
которая может помешать настройкам по умолчанию. Например, службы, инициализированные systemctl, остаются в каталоге 
systemd (каталоге, в котором хранится программа, которую следует запустить при загрузке системы Linux). Таким 
образом, программы, инициализированные systemctl, загружаются вместе с system.     
С помощью  service вы можете использовать только команды, относящиеся к этой конкретной службе (перезагрузка, запуск,
остановка, статус и т. д.), а с помощью такого мощного инструмента, как  systemctl, вы можете контролировать 
состояние системы «systemd» и менеджера служб.   
Примечание: Если вы не знаете, что делаете, попробуйте использовать serviceвместо этого, чтобы избежать 
остановки/отключения/маскировки нежелательных служб, которые могут не исправиться даже при новой загрузке. Резервное 
копирование важных файлов всегда было хорошей привычкой.  

Ссылки

Разница между Systemctl и командой service - Stack Overflow
Шпаргалка по Systemctl (github.com)  (Небольшая шпаргалка, которую стоит прочитать перед началом работы с systemctl).

### Ответьте на вопросы ниже
Прочитайте последнее учебное задание.
```commandline
Ответ не нужен
```
Безопасно ли запускать команду systemctl и экспериментировать на вашей основной системе Linux, не следуя надлежащему 
руководству и не имея никаких предварительных знаний? (Верно/Неверно) 
```commandline
Wrong
```
Как вы импортируете данный закрытый ключ PGP. (Предположим, имя файла — key.gpg)
```commandline
gpg --import key.gpg
```
Как вывести список всех действий порта, если netstat недоступен на машине? (Полное имя)
```commandline
Socket Statistics
```
Какую команду можно использовать для исправления сломанной/неправильно/странно работающей оболочки терминала?
```commandline
reset
```

## Задание 14
Прежде всего поздравляю с тем, что вы дошли так далеко. Эй, вы действительно это сделали. Знакомство со столькими 
модулями — нелегкая задача... (Поверьте человеку, который потратил около месяца на то, чтобы сделать все это). 
Особенно это касается строп — это тема, в которой вам следует много практиковаться. Сложно полностью разобраться в 
вещах с самого начала, но как только вы заложите основу с помощью инструментов, описанных выше, это действительно 
ничего. Так что просто продолжайте, это того стоит.
Ю0у. С4н. Д0. 1т. 

Ответьте на вопросы ниже
Нажмите F, чтобы проявить уважение
```commandline
F
```

[>> вернуться на главную страницу](https://github.com/BEPb/tryhackme/blob/master/README.md)