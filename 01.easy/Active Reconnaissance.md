

[>> вернуться на главную страницу](https://github.com/BEPb/tryhackme/blob/master/README.md)

# Комната [Active Reconnaissance](https://tryhackme.com/r/room/activerecon) 

Всего 5 заданий:
## Задание 1
В первой комнате модуля сетевой безопасности мы сосредоточились на пассивной разведке . Во второй комнате мы 
сосредоточимся на активной разведке и основных инструментах, связанных с ней. Мы учимся использовать веб-браузер для 
сбора дополнительной информации о нашей цели. Кроме того, мы обсуждаем использование простых инструментов, таких как 
ping, traceroute, telnet, и ncдля сбора информации о сети, системе и услугах.    

Как мы узнали в предыдущей комнате, пассивная разведка позволяет вам собирать информацию о вашей цели без 
какого-либо прямого взаимодействия или связи. Вы наблюдаете издалека или проверяете общедоступную информацию.  

Активная разведка требует, чтобы вы установили какой-то контакт с вашей целью. Этот контакт может быть телефонным 
звонком или визитом в целевую компанию под каким-то предлогом для сбора дополнительной информации, обычно в рамках 
социальной инженерии. В качестве альтернативы это может быть прямое подключение к целевой системе, будь то посещение 
ее веб-сайта или проверка того, открыт ли ее брандмауэром порт SSH. Думайте об этом так, как будто вы внимательно 
осматриваете окна и дверные замки. Поэтому важно помнить, что не следует заниматься активной разведкой, пока не 
получите подписанное юридическое разрешение от клиента.     

В этой комнате мы сосредоточимся на активной разведке. Активная разведка начинается с прямых подключений к целевой 
машине. Любое такое подключение может оставить информацию в журналах, показывающую IP-адрес клиента, время 
подключения и продолжительность подключения, среди прочего. Однако не все подключения подозрительны. Можно позволить 
вашей активной разведке выглядеть как обычная клиентская активность. Рассмотрим просмотр веб-страниц; никто не 
заподозрит браузер, подключенный к целевому веб-серверу, среди сотен других законных пользователей. Вы можете 
использовать такие методы в своих интересах, работая в составе красной команды (атакующих) и не желая тревожить 
синюю команду (защитников).      

В этой комнате мы рассмотрим различные инструменты, обычно входящие в комплект большинства операционных систем или 
легкодоступные. Начнем с веб-браузера и его встроенных инструментов разработчика; кроме того, мы покажем вам, как 
веб-браузер может быть «вооружен», чтобы стать эффективной инфраструктурой разведки. После этого мы обсудим другие 
безвредные инструменты, такие как ping, traceroute, и telnet. Все эти программы требуют подключения к цели, и, 
следовательно, наши действия будут подпадать под активную разведку.    

Эта комната будет интересна всем, кто хочет ознакомиться с основными инструментами и посмотреть, как их можно 
использовать в активной разведке. Инструменты разработчика веб-браузера могут потребовать некоторых усилий для 
ознакомления, хотя они предлагают графический пользовательский интерфейс. Охваченные инструменты командной строки 
относительно просты в использовании.   

Важное примечание: Обратите внимание, что если вы не подписаны, у AttackBox не будет доступа к Интернету, поэтому 
вам придется использовать VPN для ответа на вопросы, требующие доступа к Интернету. 

Ответить на вопросы ниже
Убедитесь, что вы понимаете, почему эти инструменты попадают под активную разведку. Запустите AttackBox и убедитесь, 
что он готов. Он вам понадобится для ответов на вопросы, особенно в последующих заданиях. 

```commandline
Ответ не нужен
```

## Задание 2
Веб-браузер может быть удобным инструментом, особенно потому, что он легко доступен на всех системах. Существует 
несколько способов, с помощью которых вы можете использовать веб-браузер для сбора информации о цели. 

На транспортном уровне браузер подключается к:
- TCP-порт 80 по умолчанию при доступе к веб-сайту через HTTP
- TCP -порт 443 по умолчанию при доступе к веб-сайту через HTTPS
Поскольку 80 и 443 являются портами по умолчанию для HTTP и HTTPS, веб-браузер не отображает их в адресной строке. 
Однако можно использовать пользовательские порты для доступа к службе. Например, https://127.0.0.1:8834/ подключится 
к 127.0.0.1 (localhost) на порту 8834 по протоколу HTTPS. Если на этом порту прослушивается HTTPS-сервер, мы получим 
веб-страницу.   

При просмотре веб-страницы вы можете нажать `Ctrl+Shift+I` на ПК или Option + Command + I( ⌥ + ⌘ + I) на Mac, чтобы 
открыть Developer Tools в Firefox. Аналогичные сочетания клавиш также позволят вам начать работу с Google Chrome или 
Chromium. Developer Tools позволяет вам проверять множество вещей, которые ваш браузер получил и которыми обменял с 
удаленным сервером. Например, вы можете просматривать и даже изменять файлы JavaScript (JS), проверять файлы cookie, 
установленные в вашей системе, и обнаруживать структуру папок содержимого сайта.    

Ниже представлен скриншот Firefox Developer Tools. Chrome DevTools очень похож.

Также есть множество дополнений для Firefox и Chrome, которые могут помочь в тестировании на проникновение. Вот 
несколько примеров: 

FoxyProxy позволяет быстро менять прокси-сервер, который вы используете для доступа к целевому веб-сайту. Это 
расширение для браузера удобно, когда вы используете такой инструмент, как Burp Suite, или если вам нужно регулярно 
переключать прокси-серверы. Вы можете получить FoxyProxy для Firefox здесь.  
User-Agent Switcher and Manager дает вам возможность притворяться, что вы заходите на веб-страницу из другой 
операционной системы или другого веб-браузера. Другими словами, вы можете притворяться, что просматриваете сайт с 
помощью iPhone, когда на самом деле вы заходите на него из Mozilla Firefox. Вы можете скачать User-Agent Switcher 
and Manager для Firefox здесь.   
Wappalyzer предоставляет сведения о технологиях, используемых на посещаемых веб-сайтах. Такое расширение удобно, в 
первую очередь, когда вы собираете всю эту информацию во время просмотра веб-сайта, как любой другой пользователь. 
Скриншот Wappalyzer показан ниже. Вы можете найти Wappalyzer для Firefox здесь.  

Со временем вы, возможно, найдете несколько расширений, которые идеально впишутся в ваш рабочий процесс.

Ответить на вопросы ниже
Перейдите на следующий веб-сайт и убедитесь, что вы открыли Developer Tools на AttackBox Firefox или браузер на 
вашем компьютере. Используя Developer Tools, выясните общее количество вопросов. 
```commandline
8
```
## Задание 3
Ping должен напомнить вам игру в пинг-понг (настольный теннис). Вы бросаете мяч и ожидаете, что он вам вернется. 
Основная цель ping — проверить, можете ли вы связаться с удаленной системой и может ли удаленная система связаться с 
вами. Другими словами, изначально это использовалось для проверки сетевого подключения; однако нас больше интересуют 
другие его применения: проверка того, находится ли удаленная система в сети.   

Проще говоря, команда ping отправляет пакет на удаленную систему, а удаленная система отвечает. Таким образом, вы 
можете сделать вывод, что удаленная система находится в сети и что сеть между двумя системами работает.  

Если вы предпочитаете более щепетильное определение, ping — это команда, которая отправляет пакет ICMP Echo на 
удаленную систему. Если удаленная система находится в сети, а пакет ping был правильно маршрутизирован и не 
заблокирован никаким брандмауэром, удаленная система должна отправить ответ ICMP Echo. Аналогично, ответ ping должен 
достичь первой системы, если он правильно маршрутизирован и не заблокирован никаким брандмауэром.   

Целью такой команды является обеспечение того, чтобы целевая система была подключена к сети, прежде чем мы потратим 
время на проведение более детального сканирования для обнаружения работающей операционной системы и служб.  

На вашем терминале AttackBox вы можете начать использовать ping как ping MACHINE_IP или ping HOSTNAME. В последнем 
случае система должна разрешить HOSTNAME в IP-адрес перед отправкой пакета ping. Если вы не укажете количество в 
системе Linux , вам нужно будет нажать , CTRL+c чтобы принудительно остановить его. Следовательно, вы можете 
рассмотреть, ping -c 10 MACHINE_IP хотите ли вы просто отправить десять пакетов. Это эквивалентно ping -n 10 
MACHINE_IP в системе MS Windows.    

Технически говоря, ping относится к протоколу ICMP (Internet Control Message Protocol). ICMP поддерживает множество 
типов запросов, но, в частности, нас интересуют ping (ICMP echo/type 8) и ping reply (ICMP echo reply/type 0). Для 
использования ping не требуется вникать в детали ICMP.  

В следующем примере мы указали общее количество пакетов 5. С терминала AttackBox мы начали пинговать MACHINE_IP. Мы 
узнали, что MACHINE_IPон работает и не блокирует запросы ICMP echo. Более того, любые брандмауэры и маршрутизаторы 
на маршруте пакета также не блокируют запросы ICMP echo.  

Терминал AttackBox
```commandline
user@AttackBox$ ping -c 5 MACHINE_IP
PING MACHINE_IP (MACHINE_IP) 56(84) bytes of data.
64 bytes from MACHINE_IP: icmp_seq=1 ttl=64 time=0.636 ms
64 bytes from MACHINE_IP: icmp_seq=2 ttl=64 time=0.483 ms
64 bytes from MACHINE_IP: icmp_seq=3 ttl=64 time=0.396 ms
64 bytes from MACHINE_IP: icmp_seq=4 ttl=64 time=0.416 ms
64 bytes from MACHINE_IP: icmp_seq=5 ttl=64 time=0.445 ms


--- MACHINE_IP ping statistics ---
5 packets transmitted, 5 received, 0% packet loss, time 4097ms
rtt min/avg/max/mdev = 0.396/0.475/0.636/0.086 ms
```

В приведенном выше примере мы ясно увидели, что целевая система отвечает. Выходные данные ping являются индикатором 
того, что она находится в сети и доступна. Мы передали пять пакетов и получили пять ответов. Мы замечаем, что в 
среднем ответу потребовалось 0,475 мс (миллисекунды), чтобы достичь нашей системы, а максимальное значение составило 
0,636 мс.   

С точки зрения тестирования на проникновение мы попытаемся узнать больше об этой цели. Мы попытаемся узнать как 
можно больше, например, какие порты открыты и какие службы запущены. 

Давайте рассмотрим следующий случай: мы выключили целевую виртуальную машину, а затем попытались выполнить ping 
MACHINE_IP. Как и следовало ожидать в следующем примере, мы не получили никакого ответа. 

Терминал AttackBox
```commandline
user@AttackBox$ ping -c 5 MACHINE_IP
PING MACHINE_IP (MACHINE_IP) 56(84) bytes of data.
From ATTACKBOX_IP icmp_seq=1 Destination Host Unreachable
From ATTACKBOX_IP icmp_seq=2 Destination Host Unreachable
From ATTACKBOX_IP icmp_seq=3 Destination Host Unreachable
From ATTACKBOX_IP icmp_seq=4 Destination Host Unreachable
From ATTACKBOX_IP icmp_seq=5 Destination Host Unreachable
```


--- MACHINE_IP ping statistics ---
5 packets transmitted, 0 received, +5 errors, 100% packet loss, time 4098ms
pipe 4
В этом случае мы уже знаем, что мы выключили целевой компьютер с MACHINE_IP. На каждый пинг система, которую мы 
используем, в данном случае AttackBox, отвечает «Destination Host Unreachable». Мы видим, что мы передали пять 
пакетов, но ни один не был получен, что приводит к 100% потере пакетов.  

Вообще говоря, когда мы не получаем ответ на ping, есть несколько объяснений, почему мы не получили ответ на ping, например:

Конечный компьютер не отвечает; возможно, он все еще загружается или выключен, или произошел сбой ОС .
Он отключен от сети, или на пути к нему находится неисправное сетевое устройство.
Брандмауэр настроен на блокировку таких пакетов. Брандмауэр может быть частью программного обеспечения, работающего 
в самой системе, или отдельным сетевым устройством. Обратите внимание, что брандмауэр MS Windows блокирует ping по 
умолчанию.  
Ваша система отключена от сети.
### Ответить на вопросы ниже
Какой параметр вы бы использовали для установки размера данных, передаваемых эхо-запросом ICMP?
```commandline
-s
```
Каков размер заголовка ICMP в байтах?
```commandline
8
```
Блокирует ли брандмауэр MS Windows ping по умолчанию? (Да/Нет)
```commandline
Y
```
Разверните виртуальную машину для этой задачи и с помощью терминала AttackBox выполните команду ping -c 10 
MACHINE_IP. Сколько ответов ping вы получили? 
```commandline
10
```

## Задание 4
Как следует из названия, команда traceroute отслеживает маршрут , пройденный пакетами от вашей системы до другого 
хоста. Целью traceroute является поиск IP-адресов маршрутизаторов или переходов, которые проходит пакет по пути от 
вашей системы до целевого хоста. Эта команда также показывает количество маршрутизаторов между двумя системами. Она 
полезна, поскольку указывает количество переходов (маршрутизаторов) между вашей системой и целевым хостом. Однако 
обратите внимание, что маршрут, пройденный пакетами, может измениться, поскольку многие маршрутизаторы используют 
протоколы динамической маршрутизации, которые адаптируются к изменениям в сети.     

В Linux и macOS используется команда traceroute MACHINE_IP, а в MS Windows — tracert MACHINE_IP. traceroute пытается 
обнаружить маршрутизаторы на пути от вашей системы к целевой системе. 

Не существует прямого способа обнаружить путь от вашей системы до целевой системы. Мы полагаемся на ICMP, чтобы 
«обмануть» маршрутизаторы, заставив их раскрыть свои IP-адреса. Мы можем сделать это, используя небольшое время 
жизни ( TTL ) в поле заголовка IP. Хотя T в TTL означает время, TTL указывает максимальное количество 
маршрутизаторов/прыжков, через которые пакет может пройти, прежде чем будет отброшен; TTL не является максимальным 
количеством единиц времени. Когда маршрутизатор получает пакет, он уменьшает TTL на единицу, прежде чем передать его 
следующему маршрутизатору. На следующем рисунке показано, что каждый раз, когда IP-пакет проходит через 
маршрутизатор, его значение TTL уменьшается на 1. Первоначально он покидает систему со значением TTL, равным 64; он 
достигает целевой системы со значением TTL , равным 60, после прохождения через 4 маршрутизатора.       



Однако если TTL достигает 0, он будет отброшен, а ICMP Time-to-Live exceeded будет отправлено исходному отправителю. 
На следующем рисунке система устанавливает TTL в 1 перед отправкой его маршрутизатору. Первый маршрутизатор на пути 
уменьшает TTL на 1, в результате чего TTL становится равным 0. Следовательно, этот маршрутизатор отбросит пакет и 
отправит сообщение об ошибке ICMP time exceeded in-transit. Обратите внимание, что некоторые маршрутизаторы 
настроены не отправлять такие сообщения ICMP при отбрасывании пакета.    



В Linuxtraceroute начнется с отправки UDP- датаграмм в IP-пакетах с TTL , равным 1. Таким образом, это приведет к 
тому, что первый маршрутизатор столкнется с TTL = 0 и отправит обратно ICMP Time-to-Live exceeded. Следовательно, 
TTL, равный 1, раскроет вам IP-адрес первого маршрутизатора. Затем он отправит еще один пакет с TTL = 2; этот пакет 
будет отброшен на втором маршрутизаторе. И так далее. Давайте попробуем это на реальных системах.   

В следующих примерах мы запускаем одну и ту же команду traceroute tryhackme.comиз TryHackMe's AttackBox. Мы замечаем,
что разные запуски могут приводить к разным маршрутам, по которым проходят пакеты. 

Трассировка маршрута А

Терминал AttackBox - Traceroute A
```commandline
user@AttackBox$ traceroute tryhackme.com
traceroute to tryhackme.com (172.67.69.208), 30 hops max, 60 byte packets
 1  ec2-3-248-240-5.eu-west-1.compute.amazonaws.com (3.248.240.5)  2.663 ms * ec2-3-248-240-13.eu-west-1.compute.amazonaws.com (3.248.240.13)  7.468 ms
 2  100.66.8.86 (100.66.8.86)  43.231 ms 100.65.21.64 (100.65.21.64)  18.886 ms 100.65.22.160 (100.65.22.160)  14.556 ms
 3  * 100.66.16.176 (100.66.16.176)  8.006 ms *
 4  100.66.11.34 (100.66.11.34)  17.401 ms 100.66.10.14 (100.66.10.14)  23.614 ms 100.66.19.236 (100.66.19.236)  17.524 ms
 5  100.66.7.35 (100.66.7.35)  12.808 ms 100.66.6.109 (100.66.6.109)  14.791 ms *
 6  100.65.14.131 (100.65.14.131)  1.026 ms 100.66.5.189 (100.66.5.189)  19.246 ms 100.66.5.243 (100.66.5.243)  19.805 ms
 7  100.65.13.143 (100.65.13.143)  14.254 ms 100.95.18.131 (100.95.18.131)  0.944 ms 100.95.18.129 (100.95.18.129)  0.778 ms
 8  100.95.2.143 (100.95.2.143)  0.680 ms 100.100.4.46 (100.100.4.46)  1.392 ms 100.95.18.143 (100.95.18.143)  0.878 ms
 9  100.100.20.76 (100.100.20.76)  7.819 ms 100.92.11.36 (100.92.11.36)  18.669 ms 100.100.20.26 (100.100.20.26)  0.842 ms
10  100.92.11.112 (100.92.11.112)  17.852 ms * 100.92.11.158 (100.92.11.158)  16.687 ms
11  100.92.211.82 (100.92.211.82)  19.713 ms 100.92.0.126 (100.92.0.126)  18.603 ms 52.93.112.182 (52.93.112.182)  17.738 ms
12  99.83.69.207 (99.83.69.207)  17.603 ms  15.827 ms  17.351 ms
13  100.92.9.83 (100.92.9.83)  17.894 ms 100.92.79.136 (100.92.79.136)  21.250 ms 100.92.9.118 (100.92.9.118)  18.166 ms
14  172.67.69.208 (172.67.69.208)  17.976 ms  16.945 ms 100.92.9.3 (100.92.9.3)  17.709 ms
```

В выводе traceroute выше у нас есть 14 пронумерованных строк; каждая строка представляет один маршрутизатор/переход. 
Наша система отправляет три пакета с TTL , установленным на 1, затем три пакета с TTL , установленным на 2, и так 
далее. В зависимости от топологии сети мы можем получить ответы от 3 разных маршрутизаторов, в зависимости от 
маршрута, пройденного пакетом. Рассмотрим строку номер 12, двенадцатый маршрутизатор с указанным IP-адресом отбросил 
пакет три раза и отправил сообщение ICMP о превышении времени в пути. Строка 12 99.83.69.207 (99.83.69.207) 17.603 
ms 15.827 ms 17.351 msпоказывает время в миллисекундах, необходимое для достижения нашей системы каждым ответом.     

С другой стороны, мы видим, что получили только один ответ на третьей строке. Две звезды в выводе 3 * 100.66.16.176 
(100.66.16.176) 8.006 ms *указывают на то, что наша система не получила два ожидаемых сообщения ICMP time exceeded 
in-transit.  

Наконец, в первой строке вывода мы видим, что пакеты, покидающие AttackBox, идут разными маршрутами. Мы видим два 
маршрутизатора, которые ответили, что TTL равен единице. Наша система так и не получила третье ожидаемое сообщение 
ICMP.  

Трассировка маршрута B

Терминал AttackBox - Traceroute B
```commandline
user@AttackBox$ traceroute tryhackme.com
traceroute to tryhackme.com (104.26.11.229), 30 hops max, 60 byte packets
 1  ec2-79-125-1-9.eu-west-1.compute.amazonaws.com (79.125.1.9)  1.475 ms * ec2-3-248-240-31.eu-west-1.compute.amazonaws.com (3.248.240.31)  9.456 ms
 2  100.65.20.160 (100.65.20.160)  16.575 ms 100.66.8.226 (100.66.8.226)  23.241 ms 100.65.23.192 (100.65.23.192)  22.267 ms
 3  100.66.16.50 (100.66.16.50)  2.777 ms 100.66.11.34 (100.66.11.34)  22.288 ms 100.66.16.28 (100.66.16.28)  4.421 ms
 4  100.66.6.47 (100.66.6.47)  17.264 ms 100.66.7.161 (100.66.7.161)  39.562 ms 100.66.10.198 (100.66.10.198)  15.958 ms
 5  100.66.5.123 (100.66.5.123)  20.099 ms 100.66.7.239 (100.66.7.239)  19.253 ms 100.66.5.59 (100.66.5.59)  15.397 ms
 6  * 100.66.5.223 (100.66.5.223)  16.172 ms 100.65.15.135 (100.65.15.135)  0.424 ms
 7  100.65.12.135 (100.65.12.135)  0.390 ms 100.65.12.15 (100.65.12.15)  1.045 ms 100.65.14.15 (100.65.14.15)  1.036 ms
 8  100.100.4.16 (100.100.4.16)  0.482 ms 100.100.20.122 (100.100.20.122)  0.795 ms 100.95.2.143 (100.95.2.143)  0.827 ms
 9  100.100.20.86 (100.100.20.86)  0.442 ms 100.100.4.78 (100.100.4.78)  0.347 ms 100.100.20.20 (100.100.20.20)  1.388 ms
10  100.92.212.20 (100.92.212.20)  11.611 ms 100.92.11.54 (100.92.11.54)  12.675 ms 100.92.11.56 (100.92.11.56)  10.835 ms
11  100.92.6.52 (100.92.6.52)  11.427 ms 100.92.6.50 (100.92.6.50)  11.033 ms 100.92.210.50 (100.92.210.50)  10.551 ms
12  100.92.210.139 (100.92.210.139)  10.026 ms 100.92.6.13 (100.92.6.13)  14.586 ms 100.92.210.69 (100.92.210.69)  12.032 ms
13  100.92.79.12 (100.92.79.12)  12.011 ms 100.92.79.68 (100.92.79.68)  11.318 ms 100.92.80.84 (100.92.80.84)  10.496 ms
14  100.92.9.27 (100.92.9.27)  11.354 ms 100.92.80.31 (100.92.80.31)  13.000 ms 52.93.135.125 (52.93.135.125)  11.412 ms
15  150.222.241.85 (150.222.241.85)  9.660 ms 52.93.135.81 (52.93.135.81)  10.941 ms 150.222.241.87 (150.222.241.87)  16.543 ms
16  100.92.228.102 (100.92.228.102)  15.168 ms 100.92.227.41 (100.92.227.41)  10.134 ms 100.92.227.52 (100.92.227.52)  11.756 ms
17  100.92.232.111 (100.92.232.111)  10.589 ms 100.92.231.69 (100.92.231.69)  16.664 ms 100.92.232.37 (100.92.232.37)  13.089 ms
18  100.91.205.140 (100.91.205.140)  11.551 ms 100.91.201.62 (100.91.201.62)  10.246 ms 100.91.201.36 (100.91.201.36)  11.368 ms
19  100.91.205.79 (100.91.205.79)  11.112 ms 100.91.205.83 (100.91.205.83)  11.040 ms 100.91.205.33 (100.91.205.33)  10.114 ms
20  100.91.211.45 (100.91.211.45)  9.486 ms 100.91.211.79 (100.91.211.79)  13.693 ms 100.91.211.47 (100.91.211.47)  13.619 ms
21  100.100.6.81 (100.100.6.81)  11.522 ms 100.100.68.70 (100.100.68.70)  10.181 ms 100.100.6.21 (100.100.6.21)  11.687 ms
22  100.100.65.131 (100.100.65.131)  10.371 ms 100.100.92.6 (100.100.92.6)  10.939 ms 100.100.65.70 (100.100.65.70)  23.703 ms
23  100.100.2.74 (100.100.2.74)  15.317 ms 100.100.66.17 (100.100.66.17)  11.492 ms 100.100.88.67 (100.100.88.67)  35.312 ms
24  100.100.16.16 (100.100.16.16)  19.155 ms 100.100.16.28 (100.100.16.28)  19.147 ms 100.100.2.68 (100.100.2.68)  13.718 ms
25  99.83.89.19 (99.83.89.19)  28.929 ms *  21.790 ms
26  104.26.11.229 (104.26.11.229)  11.070 ms  11.058 ms  11.982 ms
```

Во втором запуске программы traceroute мы заметили, что на этот раз пакеты прошли более длинный маршрут, пройдя 
через 26 маршрутизаторов. Если вы запускаете traceroute к системе в своей сети, маршрут вряд ли изменится. Однако мы 
не можем ожидать, что маршрут останется фиксированным, когда пакетам нужно будет пройти через другие маршрутизаторы 
за пределами нашей сети.   

Подводя итог, можно отметить следующее:

Количество переходов/маршрутизаторов между вашей системой и целевой системой зависит от времени запуска traceroute. 
Нет гарантии, что ваши пакеты всегда будут следовать по одному и тому же маршруту, даже если вы находитесь в одной и 
той же сети или повторяете команду traceroute в течение короткого времени.  
Некоторые маршрутизаторы возвращают публичный IP-адрес. Вы можете проверить несколько из этих маршрутизаторов в 
зависимости от области предполагаемого тестирования на проникновение. 
Некоторые маршрутизаторы не возвращают ответ.
### Ответить на вопросы ниже
В Traceroute A, каков IP-адрес последнего маршрутизатора/узла перед достижением tryhackme.com?
```commandline
172.67.69.208
```
В Traceroute B какой IP-адрес последнего маршрутизатора/узла перед достижением tryhackme.com?
```commandline
104.26.11.229
```
Сколько маршрутизаторов находится между двумя системами в Traceroute B?
```commandline
26
```
Запустите присоединенную виртуальную машину из задачи 3, если она еще не запущена. На AttackBox запустите  
traceroute MACHINE_IP. Проверьте, сколько маршрутизаторов/прыжков между AttackBox и целевой виртуальной машиной. 
```commandline
Ответ не нужен
```

## Задание 5
Протокол TELNET (Teletype Network) был разработан в 1969 году для связи с удаленной системой через интерфейс 
командной строки ( CLI ). Следовательно, команда telnet использует протокол TELNET для удаленного администрирования. 
Порт по умолчанию, используемый telnet, — 23. С точки зрения безопасности, telnet отправляет все данные, включая 
имена пользователей и пароли, в открытом тексте. Отправка в открытом тексте позволяет любому, кто имеет доступ к 
каналу связи, легко украсть учетные данные для входа. Безопасной альтернативой является протокол SSH (Secure SHell). 


Однако клиент telnet, благодаря своей простоте, может использоваться и для других целей. Зная, что клиент telnet 
использует протокол TCP , вы можете использовать Telnet для подключения к любой службе и захвата ее баннера. 
Используя telnet MACHINE_IP PORT, вы можете подключиться к любой службе, работающей на TCP , и даже обменяться 
несколькими сообщениями, если она не использует шифрование.   

Допустим, мы хотим узнать больше информации о веб-сервере, прослушивающем порт 80. Мы подключаемся к серверу через 
порт 80, а затем взаимодействуем с помощью протокола HTTP . Вам не нужно углубляться в протокол HTTP ; вам просто 
нужно выполнить . Чтобы указать что-то, кроме страницы индекса по умолчанию, вы можете выполнить, который запросит.
Мы также указали удаленному веб-серверу, что хотим использовать версию HTTP 1.1 для связи. Чтобы получить допустимый 
ответ, вместо ошибки вам нужно ввести некоторое значение для хоста и дважды нажать Enter. Выполнение этих шагов 
предоставит запрошенную страницу индекса.GET / HTTP/1.1GET /page.html HTTP/1.1page.htmlhost: example     

Терминал пентестера
```commandline
pentester@TryHackMe$ telnet MACHINE_IP 80
Trying MACHINE_IP...
Connected to MACHINE_IP.
Escape character is '^]'.
GET / HTTP/1.1
host: telnet

HTTP/1.1 200 OK
Server: nginx/1.6.2
Date: Tue, 17 Aug 2021 11:13:25 GMT
Content-Type: text/html
Content-Length: 867
Last-Modified: Tue, 17 Aug 2021 11:12:16 GMT
Connection: keep-alive
ETag: "611b9990-363"
Accept-Ranges: bytes



...
```

Особый интерес для нас представляет обнаружение типа и версии установленного веб-сервера, Server: nginx/1.6.2. В 
этом примере мы общались с веб-сервером, поэтому использовали базовые команды HTTP . Если мы подключаемся к 
почтовому серверу, нам нужно использовать правильные команды на основе протокола, например SMTP и POP3.  

### Ответить на вопросы ниже
Запустите присоединенную виртуальную машину из задачи 3, если она еще не запущена. На AttackBox откройте терминал и 
используйте клиент telnet для подключения к виртуальной машине на порту 80. Каково имя работающего сервера? 

```commandline
Apache
```
Какова версия работающего сервера (на порту 80 виртуальной машины)?


```commandline
2.4.10
```
## Задание 6
Netcat или просто ncимеет различные приложения, которые могут быть очень полезны для пентестера. Netcat поддерживает 
протоколы TCP и UDP . Он может функционировать как клиент, который подключается к прослушиваемому порту; в качестве 
альтернативы он может выступать в качестве сервера, который прослушивает порт по вашему выбору. Таким образом, это 
удобный инструмент, который вы можете использовать как простой клиент или сервер по TCP или UDP .   

Во-первых, вы можете подключиться к серверу, как вы делали это с Telnet, чтобы получить его баннер, используя nc 
MACHINE_IP PORT, что очень похоже на наш предыдущий telnet MACHINE_IP PORT. Обратите внимание, что вам может 
потребоваться нажать SHIFT+ENTER после строки GET.  

Терминал пентестера
```commandline
pentester@TryHackMe$ nc MACHINE_IP 80
GET / HTTP/1.1
host: netcat

HTTP/1.1 200 OK
Server: nginx/1.6.2
Date: Tue, 17 Aug 2021 11:39:49 GMT
Content-Type: text/html
Content-Length: 867
Last-Modified: Tue, 17 Aug 2021 11:12:16 GMT
Connection: keep-alive
ETag: "611b9990-363"
Accept-Ranges: bytes
...
```

В терминале, показанном выше, мы использовали netcat для подключения к порту MACHINE_IP 80 с помощью` nc MACHINE_IP 
80`. Затем мы выполнили команду get для страницы по умолчанию с помощью ; мы указываем целевому серверу, что наш 
    клиент поддерживает HTTP версии 1.1. Наконец, нам нужно дать имя нашему хосту, поэтому мы добавили на новой 
    строке ; вы можете назвать свой хост как угодно, так как это не повлияет на это упражнение.
GET / HTTP/1.1host: netcat   

На основании полученных данных Server: nginx/1.6.2можно сказать, что на порту 80 у нас Nginx версии 1.6.2 
прослушивает входящие соединения. 

Вы можете использовать netcat для прослушивания TCP- порта и подключения к прослушивающему порту на другой системе.

На серверной системе, где вы хотите открыть порт и прослушивать его, вы можете выполнить `nc -lp 1234` или, что еще 
лучше, `nc -vnlp 1234`, что эквивалентно `nc -v -l -n -p 1234`, как вы помните из Linux room. Точный порядок букв не 
имеет значения, пока номеру порта непосредственно предшествует -p.  

вариант	значение
```commandline
-l	Режим прослушивания
-p	Укажите номер порта
-n	Только числовые данные; разрешение имен хостов через DNS не поддерживается
-v	Подробный вывод (необязательно, но полезно для обнаружения ошибок)
-vv	Очень многословно (необязательно)
-k	Продолжайте слушать после отключения клиента
```

Примечания:

эта опция -p должна располагаться непосредственно перед номером порта, который вы хотите прослушивать.
эта опция -n позволит избежать DNS- поиска и предупреждений.
Для прослушивания портов с номерами менее 1024 требуются права root.
На стороне клиента вы бы выдали nc MACHINE_IP PORT_NUMBER. Вот пример использования ncecho. После того, как вы 
успешно установите соединение с сервером, все, что вы введете на стороне клиента, будет отображено на стороне 
сервера и наоборот.  

Рассмотрим следующий пример. На стороне сервера мы будем прослушивать порт 1234. Мы можем сделать это с помощью 
команды `nc -vnlp 1234`(такой же, как `nc -lvnp 1234`). В нашем случае прослушивающий сервер имеет IP-адрес MACHINE_IP, 
поэтому мы можем подключиться к нему со стороны клиента, выполнив `nc MACHINE_IP 1234`. Эта настройка будет передавать 
все, что вы вводите с одной стороны, на другую сторону туннеля TCP . Вы можете найти запись процесса ниже. Обратите 
внимание, что прослушивающий сервер находится в левой части экрана.    

### Ответить на вопросы ниже
Запустите ВМ и откройте AttackBox. После загрузки AttackBox используйте Netcat для подключения к порту 21 ВМ. Какая 
версия запущенного сервера? 

```commandline
0.17
```

## Задание 7
В этой комнате мы рассмотрели множество различных инструментов. Легко объединить несколько из них с помощью скрипта 
оболочки, чтобы построить примитивный сетевой и системный сканер. Вы можете использовать tracerouteдля сопоставления 
пути к цели, pingдля проверки того, отвечает ли целевая система на ICMP Echo, и telnetдля проверки того, какие порты 
открыты и доступны, пытаясь подключиться к ним. Доступные сканеры делают это на гораздо более продвинутых и сложных 
уровнях, как мы увидим в следующих четырех комнатах с nmap.    

Команда	Пример
```commandline
пинг	ping -c 10 MACHINE_IPна Linux или macOS
пинг	ping -n 10 MACHINE_IPна MS Windows
трассировка	traceroute MACHINE_IPна Linux или macOS
трассировка	tracert MACHINE_IPна MS Windows
телнет	telnet MACHINE_IP PORT_NUMBER
netcat как клиент	nc MACHINE_IP PORT_NUMBER
netcat как сервер	nc -lvnp PORT_NUMBER
```

Хотя это и фундаментальные инструменты, они легко доступны на большинстве систем. В частности, веб-браузер 
установлен практически на каждом компьютере и смартфоне и может стать важным инструментом в вашем арсенале для 
проведения разведки без поднятия тревоги. Если вы хотите получить более глубокие знания об инструментах разработчика,
мы рекомендуем присоединиться к Walking An Application.   

### Ответить на вопросы ниже
Прежде чем переходить к более сложным инструментам, убедитесь, что вы освоили различные базовые, но необходимые 
инструменты, представленные в этой комнате. 

```commandline
Ответ не нужен
```
[>> вернуться на главную страницу](https://github.com/BEPb/tryhackme/blob/master/README.md)