[>> вернуться на главную страницу](https://github.com/BEPb/tryhackme/blob/master/README.md)

# Комната [HTTP Request Smuggling](https://tryhackme.com/r/room/httprequestsmuggling) 

Всего 8 заданий:
## Задание 1
### Введение
HTTP Request Smuggling — это уязвимость, которая возникает при несоответствиях в различных компонентах 
веб-инфраструктуры. Сюда входят прокси, балансировщики нагрузки и серверы, которые интерпретируют границы HTTP- 
запросов. Например, рассмотрим железнодорожную станцию, где билеты проверяются в нескольких точках перед посадкой. 
Если на каждой контрольной точке разные критерии для действительного билета, пассажир может воспользоваться этими 
несоответствиями, чтобы сесть в поезд без действительного билета. Аналогично, в веб-запросах эта уязвимость в 
основном касается заголовков Content-Length и Transfer-Encoding, которые указывают на конец тела запроса. Когда эти 
заголовки манипулируются или интерпретируются непоследовательно в разных компонентах, это может привести к тому, что 
один запрос будет смешан с другим.       

### Процесс контрабанды HTTP-запросов

Разделение запросов или атаки HTTP-десинхронизации возможны из-за природы соединений keep-alive и HTTP-конвейера, 
которые позволяют отправлять несколько запросов по одному и тому же TCP-соединению. Без этих механизмов контрабанда 
запросов была бы невозможна. При расчете размеров Content-Length (CL) и Transfer-Encoding (TE) крайне важно 
учитывать наличие символов возврата каретки \rи новой строки \n. Эти символы не только являются частью 
форматирования протокола HTTP, но и влияют на расчет размеров контента.    

При тестировании уязвимостей контрабанды запросов важно отметить, что некоторые инструменты могут автоматически 
«исправлять» заголовок Content-Length по умолчанию. Это означает, что если вы используете такие инструменты для 
запуска полезных нагрузок, ваши значения Content-Length могут быть перезаписаны, что может изменить результаты теста.   

Обратите внимание, что тестирование на контрабанду запросов может потенциально нарушить работу веб-сайта многими 
способами (отравление кэша, другие запросы пользователей могут начать сбоить или даже внутренний конвейер может 
полностью рассинхронизироваться), поэтому следует проявлять особую осторожность при тестировании на рабочем веб-сайте.  

### Цели
- Узнайте, что такое контрафакт HTTP- запросов и его влияние.
- Выявление уязвимостей HTTP- запросов в веб-приложениях.
- Используйте эти уязвимости в контролируемой среде.
- Понимать и применять меры по смягчению и предотвращению этих уязвимостей.
- Предварительные условия
- Базовое понимание протокола HTTP/1.1 и его заголовков. Вы можете взглянуть на эту комнату для более подробного 
  объяснения.
- Знакомство с компонентами инфраструктуры веб-сервера, такими как балансировщики нагрузки, прокси-серверы и 
  веб-серверы.
- Базовое понимание и использование прокси-инструмента, такого как Burp Suite .
- Важность понимания контрабанды HTTP- запросов
- Контрабандные запросы могут обойти механизмы безопасности, такие как брандмауэры веб-приложений. Это потенциально 
  приводит к несанкционированному доступу или утечкам данных.
- Злоумышленники могут отравлять веб-кэши, внедряя вредоносный контент, в результате чего пользователи видят неверные 
  или вредоносные данные.
- Контрабандные запросы могут быть объединены в цепочку для эксплуатации других уязвимостей системы, что увеличивает 
  потенциальный ущерб.
Из-за сложной природы этой уязвимости она часто остается незамеченной, поэтому специалистам по безопасности крайне важно ее понять и устранить.
### Ответить на вопросы ниже
Разверните целевую виртуальную машину, прикрепленную к этой задаче, нажав зеленую кнопку Start Machine . После 
получения сгенерированного IP-адреса машины вы можете использовать наш AttackBox или собственную виртуальную машину, 
подключенную к VPN TryHackMe.  

```commandline
Ответ не нужен
```

## Задание 2
### Компоненты современных веб-приложений
Современные веб-приложения больше не являются простыми, монолитными структурами. Они состоят из различных 
компонентов, которые работают друг с другом. Ниже приведены некоторые компоненты, из которых обычно состоит 
современное веб-приложение:  

- Фронтенд-сервер : обычно это обратный прокси-сервер или балансировщик нагрузки, который перенаправляет запросы на 
бэкенд.
- Back-end server : Этот компонент на стороне сервера обрабатывает запросы пользователей, взаимодействует с базами 
  данных и передает данные на front-end. Он часто разрабатывается с использованием таких языков, как PHP , Python и Javascript, а также фреймворков, как Laravel, Django или Node.js.
- Базы данных : постоянные системы хранения, в которых хранятся данные приложений. Примерами являются такие базы 
  данных, как MySQL, PostgreSQL и NoSQL.
- API (интерфейсы прикладного программирования) : интерфейсы позволяют интерфейсу и бэкэнду взаимодействовать и 
  интегрироваться с другими сервисами.
- Микросервисы : вместо единого монолитного бэкэнда многие современные приложения используют микросервисы, 
  представляющие собой небольшие независимые сервисы, взаимодействующие по сети, часто с использованием HTTP / REST или gRPC.

### Балансировщики нагрузки и обратные прокси-серверы
- Балансировщики нагрузки : эти устройства или службы распределяют входящий сетевой трафик по нескольким серверам, 
чтобы гарантировать, что ни один сервер не будет перегружен слишком большим трафиком. Такое распределение 
  обеспечивает высокую доступность и надежность, перенаправляя запросы только на те онлайн-серверы, которые могут их 
  обработать. Балансировка нагрузки для веб-серверов часто выполняется обратными прокси-серверами. Примерами 
  являются AWS Elastic Load Balancing, HAProxy и F5 BIG-IP.   
- Обратные прокси : Обратный прокси располагается перед одним или несколькими веб-серверами и перенаправляет 
  клиентские запросы на соответствующий веб-сервер. Хотя они также могут выполнять балансировку нагрузки, их основная цель — предоставить единую точку доступа и управление для внутренних серверов. Примерами являются NGINX, Apache с mod_proxy и Varnish.

### Как работают балансировщики нагрузки и обратные прокси-серверы

#### Роль механизмов кэширования
Кэширование — это метод, используемый для хранения и повторного использования ранее полученных данных или 
вычисленных результатов для ускорения последующих запросов и вычислений. В контексте веб-инфраструктуры:  

- Кэширование контента : сохраняя веб-контент, который редко меняется (например, изображения, CSS и файлы JS), 
механизмы кэширования могут снизить нагрузку на веб-серверы и ускорить доставку контента пользователям.
- Кэширование запросов к базе данных : базы данных могут кэшировать результаты часто выполняемых запросов, сокращая 
  время и ресурсы, необходимые для многократного извлечения одних и тех же данных.
- Полностраничное кэширование : можно кэшировать целые веб-страницы, поэтому их не нужно повторно генерировать для 
  каждого пользователя. Это особенно полезно для веб-сайтов с высоким трафиком.
- Edge Caching/CDN : сети доставки контента (CDN) кэшируют контент ближе к пользователям (на «границе» сети), 
  сокращая задержку и ускоряя доступ для пользователей по всему миру.
- Кэширование API : Кэширование ответов может значительно сократить объем внутренней обработки для API, которые 
  многократно обслуживают похожие запросы.

Кэширование, при правильной реализации, может значительно повысить производительность и отзывчивость веб-приложений. 
Однако правильное управление кэшами имеет важное значение для предотвращения предоставления устаревшего или 
неактуального контента.  

### Ответить на вопросы ниже
Что находится перед одним или несколькими веб-серверами и перенаправляет клиентские запросы на соответствующий 
веб-сервер? 

```commandline
Reverse Proxy
```

## Задание 3
### Понимание структуры HTTP- запроса
Каждый HTTP- запрос состоит из двух основных частей: заголовка и тела.

### HTTP-структура

- Строка запроса : Первая строка запроса — это строка запроса. Она состоит как минимум из трех элементов. Во-первых, 
это метод, который в данном случае — «POST». Метод — это команда из одного слова, которая сообщает серверу, что 
  делать с ресурсом. Во-вторых, это компонент пути URL для запроса. Путь идентифицирует ресурс на сервере, который в 
  данном случае — «/admin/login». Наконец, номер версии HTTP показывает спецификацию HTTP , которой клиент пытался 
  соответствовать в сообщении. Обратите внимание, что HTTP /2 и HTTP /1.1 имеют разные структуры.POST /admin/login 
  HTTP/1.1    
- Заголовки запроса : этот раздел содержит метаданные о запросе, такие как тип отправляемого контента, желаемый 
  формат ответа и токены аутентификации. Это как конверт письма, предоставляющий информацию об отправителе, 
  получателе и характере контента внутри. 
- Текст сообщения : Это фактическое содержимое запроса. Текст может быть пустым для запроса GET, но для запроса POST 
  он может содержать данные формы, полезные данные JSON или загрузки файлов.
- Длина заголовка содержимого
- Заголовок Content-Length указывает размер тела запроса или ответа в байтах. Он сообщает принимающему серверу, 
  сколько данных ожидать, гарантируя получение всего контента.

Запрос образца длины контента
```commandline
POST /submit HTTP/1.1
Host: good.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 14
    
q=smuggledData
```

Это означает, что тело запроса или ответа содержит 14 байт данных.

### Заголовок кодирования передачи
Заголовок Transfer-Encoding используется для указания формы кодирования, применяемой к телу сообщения HTTP-запроса 
или ответа. Обычно используемое значение для этого заголовка — «chunked», указывающее, что тело сообщения разделено 
на ряд фрагментов, каждому из которых предшествует его размер в шестнадцатеричном формате. Другие возможные значения 
для заголовка Transfer-Encoding включают «compress», «deflate» и «gzip», каждое из которых указывает на другой тип 
кодирования. Например:    

Запрос образца кодирования передачи
```commandline
POST /submit HTTP/1.1
Host: good.com
Content-Type: application/x-www-form-urlencoded
Transfer-Encoding: chunked
    
b
q=smuggledData 
0
```
В этом примере "b" (в шестнадцатеричном формате, эквивалентно 11 в десятичном) указывает размер следующего фрагмента.
Фрагмент q=smuggledData представляет собой фактические данные, за которыми следует новая строка. Запрос завершается 
строкой "0", указывающей на конец тела сообщения. Каждый размер фрагмента указывается в шестнадцатеричном формате, а 
конец фрагментированного тела обозначается фрагментом размером 0.   

### Как заголовки влияют на обработку запросов
Заголовки играют важную роль в руководстве сервером для обработки запроса. Это связано с тем, что они определяют, 
как анализировать тело запроса, и влияют на поведение кэширования. Они также могут влиять на аутентификацию, 
перенаправление и другие ответы сервера.  

### Как заголовки влияют на процесс запроса

Манипулирование заголовками, такими как Content-Length и Transfer-Encoding, может создавать уязвимости. Например, 
если прокси-сервер запутается в этих заголовках, он может неправильно различать, где заканчивается один запрос и 
начинается другой.  

### Источник контрабанды HTTP- запросов
Контрабанда HTTP- запросов в основном происходит из-за различий в том, как разные серверы (например, 
front-end-сервер и back-end-сервер) интерпретируют границы HTTP- запросов. Например: 

Если присутствуют оба заголовка Content-Length и Transfer-Encoding, могут возникнуть неоднозначности.
Некоторые компоненты отдают приоритет длине содержимого, в то время как другие отдают приоритет кодированию передачи.
Это несоответствие может привести к тому, что один компонент решит, что запрос завершен, а другой будет думать, что 
он все еще продолжается, что приведет к контрабанде.
Пример: Предположим, что сервер front-end использует заголовок Content-Length для определения конца запроса, в то 
время как сервер back-end использует заголовок Transfer-Encoding. Злоумышленник может создать запрос, который, 
по-видимому, имеет одну границу для сервера front-end, но другую границу для сервера back-end. Это может привести к 
тому, что один запрос будет «контрабандно пронесен» внутрь другого, что приведет к неожиданному поведению и 
потенциальным уязвимостям.    

### Как возникает контрабанда http-запросов

### Ответить на вопросы ниже
Какой заголовок запроса указывает размер тела запроса или ответа в байтах? Это информирует принимающий сервер о том, 
сколько данных ожидать, гарантируя получение всего содержимого. 

```commandline
Content-Length
```

## Задание 4
### Введение в контрабанду запросов CL.TE
CL.TE означает Content-Length/Transfer-Encoding . Название CL.TE происходит от двух задействованных заголовков: 
Content-Length и Transfer-Encoding .  В технике CL.TE злоумышленник использует различия между тем, как разные 
серверы (обычно front-end и back-end) расставляют приоритеты для этих заголовков. Например:  

- Прокси-сервер использует заголовок Content-Length для определения конца запроса.
- Внутренний сервер использует заголовок Transfer-Encoding.

### Как работает контрабанда запросов CL.TE
Из-за этого несоответствия возможно создание неоднозначных запросов, которые интерпретируются по-разному каждым 
сервером. Например, представьте, что вы отправляете запрос с обоими заголовками Content-Lengthи Transfer-Encoding. 
Фронтенд-сервер может использовать заголовок Content-Length и думать, что запрос заканчивается в определенной точке 
из-за предоставленного количества байтов. Напротив, бэкенд-сервер, полагаясь на заголовок Transfer-Encoding, может 
интерпретировать запрос по-разному, что приведет к неожиданному поведению.

### Использование CL.TE для контрабанды запросов
Чтобы использовать технику CL.TE, злоумышленник создает запрос, включающий оба заголовка, гарантируя, что front-end 
и back-end серверы будут интерпретировать границы запроса по-разному.  Например, злоумышленник отправляет запрос типа:

Запрос образца
```commandline
POST /search HTTP/1.1
Host: example.com
Content-Length: 130
Transfer-Encoding: chunked

0

POST /update HTTP/1.1
Host: example.com
Content-Length: 13
Content-Type: application/x-www-form-urlencoded

isadmin=true
```

Здесь сервер front-end видит Content-Length130 байт и считает, что запрос заканчивается после   isadmin=true. Однако 
сервер back-end видит Transfer-Encoding: chunkedи интерпретирует 0как конец фрагмента, делая второй запрос началом 
нового фрагмента. Это может привести к тому, что сервер back-end будет рассматривать как отдельный новый запрос, 
потенциально предоставляя злоумышленнику несанкционированный доступ.POST /update HTTP/1.1    

### Неправильная длина содержимого
При создании контрабандной полезной нагрузки запроса, если Content-Length не равен фактической длине содержимого, 
может возникнуть несколько проблем. Во-первых, сервер может обработать только ту часть тела запроса, которая 
соответствует Content-Length. Это может привести к тому, что контрабандная часть запроса будет проигнорирована или 
не будет обработана так, как предполагалось. Например, на снимке экрана ниже исходный размер тела составляет 24 
байта.    

### правильный заголовок длины содержимого

Чтобы убедиться, что Content-Length является допустимым, мы можем проверить каталог /submissionsи убедиться, что все 
тело сохранено в файле .txt. 

### Полный запрос успешно сохранен

Поскольку размер тела username=test&query=testсоставляет 24 байта, отправка Content-Length с размером меньше этого 
даст указание внутреннему серверу интерпретировать тело запроса по-другому. Например, если Content-Length установлен 
меньше фактического размера тела username=test&query=test(который составляет 24 байта), внутренний сервер прочитает 
только часть тела запроса на основе указанного Content-Length. Например, установка Content-Length в 10 байт означает,
что сервер будет рассматривать только первые 10 байт тела, что приведет к неполной обработке данных.     

Неправильный заголовок длины содержимого

Неполные данные были сохранены

### Ответить на вопросы ниже
Что означает CL.TE?

```commandline
Content-Length/Transfer-Encoding
```

## Задание 5
### Введение в технику TE.CL
TE.CL означает Transfer-Encoding/Content-Length . Этот метод противоположен методу CL.TE. В подходе TE.CL 
расхождение в интерпретации заголовков инвертируется, поскольку front-end сервер использует заголовок 
Transfer-Encoding для определения конца запроса, а back-end сервер использует заголовок Content-Length.  

Метод TE.CL возникает, когда прокси-сервер отдает приоритет Transfer-Encodingзаголовку, в то время как внутренний 
сервер отдает приоритет Content-Lengthзаголовку. 

### Как работает контрабанда TE.CL

Пример: Если злоумышленник отправляет запрос с обоими заголовками, то фронтенд-сервер или прокси-сервер может 
интерпретировать запрос на основе заголовка Transfer-Encoding, в то время как бэкенд-сервер может полагаться на 
Content-Lengthзаголовок. Эта разница в интерпретации может интерпретировать запрос по-разному, что приведет к 
неожиданному поведению.   

### Использование TE.CL для контрабанды запросов
Чтобы воспользоваться техникой TE.CL, злоумышленник создает специально разработанный запрос, включающий заголовки 
Transfer-Encoding и Content-Length , чтобы создать неоднозначность в интерпретации запроса серверами front-end и 
back-end.  

Например, злоумышленник отправляет запрос вида:

Запрос образца
```commandline
POST / HTTP/1.1
Host: example.com
Content-Length: 4
Transfer-Encoding: chunked

78
POST /update HTTP/1.1
Host: example.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 15

isadmin=true
0
```

В приведенной выше полезной нагрузке фронтенд-сервер видит Transfer-Encoding: chunkedзаголовок и обрабатывает запрос 
как фрагментированный. 78(Шестнадцатеричное значение 120) указывает, что следующие 120 байт являются частью тела 
текущего запроса. Фронтенд-сервер рассматривает все до 0(указывающего на конец фрагментированного сообщения) как 
часть тела первого запроса.

Однако внутренний сервер использует заголовок Content-Length, который установлен на 4. Он обрабатывает только первые 
4 байта запроса, не включая весь контрабандный запрос POST /update. Оставшаяся часть запроса, начиная с POST /update 
, затем интерпретируется внутренним сервером как отдельный новый запрос.

Контрабандный запрос обрабатывается внутренним сервером так, как если бы это был законный отдельный запрос. Этот 
запрос включает параметр isadmin=true, который потенциально может повысить привилегии злоумышленника или изменить 
данные на сервере, в зависимости от функциональности приложения.

### Ответить на вопросы ниже
Что означает TE.CL?

```commandline
Transfer-Encoding/Content-Length
```
## Задание 6
### Введение в технику TE.TE
Transfer Encoding Obfuscation, также известная как  TE.TE , означает Transfer-Encoding/Transfer-Encoding . В отличие 
от методов CL.TE или TE.CL, техника TE.TE возникает, когда и front-end, и back-end серверы используют заголовок 
Transfer-Encoding.  В технике TE.TE злоумышленник использует непоследовательную обработку серверами 
Transfer-Encoding, присутствующего в заголовках HTTP .   

Уязвимость TE.TE не всегда требует нескольких заголовков Transfer-Encoding. Вместо этого она часто включает один 
неправильно сформированный заголовок Transfer-Encoding, который по-разному интерпретируется front-end и back-end 
серверами. В некоторых случаях front-end сервер может игнорировать или удалять неправильно сформированную часть 
заголовка и обрабатывать запрос обычным образом, в то время как back-end сервер может интерпретировать запрос 
по-разному из-за неправильно сформированного заголовка, что приводит к контрабанде запроса.    

### Как работает контрабанда запросов TE.TE

Пример : злоумышленник манипулирует заголовком Transfer-Encoding, включая "chunked" в неправильно сформированные 
вариации. Это делается для того, чтобы использовать то, как front-end и back-end серверы отдают приоритет заголовку 
Transfer-Encoding (TE) над Content-Length (CL). Создавая неправильно сформированные заголовки Transfer-Encoding, 
злоумышленник стремится заставить один сервер игнорировать заголовок TE и использовать вместо него CL, что приводит 
к расхождению в том, как интерпретируются границы запроса между front-end и back-end серверами. Эта манипуляция 
может привести либо к ситуации CL.TE, либо к TE.CL, в зависимости от того, какой сервер возвращается к использованию 
Content-Length.      

### Использование TE.TE для контрабанды запросов
Чтобы использовать технику TE.TE, злоумышленник может создать запрос, включающий заголовки Transfer-Encoding, 
которые используют разные кодировки.  Например, злоумышленник отправляет запрос типа: 

Запрос образца
```commandline
POST / HTTP/1.1
Host: example.com
Content-length: 4
Transfer-Encoding: chunked
Transfer-Encoding: chunked1

4e
POST /update HTTP/1.1
Host: example.com
Content-length: 15

isadmin=true
0
```

В приведенной выше полезной нагрузке фронтенд-сервер встречает два Transfer-Encodingзаголовка. Первый из них — 
стандартная фрагментированная кодировка, а второй, chunked1, — нестандартный. В зависимости от конфигурации 
фронтенд-сервер может обрабатывать запрос на основе первого Transfer-Encoding: chunkedзаголовка и игнорировать 
неправильно сформированный chunked1, интерпретируя весь запрос вплоть до 0как единое фрагментированное сообщение.

Однако внутренний сервер может обработать неправильно сформированный запрос Transfer-Encoding: chunked1по-другому. 
Он может либо отклонить неправильно сформированную часть и обработать запрос аналогично внешнему серверу, либо 
интерпретировать запрос по-другому из-за наличия нестандартного заголовка. Если он обрабатывает только первые 4 
байта, как указано в Content-length: 4, оставшаяся часть запроса, начиная с , POST /updateзатем обрабатывается как 
отдельный новый запрос.    

Контрабандный запрос с isadmin=true параметром обрабатывается внутренним сервером, как если бы это был законный 
отдельный запрос. Это может привести к несанкционированным действиям или изменению данных, в зависимости от 
функциональности сервера и характера конечной точки /update.  

### Ответить на вопросы ниже
Что означает TE.TE?
```commandline
Transfer-Encoding/Transfer-Encoding
```
## Задание 7
### Прохождение
Уязвимая среда имеет ATS (Apache Traffic Server) в качестве front-end proxy, Nginx в качестве back-end веб-сервера и 
PHP , обрабатывающий динамический контент. Из-за различий в том, как ATS и Nginx расставляют приоритеты 
Content-Lengthи Transfer-Encodingзаголовки, существует вероятность контрабанды HTTP- запросов. Начните с добавления 
httprequestsmuggling.thmв свой /etc/hostsфайл.   

/etc/хосты
```commandline
127.0.0.1       localhost
127.0.1.1       tryhackme.lan   tryhackme
MACHINE_IP     httprequestsmuggling.thm
# The following lines are desirable for IPv6 capable hosts
::1     localhost ip6-localhost ip6-loopback
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters
```
### Оценка заявки
Веб-приложение для этой комнаты использует ссылку http://httprequestsmuggling.thm . Оно содержит форму Home, Login и 
Contact, которая позволяет пользователям получать доступ и отправлять отзывы разработчику. Для демонстрации 
отправленные запросы сохраняются в каталоге /submissions.  Ниже приведен снимок экрана приложения:   

Домашняя страница уязвимого приложения


Использование приложения
Используя Burp Suite Proxy, перехватите запрос, отправленный в индекс веб-сайта. Этот запрос станет базовым, который 
мы будем использовать для эксплуатации уязвимого приложения. 

Базовый запрос на использование в целях контрабанды

Отправьте запрос Intruder и скопируйте и вставьте указанную ниже полезную нагрузку в поле «Позиции полезной нагрузки».

Полезная нагрузка
```commandline
POST / HTTP/1.1
Host: httprequestsmuggling.thm
Content-Type: application/x-www-form-urlencoded
Content-Length: 160
Transfer-Encoding: chunked

0

POST /contact.php HTTP/1.1
Host: httprequestsmuggling.thm
Content-Type: application/x-www-form-urlencoded
Content-Length: 500

username=test&query=§
```

Распределение полезной нагрузки
В уязвимости CL.TE, поскольку прокси или фронтенд отдают приоритет заголовку Content-Length , 160 байт тела 
считаются телом первого POST. Фронтенд думает, что это один запрос, и пересылает его в конвейер, где бэкенд-сервер 
теперь отдает приоритет Transfer-Encoding, заканчивая первый запрос POST на первом фрагменте размером 0 и 
предполагая, что второй POST — это другой запрос.   

Коробка позиций полезной нагрузки с полезной нагрузкой

Коробка позиций полезной нагрузки с полезной нагрузкой

Перейдите на вкладку Payloads и установите Payload type на Null payloads . Затем в настройках Payload введите 10000, чтобы сгенерировать 10000 null payloads.

Настройки нулевых полезных нагрузок

Перейдите на вкладку Resource pool и создайте новый resource pool. Вы можете следовать скриншоту ниже для настроек.

Новый пул ресурсов

Нажмите кнопку «Начать атаку» на вкладке «Злоумышленник», чтобы начать атаку.

Атака началась

Через несколько минут проверьте /submissions каталог веб-сайта, чтобы убедиться, что запрос к contact.php не содержит в себе запросы других пользователей.

Примечание: доступ к уязвимому приложению во время осуществления контрабанды приведет к перехвату вашего запроса вместо запроса целевого пользователя.

Страница отправки, содержащая сохраненный запрос

Просмотрите текстовые файлы и проверьте наличие пароля, добавленного к параметру запроса.

Файл .txt, содержащий перехваченный запрос целевого пользователя

Используйте пароль для входа в приложение.

Страница, содержащая флаг после входа в систему

### Ответить на вопросы ниже
Что за флаг на панели инструментов?


```commandline
THM{1c4N_$mU66l3!!}
```
## Задание 8
### Заключение
Контрабанда HTTP- запросов происходит из-за различий в интерпретации заголовков запросов серверами, в основном за 
счет манипуляции заголовками Content-Length и Transfer-Encoding, что приводит к нечетким границам запроса. Это может 
привести к тому, что серверы в средах с компонентами front-end и back-end будут неправильно определять пределы 
запросов, что потенциально позволяет обойти защиту и получить несанкционированный доступ к данным.   

Подходы к смягчению последствий
- Единая обработка заголовков: убедитесь, что все серверы обрабатывают заголовки одинаково, чтобы исключить 
возможность контрабанды.
- Используйте HTTP /2: переход на HTTP /2 может улучшить управление границами запросов, снижая риск контрабанды.
- Постоянное наблюдение и проверки: следите за трафиком сервера на предмет признаков контрабанды и проводите 
  периодические проверки для поддержания безопасных настроек сервера.
- Осведомленность команды: убедитесь, что команды разработки и эксплуатации понимают опасности контрабанды запросов и 
  меры предосторожности.
Подводя итог, можно сказать, что, несмотря на значительный риск, связанный с контрабандой HTTP- запросов, это 
  управляемая проблема с правильными знаниями, стратегиями и ресурсами. Особое внимание к безопасности при 
  разработке и управлении веб-приложениями имеет решающее значение для защиты как самого приложения, так и его 
  пользователей.   

### Ответить на вопросы ниже
Теперь я могу использовать уязвимости HTTP-запросов!

```commandline
Ответ не нужен
```
[>> вернуться на главную страницу](https://github.com/BEPb/tryhackme/blob/master/README.md)