[>> вернуться на главную страницу](https://github.com/BEPb/tryhackme/blob/master/README.md)

# Комната [SQL Injection Lab]() 

Всего 10 заданий:
## Задание 1
Эта комната предназначена для введения в SQL- инъекцию и демонстрирует различные атаки SQL- инъекции. Она не 
предназначена для изучения самого языка SQL. Настоятельно рекомендуется иметь некоторые предварительные знания языка 
SQL.  

Веб-приложение можно найти по адресу:  http://10.10.162.127:5000

Примечание: для развертывания потребуется не менее пяти минут.

Можно отобразить SQL-запросы, выполненные приложением в задачах, включив «Показать запрос» в правом верхнем меню на  
http://10.10.162.127:5000 . Также можно отобразить руководство по задачам, включив «Руководство». 

Все скрипты, упомянутые в задачах, можно просмотреть и загрузить, посетив страницу «Загрузки» в верхнем левом углу 
целевой страницы или перейдя по адресу  http://10.10.162.127:5000/downloads/. 

### Ответить на вопросы ниже
Разверните машину

```commandline
Ответ не нужен
```

## Задание 2
SQL- инъекция — это метод, с помощью которого злоумышленники могут выполнять свои собственные вредоносные SQL- 
выражения, обычно называемые вредоносной полезной нагрузкой. С помощью вредоносных SQL- выражений злоумышленники 
могут украсть информацию из базы данных жертвы; что еще хуже, они могут вносить изменения в базу данных. Наше 
веб-приложение для управления сотрудниками имеет уязвимости SQL- инъекции, которые имитируют ошибки, часто 
допускаемые разработчиками.    

Приложениям часто требуются динамические SQL -запросы для отображения контента на основе различных условий, 
установленных пользователем. Чтобы разрешить динамические SQL- запросы, разработчики часто объединяют 
пользовательский ввод непосредственно в оператор SQL . Без проверки полученных входных данных конкатенация строк 
становится наиболее распространенной ошибкой, которая приводит к уязвимости SQL- инъекции. Без очистки входных 
данных пользователь может заставить базу данных интерпретировать пользовательский ввод как оператор SQL, а не как 
данные. Другими словами, злоумышленник должен иметь доступ к параметру, которым он может управлять, который входит в 
оператор SQL . Имея контроль над параметром, злоумышленник может внедрить вредоносный запрос, который будет выполнен 
базой данных. Если приложение не очищает заданные входные данные из контролируемого злоумышленником параметра, 
запрос будет уязвим для атаки SQL- инъекции.         

Следующий код PHP демонстрирует динамический SQL- запрос в форме входа. Переменные пользователя и пароля из запроса 
POST объединяются непосредственно в оператор SQL. 

`$ query  =  " SELECT * FROM users WHERE username=' "  +  $ _POST [ " user " ]  +  " ' AND password= ' "  +  $ _POST [ " password " ] $  +  ' ";"`
Если злоумышленник предоставляет значение  ' OR 1 = 1 -- -  внутри параметра имени, запрос может вернуть более 
одного пользователя. Большинство приложений обработают первого возвращенного пользователя, что означает, что 
злоумышленник может воспользоваться этим и войти в систему как первый пользователь, возвращенный запросом. 
Последовательность двойного тире (--) является индикатором комментария в SQL и приводит к тому, что остальная часть 
запроса закомментируется. В SQL строка заключается либо в одинарную кавычку ('), либо в двойную кавычку ("). 
Одинарная кавычка (') во входных данных используется для закрытия строкового литерала. Если злоумышленник вводит  ' 
OR 1 = 1 -- -  в параметр имени и оставляет пароль пустым, запрос выше приведет к следующему оператору SQL.

ВЫБЕРИТЕ  *  ИЗ  пользователей,  ГДЕ  имя пользователя  =  ''  ИЛИ  1 = 1 -- - '  И пароль =  ''
Если база данных выполняет SQL-выражение выше, возвращаются все пользователи в таблице пользователей. Следовательно, 
злоумышленник обходит механизм аутентификации приложения и входит в систему как первый пользователь, возвращенный 
запросом.   

Причина использования  -- - вместо  --  в первую очередь связана с тем, как MySQL обрабатывает стиль комментариев с 
двойным тире.  

От  последовательности --   до конца строки. В MySQL  стиль комментариев --   (двойное тире) требует, чтобы за 
вторым тире следовал хотя бы один пробел или управляющий символ (такой как пробел, табуляция, новая строка и т. д.). 
Этот синтаксис немного отличается от стандартного синтаксиса комментариев SQL, как обсуждалось в разделе 1.7.2.4, «' 
-- ' как начало комментария». ( dev.mysql.com )   

 Самым безопасным решением для встроенного комментария SQL является использование --<пробел><любой символ>, например 
 -- -,  поскольку если он закодирован в URL в  --%20-, он все равно будет декодирован как  -- - . Для получения 
 дополнительной информации см.:  https://blog.raw.pm/en/sql-injection-mysql-comment/

SQL- инъекция 1: поле ввода, не являющееся строкой
Когда пользователь входит в систему, приложение выполняет следующий запрос:

ВЫБЕРИТЕ  uid,  имя,  profileID,  зарплату,  номер паспорта,  email,  псевдоним,  пароль ИЗ usertable, ГДЕ profileID 
= 10 И пароль =  'ce5ca67... ' 
При входе в систему пользователь вводит данные в параметр profileID. Для этого вызова параметр принимает целое число,
как можно увидеть здесь: 

профильID = 10
Поскольку очистка входных данных не производится, можно обойти вход в систему, используя любое истинное условие, 
например, указанное ниже в качестве ProfileID. 

1  или  1 = 1 -- -
Обойдите вход в систему и восстановите флаг.

SQL- инъекция 2: строка поля ввода
В этом вызове используется тот же запрос, что и в предыдущем вызове. Однако параметр ожидает строку вместо целого 
числа, как можно увидеть здесь: 

профильID = ' 10 '
Поскольку он ожидает строку, нам нужно изменить нашу полезную нагрузку, чтобы немного обойти вход. Следующая строка 
позволит нам войти: 

1 '  или  ' 1 ' = ' 1 ' -- -
Обойдите вход в систему и восстановите флаг.

SQL -инъекция 3 и 4: URL- и POST-инъекция
Здесь SQL- запрос такой же, как и предыдущий:

ВЫБЕРИТЕ  uid ,  имя ,  profileID ,  зарплату ,  номер паспорта ,  email ,  псевдоним ,  пароль  ИЗ  usertable  , 
ГДЕ  profileID = ' 10 '  И  пароль = ' ce5ca67... ' 
Однако в этом случае вредоносный пользовательский ввод не может быть внедрен непосредственно в приложение через 
форму входа, поскольку были реализованы некоторые элементы управления на стороне клиента: 

функция  validateform ()  {
    var  profileID  =  document.inputForm.profileID.value ;
    var  пароль  =  документ.inputForm.пароль.значение ;

    если  ( / ^ [ a-zA-Z0-9 ]* $ / . test ( profileID )  ==  false  || / ^ [ a-zA-Z0-9 ]* $ / . test ( password )  == false )  {  
        alert ( " Поля ввода не могут содержать специальные символы " ) ;
        вернуть  ложь ;
    }
    если  ( profileID  ==  null  ||  пароль  ==  null )  {
        alert ( " Поля ввода не могут быть пустыми. " ) ;
        вернуть  ложь ;
    }
}
Приведенный выше код JavaScript требует, чтобы и profileID, и пароль содержали только символы между az, AZ и 0-9. 
Клиентские элементы управления предназначены только для улучшения пользовательского опыта и никоим образом не 
являются функцией безопасности, поскольку пользователь имеет полный контроль над клиентом и отправляемыми им данными.
Например, прокси-инструмент, такой как Burp Suite, можно использовать для обхода проверки JavaScript на стороне 
клиента ( https://portswigger.net/support/using-burp-to-bypass-client-side-javascript-validation ).     

### SQL -инъекция 3: URL-инъекция
В этом задании используется запрос GET при отправке формы входа, как показано здесь:

Вход в систему и проверку на стороне клиента можно легко обойти, перейдя непосредственно по этому URL-адресу:

http://10.10.162.127:5000/sesqli3/login?profileID=-1' или 1=1-- -&password=a

Браузер автоматически urlencode это для нас. Urlencode необходимо, так как протокол HTTP не поддерживает все символы 
в запросе. После urlencode URL выглядит следующим образом: 

http://10.10.162.127:5000 /sesqli3/login?profileID=-1%27%20or%201=1--%20-&password=a

%27 становится символом одинарной кавычки ('), а %20 становится пробелом.

### SQL- инъекция 4: POST-инъекция
При отправке формы входа для этого вызова используется метод HTTP POST. Можно либо удалить/отключить JavaScript, 
проверяющий форму входа, либо отправить действительный запрос и перехватить его с помощью прокси-инструмента, такого 
как Burp Suite, и изменить его:  


Информацию о том, как работает Burp Suite, можно найти на   странице Burp Suite  .

#### Ответить на вопросы ниже
Что такое флаг для SQL-инъекции 1: поле ввода не является строкой?


```commandline
THM{dccea429d73d4a6b4f117ac64724f460}
```
Что такое флаг для SQL-инъекции 2: строка поля ввода?


```commandline
THM{356e9de6016b9ac34e02df99a5f755ba}
```
Что такое флаг SQL-инъекции 3: URL-инъекция?


```commandline
THM{645eab5d34f81981f5705de54e8a9c36}
```
Что такое флаг для SQL-инъекции 4: POST-инъекция?

```commandline
THM{727334fd0f0ea1b836a8d443f09dc8eb}
```

## Задание 3
### Атака SQL -инъекции на оператор UPDATE
 Если SQL- инъекция происходит в операторе UPDATE, ущерб может быть гораздо более серьезным, поскольку это позволяет 
 изменять записи в базе данных. В приложении управления сотрудниками есть страница редактирования профиля, как 
 показано на следующем рисунке.  

Эта страница редактирования позволяет сотрудникам обновлять свою информацию, но у них нет доступа ко всем доступным 
полям, и пользователь может только изменять свою информацию. Если форма уязвима для SQL- инъекции, злоумышленник 
может обойти реализованную логику и обновить поля, которые им не положено обновлять, или для других пользователей.  

Теперь мы перечислим базу данных с помощью оператора UPDATE на странице профиля. Предположим, что у нас нет никаких 
предварительных знаний о базе данных. Просматривая исходный код веб-страницы, мы можем определить потенциальные 
имена столбцов, просматривая атрибут name. Столбцы не обязательно должны быть названы так, но есть большая 
вероятность, что это так, и такие имена столбцов, как «email» и «password», не являются редкостью и могут быть легко 
угаданы.    



Чтобы подтвердить, что форма уязвима и что у нас есть рабочие имена столбцов, мы можем попробовать внедрить в поля 
«nickName» и «email» что-то похожее на код ниже: 

`asd ' , nickName = ' test ' , email = ' взломан`
При внедрении вредоносной нагрузки в поле nickName обновляется только nickName. При внедрении в поле email 
обновляются оба поля: 



Первый тест подтвердил, что приложение уязвимо и что у нас правильные имена столбцов. Если бы у нас были 
неправильные имена столбцов, ни одно из полей не было бы обновлено. Поскольку оба поля обновляются после внедрения 
вредоносной нагрузки, исходный оператор SQL , вероятно, выглядит примерно так:  

ОБНОВЛЕНИЕ  < имя_таблицы >  SET  nickName = ' имя ' ,  email = ' адрес электронной почты '  ГДЕ  < условие >
Имея эти знания, мы можем попытаться определить, какая база данных используется. Есть несколько способов сделать это,
но самый простой способ — попросить базу данных идентифицировать себя. Следующие запросы можно использовать для 
идентификации MySQL, MSSQL, Oracle и SQLite:  
```commandline
# MySQL и MSSQL
', ник =@@ версия , эл. почта = '
# Для Оракула
', nickName =( ВЫБРАТЬ  баннер  ИЗ  v $ version ), email = '
# Для SQLite
', ник = sqlite_version (), электронная почта = '
```

Вставка строки с «sqlite_version()» в поле nickName показывает, что мы имеем дело с SQLite и что номер версии — 3.27.2:



Знание того, с какой базой данных мы имеем дело, облегчает понимание того, как строить наши вредоносные запросы. Мы 
можем продолжить перечисление базы данных, извлекая все таблицы. В коде ниже мы выполняем подзапрос для извлечения 
всех таблиц из базы данных и помещаем их в поле nickName. Подзапрос заключен в скобки.  Функция group_concat() 
используется для одновременного дампа всех таблиц.     

«Функция group_concat() возвращает строку, которая является объединением всех ненулевых значений X. Если параметр Y 
присутствует, то он используется в качестве разделителя между экземплярами X. Запятая («,») используется в качестве 
разделителя, если Y опущен. Порядок объединенных элементов произвольный».  

`', nickName =( SELECT  group_concat ( tbl_name )  FROM  sqlite_master  WHERE  type = ' table '  и  tbl_name  НЕ  как  ' sqlite_% ' ), email = '`
Внедрив код выше, мы увидим, что единственная таблица в базе данных называется «usertable»:



Затем мы можем продолжить, извлекая все имена столбцов из пользовательской таблицы:

`', nickName =( SELECT  sql  FROM  sqlite_master  WHERE  type != ' meta '  AND  sql  NOT  NULL  AND  name = ' usertable ' ), email = '`
И как видно ниже, таблица пользователей содержит столбцы: UID , имя, profileID, зарплата, номер паспорта, адрес электронной почты, псевдоним и пароль:



Зная имена столбцов, мы можем извлечь нужные нам данные из базы данных. Например, запрос ниже извлечет profileID, 
имя и пароли из usertable. Подзапрос использует  функцию group_concat() для одновременного выгрузки всей информации, 
а  оператор || выполняет функцию «конкатенации» — он объединяет строки своих операндов ( sqlite.org ).   

`, nickName =( SELECT  group_concat ( profileID  ||  " , "  ||  имя  ||  " , "  ||  пароль  ||  " : " )  из  usertable ), email = `

После выгрузки данных из базы данных мы видим, что пароль хеширован. Это означает, что нам нужно будет определить 
правильный тип хэша, если мы хотим обновить пароль для пользователя. Используя идентификатор хэша, такой как 
hash-identifier, мы можем определить хэш как SHA256:  

Существует несколько способов генерации хэша sha256. Например, мы можем использовать  https://gchq.github.io/CyberChef/ :

Затем мы можем обновить пароль для пользователя Admin с помощью следующего кода:

',  пароль = ' 008c70392e3abfbd0fa47bbc2ed96aa99bd49e159727fcba0f2e6abeb3a9d601 '  ГДЕ  имя = ' Администратор ' -- -
### Задача
Войдите в " SQL Injection 5: UPDATE Statement" и используйте уязвимую страницу профиля, чтобы найти флаг. Учетные 
данные, которые можно использовать: 

ID профиля:10
пароль:toor


Здесь необходимо выполнить то же перечисление, что и для поиска таблиц и имен столбцов, поскольку флаг хранится 
внутри другой таблицы. 

### Ответить на вопросы ниже
Что такое флаг для SQL-инъекции 5: оператор UPDATE?

```commandline
THM{b3a540515dbd9847c29cffa1bef1edfb}
```

## Задание 4
#### Цель
Цель этого задания — найти способ обойти аутентификацию, чтобы получить флаг. 
#### Описание
На целевой странице http://MACHINE_IP:5000  перейдите в раздел Broken Authentication в разделе Track: Vulnerable Startup ( http://MACHINE_IP:5000/challenge1/ ).

#### Задача
Обойдите вход в систему и восстановите флаг.

### Ответить на вопросы ниже
Какой флаг у этого испытания?
```commandline
THM{f35f47dcd9d596f0d3860d14cd4c68ec}
```

## Задание 5
### Цель
Эта задача основывается на предыдущей. Здесь цель — найти способ сбросить все пароли в базе данных, чтобы получить 
флаг без использования слепого внедрения. 

### Описание
Форма входа по-прежнему уязвима для SQL-инъекций, и можно обойти вход, используя  `' OR 1 = 1 -- - ` в качестве имени 
пользователя.  

Прежде чем сбрасывать все пароли, нам нужно определить места, где в приложении возвращаются результаты запроса на 
вход. После входа в систему имя текущего пользователя отображается в правом верхнем углу, поэтому можно сбросить 
данные туда, как показано здесь:  

Данные из запроса также могут быть сохранены в сеансовом cookie. Можно извлечь сеансовый cookie, открыв инструменты 
разработчика в браузере, что можно сделать, нажав F12. Затем перейдите в Storage и скопируйте значение сеансового 
cookie, как показано здесь:  

Затем можно расшифровать cookie по адресу  https://www.kirsle.net/wizards/flask-session.cgi или с помощью 
пользовательского скрипта. Скрипт для расшифровки cookie можно загрузить внутри виртуальной машины , перейдя по 
адресу  http://MACHINE_IP:5000/download/decode_cookie.py .   

После входа в систему с использованием ' OR 1=1-- -  в качестве имени пользователя  ниже можно увидеть 
расшифрованный файл cookie, и ясно, что в него помещены идентификатор пользователя и имя пользователя из запроса на вход.  
```commandline
{
    " challenge2_user_id " :  1 ,
    " challenge2_username " :  " admin "
}
```

Можно сбросить пароли, используя SQL- инъекцию на основе UNION. Для работы инъекции на основе UNION необходимо 
выполнить два ключевых требования: 

Количество столбцов во введенном запросе должно быть таким же, как и в исходном запросе.
Типы данных для каждого столбца должны соответствовать соответствующему типу
При входе в приложение оно выполнило запрос ниже. Из SQL- выражения мы видим, что оно извлекает два столбца: id и 
username. 

ВЫБЕРИТЕ  идентификатор ,  имя пользователя  ИЗ  пользователей,  ГДЕ  имя пользователя  =  ' " + имя пользователя + 
" '  И  пароль  =  ' " + пароль + " ' 
Не зная заранее количество столбцов, злоумышленник должен сначала перечислить количество столбцов, систематически 
вводя запросы с разным количеством столбцов, пока это не увенчается успехом. Например: 
```commandline
 1 '  ОБЪЕДИНЕНИЕ ВЫБИРАЕТ NULL-- -
 1 '  ОБЪЕДИНЕНИЕ ВЫБИРАЕТ NULL, NULL-- -
 1 '  ОБЪЕДИНЕНИЕ ВЫБОР NULL, NULL, NULL-- -
```

В этом случае успешное выполнение означает, что приложение успешно войдет в систему, когда будет введено правильное 
 количество столбцов. В других случаях, если включены сообщения об ошибках, может отображаться предупреждение 
 «SELECT слева и справа от UNION не имеют одинакового количества столбцов результата», когда введено неправильное 
 количество столбцов.   

Используя  ' UNION SELECT 1 , 2 -- -  в качестве имени пользователя, мы сопоставляем количество столбцов в исходном 
запросе SQL , и приложение позволяет нам войти. После входа в систему мы видим, что имя пользователя заменено целым 
числом 2, которое мы использовали в качестве второго столбца во внедренном запросе.     



То же самое касается имени пользователя в сеансовом cookie. Расшифровав его, мы увидим, что имя пользователя было 
заменено тем же значением, что и выше. 
```commandline
{
    " challenge2_user_id " :  1 ,
    " challenge2_имя_пользователя " :  2
}
```

Перечислите базу данных, чтобы найти таблицы и столбцы, как мы делали в Задании 2 Введение в SQL- инъекцию. Для 
этого может быть полезна шпаргалка, например  PayloadsAllTheThings  . Целью задачи было выгрузить все пароли, чтобы 
получить флаг, поэтому в этом случае мы предположим, что имя столбца —  password  , а имя таблицы —  users . 
Используя эту логику, можно выгрузить пароли с помощью следующего кода:

`'  UNION  SELECT  1 ,  пароль  от  пользователей -- -`
Однако предыдущее выражение вернет только один пароль. Функция group_concat() может помочь достичь цели 
одновременного сброса всех паролей.  
Вставив следующий код в поле имени пользователя:

`'  ОБЪЕДИНЕНИЕ  ВЫБЕРИТЕ  1 , group_concat ( пароль )  ОТ  пользователей -- -`
Все пароли сброшены:


Пароли также можно получить, расшифровав cookie-файл сеанса Flask:
```commandline
{
    " challenge2_user_id " :  1 ,
    " challenge2_username " :  " rcLYWHCxeGUsA9tH3GNV,asd,Лето2019!,345m3io4hj3, THM {AuTh2} ,viking123 "
}

```

Задача
Воспользуйтесь уязвимой формой входа и получите флаг.
### Ответить на вопросы ниже
Какой флаг у этого испытания?

```commandline
THM{fb381dfee71ef9c31b93625ad540c9fa}
```
## Задание 6
### Цель
Эта задача имеет ту же уязвимость, что и предыдущая. Однако теперь невозможно извлечь данные из cookie сеанса Flask 
или через отображение имени пользователя. Форма входа по-прежнему имеет ту же уязвимость, но на этот раз цель 
состоит в том, чтобы злоупотребить формой входа с помощью слепой инъекции SQL для извлечения пароля администратора.   

### Описание
Для извлечения пароля будет использоваться слепая инъекция SQL на основе булевых значений. Слепые инъекции 
утомительны и требуют много времени для выполнения вручную, поэтому планируется создать скрипт для извлечения пароля 
посимвольно. Перед созданием скрипта для автоматизации инъекции крайне важно понять, как работает инъекция. Идея 
заключается в отправке SQL-запроса, задающего вопросы «истина» или «ложь» для каждого символа в пароле. Ответ 
приложения будет проанализирован, чтобы понять, вернула ли база данных «истина» или «ложь». В этом случае приложение 
позволит нам войти, если ответ будет успешным, или останется на странице входа, сообщая «Неверное имя пользователя 
или пароль» в случае возврата «ложь», как показано на изображении ниже.      



Как уже говорилось ранее, мы захотим отправить булевы вопросы в базу данных для каждого символа в пароле, спрашивая 
базу данных, угадали ли мы правильный символ или нет. Чтобы добиться этого, нам понадобится способ контролировать, 
на каком символе мы находимся, и увеличивать его каждый раз, когда мы угадаем правильный символ в текущей позиции.  
Функция substr SQLite  может помочь нам достичь этой функциональности.   

«Функция substr SQLite возвращает подстроку из строки, начинающуюся с указанной позиции, с предопределенной длиной». 
( Учебник SQLite ) 

Первый аргумент  substr  — это сама строка, которая будет паролем администратора. Второй аргумент — это начальная 
позиция, а третий аргумент — это длина подстроки, которая будет возвращена. 

SUBSTR (  строка ,  < начало >,  < длина >)
Ниже приведен пример   использования  substr — символ после знака равенства (=) обозначает возвращаемую подстроку.

--  Изменение начала
SUBSTR ( " THM {Слепой} " ,  1 , 1 )  =  T
SUBSTR ( " THM {Слепой} " ,  2 , 1 )  =  H
SUBSTR ( " THM {Слепой} " ,  3 , 1 )  =  M

--  Изменение длины
SUBSTR ( " THM {Слепой} " ,  1 , 3 )  =  THM

Следующим шагом будет ввод пароля администратора в виде строки в  функцию substr  . Это можно сделать с помощью 
следующего запроса: 

`( ВЫБЕРИТЕ  пароль  ИЗ ОГРАНИЧЕНИЯ   пользователей  0 , 1 )`

Предложение  LIMIT  используется для ограничения объема данных, возвращаемых оператором SELECT. Первое число, 0, 
является смещением, а второе целое число — пределом: 

`ПРЕДЕЛ  < СМЕЩЕНИЕ >,  < ПРЕДЕЛ >`
Ниже приведены несколько примеров предложения  LIMIT  в действии. Правая таблица представляет собой пользовательскую 
таблицу. 
```commandline
sqlite >  ВЫБЕРИТЕ  пароль  ИЗ  пользователей  LIMIT  0 , 1
THM { Слепой }
sqlite >  ВЫБЕРИТЕ  пароль  ИЗ  пользователей  LIMIT  1 , 1
Лето 2019!
sqlite >  ВЫБЕРИТЕ  пароль  ИЗ  пользователей  LIMIT  0 , 2
THM { Слепой }
Лето 2019!
THM {Слепой}
Лето 2019!
Викинг123
```

SQL-запрос для возврата первого символа пароля администратора можно увидеть здесь:

SUBSTR (( ВЫБЕРИТЕ  пароль  ИЗ ОГРАНИЧЕНИЯ   пользователей  0 , 1 ), 1 , 1 )
Теперь нам понадобится способ сравнить первый символ пароля с нашим угаданным значением. Сравнивать символы легко, и 
мы можем сделать это следующим образом: 

SUBSTR (( ВЫБЕРИТЕ  пароль  ИЗ ОГРАНИЧЕНИЯ   пользователей  0 , 1 ), 1 , 1 )  =  ' T '
Однако, сработает ли этот подход или нет, будет зависеть от того, как приложение обрабатывает входные данные. 
Приложение преобразует имя пользователя в нижний регистр для этой задачи, что нарушает упомянутый подход, поскольку 
заглавная T не то же самое, что строчная t. Шестнадцатеричное представление ASCII T — 0x54 и 0x74 для строчной t. 
Чтобы справиться с этим, мы можем ввести наш символ в шестнадцатеричном представлении через тип подстановки X , а 
затем использовать выражение CAST SQLite для преобразования значения в тип данных, ожидаемый базой данных.    

"x,X: Аргумент — целое число, отображаемое в шестнадцатеричном формате. Для %x используются строчные 
шестнадцатеричные символы, а для %X — заглавные" - ( sqlite.org ) 

Это означает, что мы можем ввести T как X'54'. Чтобы преобразовать значение в тип SQLite Text, мы можем использовать 
выражение CAST следующим образом: CAST(X'54' as Text). Наш окончательный запрос теперь выглядит следующим образом: 

SUBSTR (( SELECT  password  FROM  users  LIMIT  0 , 1 ), 1 , 1 )  =  CAST ( X ' 54 '  as  Text )
Перед использованием созданного нами запроса нам нужно будет привести его в соответствие с исходным запросом. Наш 
запрос будет помещен в поле имени пользователя. Мы можем закрыть параметр имени пользователя, добавив одинарную 
кавычку ('), а затем добавить оператор AND, чтобы добавить к нему наше условие. Затем добавьте два тире (--), чтобы 
закомментировать проверку пароля в конце запроса. После этого наш вредоносный запрос будет выглядеть следующим образом:   

admin '  AND  SUBSTR (( SELECT  password  FROM  users  LIMIT  0 , 1 ), 1 , 1 )  =  CAST ( X ' 54 '  as  Text ) -- -
При введении этого значения в поле имени пользователя конечный запрос, выполняемый базой данных, будет следующим:

`SELECT  id ,  username  FROM  users  WHERE  username  =  ' admin '  AND  SUBSTR (( SELECT  password  FROM  users  LIMIT  0 , 1 ), 1 , 1 )  =  CAST ( X ' 54 '  as  Text )`
Если приложение отвечает перенаправлением 302, то мы нашли первый символ пароля. Чтобы получить весь пароль, 
злоумышленник должен ввести несколько тестов для каждого символа в пароле. Тестирование каждого отдельного символа 
утомительно и проще всего это сделать с помощью скрипта. Одним из простых решений является цикл по каждому 
возможному символу ASCII и сравнение его с символом базы данных. Упомянутый метод генерирует большой трафик к цели и 
не является самым эффективным методом. Пример скрипта предоставляется внутри машины и может быть просмотрен и 
загружен по адресу http://MACHINE_IP:5000/view/challenge3/challenge3-exploit.py ; обратите внимание, что необходимо 
будет изменить длину пароля с помощью переменной password_len. Длину пароля можно узнать, запросив базу данных. 
Например, в запросе ниже мы спрашиваем базу данных, равна ли длина пароля 37:       

admin '  И  длина (( ВЫБЕРИТЕ  пароль  из  пользователей, где имя пользователя= ' admin ' ))== 37 -- -
Кроме того, скрипт требует ненужного количества запросов. Дополнительной проблемой может стать создание более 
эффективного инструмента для извлечения пароля. 

Альтернативный способ решения этой проблемы — использование инструмента, такого как sqlmap, который является 
инструментом с открытым исходным кодом, автоматизирующим процесс обнаружения и эксплуатации уязвимостей SQL- 
инъекций. Для эксплуатации уязвимости с помощью sqlmap можно использовать следующую команду:  

$  sqlmap  -u http :// MACHINE_IP : 5000 / challenge3 / login  -- data = " имя пользователя = admin & пароль = admin " 
-- уровень = 5  -- риск = 3  -- СУБД = sqlite  -- метод = b  -- дамп

### Задача
Воспользуйтесь уязвимой формой входа и получите флаг.

### Ответить на вопросы ниже
Какой флаг у этого испытания?

```commandline
THM{f1f4e0757a09a0b87eeb2f33bca6a5cb}
```

## Задание 7

```commandline
Ответ не нужен
```

## Задание 8

```commandline
Ответ не нужен
```

## Задание 9

```commandline
Ответ не нужен
```

## Задание 10

```commandline
Ответ не нужен
```
[>> вернуться на главную страницу](https://github.com/BEPb/tryhackme/blob/master/README.md)