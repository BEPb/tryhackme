[>> вернуться на главную страницу](https://github.com/BEPb/tryhackme/blob/master/README.md)

# Комната [Windows x64 Assembly](https://tryhackme.com/r/room/win64assembly) 

Всего 10 заданий:
## Задание 1
Эта комната является частью серии комнат, которые познакомят вас с обратным проектированием программного обеспечения 
для Windows. В этой комнате будут обсуждаться основы обратного проектирования. В будущих комнатах мы начнем 
заниматься обратным проектированием и будем продвигаться по сложности и комплексности. Эта серия будет посвящена 
анализу исполняемых файлов, однако имейте в виду, что реверсирование — это обширная область, охватывающая не только 
двоичный анализ и не только программное обеспечение.

#### Что такое обратная разработка?
Обратное проектирование по сути означает получение результата и выяснение того, как он к нему пришел. Эти знания 
можно использовать для поиска уязвимостей в логике и методах, используемых для достижения результата. Все начинается 
с поиска того, что вы хотите атаковать, затем выяснения того, как это работает, и, наконец, выполнения с этим того, 
что вы хотите. Для исследователей безопасности цель обратного проектирования — найти, где разработчики допустили 
ошибку или поленились. Например, разработчики часто думают, что достаточно шифрования сетевого трафика, но обратные 
инженеры могут обойти это шифрование. Вот почему разработчикам не следует шифровать данные, которые их программное 
обеспечение отправляет на их серверы, а затем лениться очищать данные, когда они попадают на сервер.

#### Это долгий путь...
Стать опытным реверс-инженером — довольно долгий процесс. Будьте уверены, как только вы разовьете свои навыки, это 
будет довольно весело. Никто не может научить вас всему, что вам нужно знать об реверс-инжиниринге. Вы будете 
постоянно видеть что-то новое, и это будет вас сбивать с толку. Такова жизнь реверс-инженера. Для некоторых людей 
это действительно раздражает, но как реверс-инженеру вам часто приходится разбираться во всем самостоятельно. Вы 
будете постоянно искать, как что-то работает, а затем возиться с этим самостоятельно. Однако держите голову высоко, 
в конце концов, вы сможете начать использовать свои навыки для поиска уязвимостей, разработки эксплойтов, 
манипулирования процессами и делать кучу потрясающих вещей.

#### Почему это так сложно?
Компьютеры не должны быть дружелюбны к человеку, они созданы, чтобы быть быстрыми. Подумайте об ассемблере как об 
объединении компьютерных и человеческих языков; о чем-то, что компьютер может понимать и выполнять быстро, а также 
давать нам, людям, что-то для понимания (коды операций). Однако со временем это изменилось. Теперь мы почти 
исключительно пишем на языках высокого уровня, а компиляторы переводят это на компьютерный язык. Существует огромная 
разница между ассемблером, сгенерированным компилятором, и ассемблером, написанным человеком. Компиляторы используют 
всевозможные безумные методы, которые иногда даже не имеют смысла, но это для эффективности. Да, код высокого уровня 
изначально был написан человеком, но компилятор покончил с человеческой неэффективностью. Вот почему иногда может 
быть так сложно проводить обратную разработку программного обеспечения. С другой стороны, в конечном итоге вы 
начнете думать больше как компилятор, и это будет не так уж плохо. Вы даже можете развить способность наконец писать 
хороший код!

### Инструменты
Этот курс не будет зависеть от какого-либо одного инструмента, поэтому используйте то, что вам нужно. `x64dbg`, `Ghidra` 
и S`ysInternals` будут предоставлены на виртуальных машинах, используемых в будущих комнатах этой серии. 

Предварительные условия (знания и заметки):
- Концепции компьютерной науки
Вам не нужна степень, и некоторые концепции будут рассмотрены здесь. В конечном счете, именно ваше понимание того, как работают компьютеры и программное обеспечение, приведет вас к успеху или неудаче.
- Опыт работы с C/C++
Для обратного проектирования опыт важнее знания продвинутых техник C/C++. Продвинутые техники в любом случае почти всегда являются просто абстракциями нескольких более простых концепций.
- Сборка (рекомендуется)
Я расскажу об основах. Вам не нужно знать тонны ассемблера, но знание и удобство в нем сделают вас значительно лучше и быстрее. Я буду использовать синтаксис Intel, потому что я считаю его самым простым для чтения и он является синтаксисом по умолчанию для инструментов Windows. Обратите внимание, что при работе с Linux чаще используется AT&T.
#### Образ мышления. Эту часть можно пропустить.
Нужно понимать, что компьютеры чрезвычайно глупы. Они действуют на основе чистой логики и не делают никаких предположений.

Я попытаюсь продемонстрировать это с помощью простой «загадки» (правда, несложной).

Допустим, вы говорите компьютеру написать числа от 1 до 10 и сделать все четные числа красными.
Вот чего вы могли бы ожидать:

Выглядит правильно, все четные числа красные, как и ожидалось.
Компьютер также может генерировать следующее:

Еще раз, список действителен и соответствует правилам. Все четные числа красные.
Если вы запутались, не волнуйтесь, это значит, что вы прошли CAPTCHA. Мозг некоторых людей перевернет правило и скажет им, что все красные числа четные, что неверно, согласно тому, что мы сказали компьютеру. Компьютеры не перевернут правила или не будут применять какие-либо предположения, как это может сделать человек.

На самом деле правила ничего не говорят о нечетных числах, поэтому они могут быть любого цвета, который мы захотим!

«Куда делась 9?» — подумал программист. «Наверное, компьютер допустил ошибку и забыл написать 9. Может, я ошибся на единицу, классическая ошибка!» И маленький программист продолжает тратить часы своей жизни, в конце концов ударяясь головой о стол, когда понимает, что он был покрашен в белый цвет.
Что такое протокол?
TCP, UDP, HTTP(s), FTP и SMTP — это все протоколы. Протоколы — это просто шаблоны, которые используются для указания 
того, какие данные где находятся. Давайте рассмотрим пример. 

01011990ДжонДоу/0/123ГлавнаяСт

Без какого-либо руководства или шаблона это выглядит как просто беспорядок в данных. Наш мозг может выбрать 
некоторую информацию, например, имя и улицу. Но компьютеры не могут этого сделать, и даже мы не можем выбрать все 
данные. Это сбивает с толку, потому что все упаковано вместе в попытке сделать его как можно меньше. Вот, позвольте 
мне дать вам секретную формулу:   

ДЕНЬ РОЖДЕНИЯ(ММДДГГГГ)ИМЯ/Кол-воДетей/ДомашнийАдрес

Теперь все понятно. Набор цифр в начале — это день рождения. После дня рождения идет имя. Затем идет косая черта и 
количество детей. Затем еще одна косая черта и домашний адрес. Вот еще один пример: 

03141879АльбертЭйнштейн/3/112MercerSt

Вот что такое протокол. Это просто шаблон, который компьютеры могут использовать для того, чтобы разобрать на части 
ряд данных, которые в противном случае казались бы бессмысленными.

Я также хочу обратить внимание на разделители (косые черты), используемые для количества детей и улицы, на которой 
они живут. Поскольку некоторые данные имеют переменную длину, хорошей идеей будет различать их каким-то образом, 
помимо определенного количества символов. Помните, компьютер не может делать предположения. Нам нужно быть очень 
буквальными, иначе он не поймет, что мы имеем в виду. Правила для протокола следующие: если шаблон заполнен 
правильно, первые 8 символов представляют собой дату рождения. Символы, следующие за датой до косой черты, являются 
именем человека. Затем следующий символ(ы) после этой косой черты и до следующей косой черты — это количество детей 
у этого человека. Наконец, остальные данные после последней косой черты — это домашний адрес человека.       

### Ответьте на вопросы ниже
Теперь, когда вы познакомились с тем, как думают компьютеры, давайте перейдем к тому, как они работают.
```commandline
Ответ не нужен
```

## Задание 2
Системы счисления
Основание 10:
Мы, смертные люди, используем десятичную систему счисления (основание 10) .
Основание 10 включает 0, 1, 2, 3, 4, 5, 6, 7, 8, 9.
Вот 243 в основании 10:
243 = (10 2 * 2) + (10 1 * 4) + (10 0 * 3) = 200 + 40 + 3.

Если десятичная дробь обозначена, то она обычно имеет суффикс «d», например, 12d.

База 7:
Мы можем применить это к любой системе счисления. Например, 243 в системе счисления с основанием 7:
243(в системе счисления с основанием 7) = (7 2 * 2) + (7 1 * 4) + (7 0 * 3) = 98 + 28 + 3 = 129(в десятичной системе счисления).

Основание 7 включает в себя 0, 1, 2, 3, 4, 5, 6.
9 не входит в основание 7, так как же нам представить его в основании 7?
9 (в десятичной системе) = (7 1 * 1 ) + (7 0 * 2 ) = 7 + 2. Наш ответ будет 12 (основание 7) = 9 (основание 10).

Base2/Двоичный:
Что насчет основания 2? Основание 2 включает 0 и 1. Оно работает так же, как и другие. Вот несколько полезных значений, которые стоит знать:
2 10 = 1024, 2 9 = 512, 2 8 = 256, 2 7 = 128 и т. д.



Если вы хотите изучить двоичное преобразование и то, как оценивать различные основания, перейдите сюда:

https://www.khanacademy.org/math/algebra-home/alg-intro-to-algebra/algebra-alternate-number-bases/v/number-systems-introduction

Объяснить это текстом может быть немного сложно, но это видео описывает это очень хорошо.

Двоичный код обычно обозначается префиксом «0b», например 0b0110, а иногда суффиксом «b», например 110b.

Шестнадцатеричное:
Hexa = 6, Dec = 10. Шестнадцатеричная система имеет основание 16. Шестнадцатеричная система очень похожа, но может немного сбивать с толку некоторых людей. Видите ли, у нас есть только десять различных отдельных чисел (0, 1, 2, 3, 4, 5, 6, 7, 8, 9). Для шестнадцатеричной системы нужно 16 различных чисел. Вы можете использовать 0, 1... 11, 12, 13..., но это будет крайне запутанно. Например, что такое 1432? Это 1,4,3,2 или 14,3,2? Когда нам нужно представить что-либо больше 9, мы можем вместо этого использовать буквы, такие как A, B, C, D, E и F в случае шестнадцатеричной системы.

А = 10, Б = 11, ..., Ж = 15

Шестнадцатеричные числа обычно имеют префикс «0x» или суффикс «h», например 0xFF или FFh.

0x4A = (16 1 * 4d) + (16 0 * 10d) = 64d + 10d = 74d.

Узнайте больше о шестнадцатеричной системе здесь:

https://www.khanacademy.org/math/algebra-home/alg-intro-to-algebra/algebra-alternate-number-bases/v/hexexdecimal-number-system

Префиксы и суффиксы:
Чтобы различать разные системы счисления, мы используем префиксы или суффиксы. Существует много вещей, используемых для различения систем счисления, я покажу только самые распространенные.

Десятичная дробь представляется с суффиксом "d" или без него. Примеры: 12d или 12.
Шестнадцатеричное число представляется с  префиксом "0x" или суффиксом "h" . Примеры: 0x12 или 12h. Другой способ представления шестнадцатеричного числа — с префиксом "\x". Однако обычно это используется на байт. Две шестнадцатеричные цифры составляют один байт. Примеры: \x12 или \x12\x45\x21. Если биты и байты кажутся немного странными, мы скоро к ним вернемся, так что не волнуйтесь.
Двоичное число представляется с суффиксом "b" или с  добавлением нулей в начале . Примеры: 100101b или 00100101. Добавление нулей в начале часто используется, поскольку десятичное число не может начинаться с нуля.
### Ответьте на вопросы ниже
Что такое 0xA в десятичной системе?
```commandline
10
```
Что такое десятичное 25 в шестнадцатеричном? Включите префикс для шестнадцатеричного.
```commandline
0x19
```

## Задание 3
#### Биты и байты
Размеры типов данных различаются в зависимости от архитектуры. Это наиболее распространенные размеры, с которыми вы 
столкнетесь при работе с настольными Windows и Linux.

- Бит — это одна двоичная цифра . Может быть 0 или 1.
- Ниббл — это 4 бита .
- Байт — это 8 бит .
- Слово состоит из 2 байтов .
- Двойное слово (DWORD) — 4 байта . В два раза больше размера слова.
- Quad Word (QWORD) — 8 байт . В четыре раза больше размера слова.
Прежде чем перейти к другим типам данных, давайте поговорим о знаковых и беззнаковых числах. Знаковые числа могут 
  быть положительными или отрицательными. Беззнаковые числа могут быть только положительными. Названия происходят от 
  того, как они работают. Знаковым числам нужен бит знака, чтобы отличать, отрицательные они или нет, подобно тому, 
  как мы используем знаки + и -.

Тип данных Размеры
- Символ - 1 байт (8 бит).
- Int - Существуют 16-битные, 32-битные и 64-битные целые числа. Когда речь идет о целых числах, это обычно 32-битные.
  Для знаковых целых чисел один бит используется для указания того, является ли целое число положительным или отрицательным.
  - Подписано Int
    - 16 бит — это от -32 768 до 32 767.
    - 32 бита — это от -2 147 483 648 до 2 147 483 647.
    - 64-битный — от -9 223 372 036 854 775 808 до 9 223 372 036 854 775 807.
  - Unsigned Int — минимум равен нулю, максимум — в два раза больше, чем у знакового int (того же размера). 
  Например: беззнаковое 32-битное int принимает значения от 0 до 4 294 967 295. Это в два раза больше максимума знакового int, равного 2 147 483 647, однако его минимальное значение равно 0. Это связано с тем, что целые числа со знаком используют знаковый бит, что делает его недоступным для представления значения.
- Bool - 1 байт. Интересно, что bool нужен только 1 бит, потому что он может быть 1 или 0, но он все равно занимает 
  целый байт. Это потому, что компьютеры не склонны работать с отдельными битами из-за выравнивания (о котором мы поговорим позже). Поэтому вместо этого они работают с фрагментами, такими как 1 байт, 2 байта, 4 байта, 8 байтов и так далее.
    Для получения дополнительных типов данных перейдите по ссылке: https://www.tutorialspoint.com/cprogramming/c_data_types.htm

#### Офсеты
Позиции данных определяются тем, насколько далеко они находятся от адреса первого байта данных, известного как базовый адрес (или просто адрес) переменной. Расстояние, на котором находится фрагмент данных от своего базового адреса, считается смещением. Например, предположим, что у нас есть некоторые данные, 12345678. Просто для ясности предположим, что каждое число занимает 2 байта. С этой информацией 1 имеет смещение 0x0, 2 имеет смещение 0x2, 3 имеет смещение 0x4, 4 имеет смещение 0x6 и т. д. Вы можете ссылаться на эти значения с помощью формата BaseAddress+0x##. BaseAddress+0x0 или просто BaseAddress будет содержать 1, BaseAddress+0x2 будет содержать 2 и т. д.
### Ответьте на вопросы ниже
Сколько байт составляет СЛОВО?
```commandline
2
```
Сколько бит в СЛОВЕ?
```commandline
16
```

## Задание 4

```commandline
Ответ не нужен
```

## Задание 5

```commandline
Ответ не нужен
```

## Задание 6

```commandline
Ответ не нужен
```

## Задание 7

```commandline
Ответ не нужен
```

## Задание 8

```commandline
Ответ не нужен
```

## Задание 9

```commandline
Ответ не нужен
```

## Задание 10

```commandline
Ответ не нужен
```
[>> вернуться на главную страницу](https://github.com/BEPb/tryhackme/blob/master/README.md)