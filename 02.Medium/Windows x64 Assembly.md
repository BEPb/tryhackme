[>> вернуться на главную страницу](https://github.com/BEPb/tryhackme/blob/master/README.md)

# Комната [Windows x64 Assembly](https://tryhackme.com/r/room/win64assembly) 

Всего 10 заданий:
## Задание 1
Эта комната является частью серии комнат, которые познакомят вас с обратным проектированием программного обеспечения 
для Windows. В этой комнате будут обсуждаться основы обратного проектирования. В будущих комнатах мы начнем 
заниматься обратным проектированием и будем продвигаться по сложности и комплексности. Эта серия будет посвящена 
анализу исполняемых файлов, однако имейте в виду, что реверсирование — это обширная область, охватывающая не только 
двоичный анализ и не только программное обеспечение.

#### Что такое обратная разработка?
Обратное проектирование по сути означает получение результата и выяснение того, как он к нему пришел. Эти знания 
можно использовать для поиска уязвимостей в логике и методах, используемых для достижения результата. Все начинается 
с поиска того, что вы хотите атаковать, затем выяснения того, как это работает, и, наконец, выполнения с этим того, 
что вы хотите. Для исследователей безопасности цель обратного проектирования — найти, где разработчики допустили 
ошибку или поленились. Например, разработчики часто думают, что достаточно шифрования сетевого трафика, но обратные 
инженеры могут обойти это шифрование. Вот почему разработчикам не следует шифровать данные, которые их программное 
обеспечение отправляет на их серверы, а затем лениться очищать данные, когда они попадают на сервер.

#### Это долгий путь...
Стать опытным реверс-инженером — довольно долгий процесс. Будьте уверены, как только вы разовьете свои навыки, это 
будет довольно весело. Никто не может научить вас всему, что вам нужно знать об реверс-инжиниринге. Вы будете 
постоянно видеть что-то новое, и это будет вас сбивать с толку. Такова жизнь реверс-инженера. Для некоторых людей 
это действительно раздражает, но как реверс-инженеру вам часто приходится разбираться во всем самостоятельно. Вы 
будете постоянно искать, как что-то работает, а затем возиться с этим самостоятельно. Однако держите голову высоко, 
в конце концов, вы сможете начать использовать свои навыки для поиска уязвимостей, разработки эксплойтов, 
манипулирования процессами и делать кучу потрясающих вещей.

#### Почему это так сложно?
Компьютеры не должны быть дружелюбны к человеку, они созданы, чтобы быть быстрыми. Подумайте об ассемблере как об 
объединении компьютерных и человеческих языков; о чем-то, что компьютер может понимать и выполнять быстро, а также 
давать нам, людям, что-то для понимания (коды операций). Однако со временем это изменилось. Теперь мы почти 
исключительно пишем на языках высокого уровня, а компиляторы переводят это на компьютерный язык. Существует огромная 
разница между ассемблером, сгенерированным компилятором, и ассемблером, написанным человеком. Компиляторы используют 
всевозможные безумные методы, которые иногда даже не имеют смысла, но это для эффективности. Да, код высокого уровня 
изначально был написан человеком, но компилятор покончил с человеческой неэффективностью. Вот почему иногда может 
быть так сложно проводить обратную разработку программного обеспечения. С другой стороны, в конечном итоге вы 
начнете думать больше как компилятор, и это будет не так уж плохо. Вы даже можете развить способность наконец писать 
хороший код!

### Инструменты
Этот курс не будет зависеть от какого-либо одного инструмента, поэтому используйте то, что вам нужно. `x64dbg`, `Ghidra` 
и S`ysInternals` будут предоставлены на виртуальных машинах, используемых в будущих комнатах этой серии. 

Предварительные условия (знания и заметки):
- Концепции компьютерной науки
Вам не нужна степень, и некоторые концепции будут рассмотрены здесь. В конечном счете, именно ваше понимание того, как работают компьютеры и программное обеспечение, приведет вас к успеху или неудаче.
- Опыт работы с C/C++
Для обратного проектирования опыт важнее знания продвинутых техник C/C++. Продвинутые техники в любом случае почти всегда являются просто абстракциями нескольких более простых концепций.
- Сборка (рекомендуется)
Я расскажу об основах. Вам не нужно знать тонны ассемблера, но знание и удобство в нем сделают вас значительно лучше и быстрее. Я буду использовать синтаксис Intel, потому что я считаю его самым простым для чтения и он является синтаксисом по умолчанию для инструментов Windows. Обратите внимание, что при работе с Linux чаще используется AT&T.
#### Образ мышления. Эту часть можно пропустить.
Нужно понимать, что компьютеры чрезвычайно глупы. Они действуют на основе чистой логики и не делают никаких предположений.

Я попытаюсь продемонстрировать это с помощью простой «загадки» (правда, несложной).

Допустим, вы говорите компьютеру написать числа от 1 до 10 и сделать все четные числа красными.
Вот чего вы могли бы ожидать:

Выглядит правильно, все четные числа красные, как и ожидалось.
Компьютер также может генерировать следующее:

Еще раз, список действителен и соответствует правилам. Все четные числа красные.
Если вы запутались, не волнуйтесь, это значит, что вы прошли CAPTCHA. Мозг некоторых людей перевернет правило и скажет им, что все красные числа четные, что неверно, согласно тому, что мы сказали компьютеру. Компьютеры не перевернут правила или не будут применять какие-либо предположения, как это может сделать человек.

На самом деле правила ничего не говорят о нечетных числах, поэтому они могут быть любого цвета, который мы захотим!

«Куда делась 9?» — подумал программист. «Наверное, компьютер допустил ошибку и забыл написать 9. Может, я ошибся на единицу, классическая ошибка!» И маленький программист продолжает тратить часы своей жизни, в конце концов ударяясь головой о стол, когда понимает, что он был покрашен в белый цвет.
Что такое протокол?
TCP, UDP, HTTP(s), FTP и SMTP — это все протоколы. Протоколы — это просто шаблоны, которые используются для указания 
того, какие данные где находятся. Давайте рассмотрим пример. 

01011990ДжонДоу/0/123ГлавнаяСт

Без какого-либо руководства или шаблона это выглядит как просто беспорядок в данных. Наш мозг может выбрать 
некоторую информацию, например, имя и улицу. Но компьютеры не могут этого сделать, и даже мы не можем выбрать все 
данные. Это сбивает с толку, потому что все упаковано вместе в попытке сделать его как можно меньше. Вот, позвольте 
мне дать вам секретную формулу:   

ДЕНЬ РОЖДЕНИЯ(ММДДГГГГ)ИМЯ/Кол-воДетей/ДомашнийАдрес

Теперь все понятно. Набор цифр в начале — это день рождения. После дня рождения идет имя. Затем идет косая черта и 
количество детей. Затем еще одна косая черта и домашний адрес. Вот еще один пример: 

03141879АльбертЭйнштейн/3/112MercerSt

Вот что такое протокол. Это просто шаблон, который компьютеры могут использовать для того, чтобы разобрать на части 
ряд данных, которые в противном случае казались бы бессмысленными.

Я также хочу обратить внимание на разделители (косые черты), используемые для количества детей и улицы, на которой 
они живут. Поскольку некоторые данные имеют переменную длину, хорошей идеей будет различать их каким-то образом, 
помимо определенного количества символов. Помните, компьютер не может делать предположения. Нам нужно быть очень 
буквальными, иначе он не поймет, что мы имеем в виду. Правила для протокола следующие: если шаблон заполнен 
правильно, первые 8 символов представляют собой дату рождения. Символы, следующие за датой до косой черты, являются 
именем человека. Затем следующий символ(ы) после этой косой черты и до следующей косой черты — это количество детей 
у этого человека. Наконец, остальные данные после последней косой черты — это домашний адрес человека.       

### Ответьте на вопросы ниже
Теперь, когда вы познакомились с тем, как думают компьютеры, давайте перейдем к тому, как они работают.
```commandline
Ответ не нужен
```

## Задание 2
Системы счисления
Основание 10:
Мы, смертные люди, используем десятичную систему счисления (основание 10) .
Основание 10 включает 0, 1, 2, 3, 4, 5, 6, 7, 8, 9.
Вот 243 в основании 10:
243 = (10 2 * 2) + (10 1 * 4) + (10 0 * 3) = 200 + 40 + 3.

Если десятичная дробь обозначена, то она обычно имеет суффикс «d», например, 12d.

База 7:
Мы можем применить это к любой системе счисления. Например, 243 в системе счисления с основанием 7:
243(в системе счисления с основанием 7) = (7 2 * 2) + (7 1 * 4) + (7 0 * 3) = 98 + 28 + 3 = 129(в десятичной системе счисления).

Основание 7 включает в себя 0, 1, 2, 3, 4, 5, 6.
9 не входит в основание 7, так как же нам представить его в основании 7?
9 (в десятичной системе) = (7 1 * 1 ) + (7 0 * 2 ) = 7 + 2. Наш ответ будет 12 (основание 7) = 9 (основание 10).

Base2/Двоичный:
Что насчет основания 2? Основание 2 включает 0 и 1. Оно работает так же, как и другие. Вот несколько полезных значений, которые стоит знать:
2 10 = 1024, 2 9 = 512, 2 8 = 256, 2 7 = 128 и т. д.



Если вы хотите изучить двоичное преобразование и то, как оценивать различные основания, перейдите сюда:

https://www.khanacademy.org/math/algebra-home/alg-intro-to-algebra/algebra-alternate-number-bases/v/number-systems-introduction

Объяснить это текстом может быть немного сложно, но это видео описывает это очень хорошо.

Двоичный код обычно обозначается префиксом «0b», например 0b0110, а иногда суффиксом «b», например 110b.

Шестнадцатеричное:
Hexa = 6, Dec = 10. Шестнадцатеричная система имеет основание 16. Шестнадцатеричная система очень похожа, но может немного сбивать с толку некоторых людей. Видите ли, у нас есть только десять различных отдельных чисел (0, 1, 2, 3, 4, 5, 6, 7, 8, 9). Для шестнадцатеричной системы нужно 16 различных чисел. Вы можете использовать 0, 1... 11, 12, 13..., но это будет крайне запутанно. Например, что такое 1432? Это 1,4,3,2 или 14,3,2? Когда нам нужно представить что-либо больше 9, мы можем вместо этого использовать буквы, такие как A, B, C, D, E и F в случае шестнадцатеричной системы.

А = 10, Б = 11, ..., Ж = 15

Шестнадцатеричные числа обычно имеют префикс «0x» или суффикс «h», например 0xFF или FFh.

0x4A = (16 1 * 4d) + (16 0 * 10d) = 64d + 10d = 74d.

Узнайте больше о шестнадцатеричной системе здесь:

https://www.khanacademy.org/math/algebra-home/alg-intro-to-algebra/algebra-alternate-number-bases/v/hexexdecimal-number-system

Префиксы и суффиксы:
Чтобы различать разные системы счисления, мы используем префиксы или суффиксы. Существует много вещей, используемых для различения систем счисления, я покажу только самые распространенные.

Десятичная дробь представляется с суффиксом "d" или без него. Примеры: 12d или 12.
Шестнадцатеричное число представляется с  префиксом "0x" или суффиксом "h" . Примеры: 0x12 или 12h. Другой способ представления шестнадцатеричного числа — с префиксом "\x". Однако обычно это используется на байт. Две шестнадцатеричные цифры составляют один байт. Примеры: \x12 или \x12\x45\x21. Если биты и байты кажутся немного странными, мы скоро к ним вернемся, так что не волнуйтесь.
Двоичное число представляется с суффиксом "b" или с  добавлением нулей в начале . Примеры: 100101b или 00100101. Добавление нулей в начале часто используется, поскольку десятичное число не может начинаться с нуля.
### Ответьте на вопросы ниже
Что такое 0xA в десятичной системе?
```commandline
10
```
Что такое десятичное 25 в шестнадцатеричном? Включите префикс для шестнадцатеричного.
```commandline
0x19
```

## Задание 3
#### Биты и байты
Размеры типов данных различаются в зависимости от архитектуры. Это наиболее распространенные размеры, с которыми вы 
столкнетесь при работе с настольными Windows и Linux.

- Бит — это одна двоичная цифра . Может быть 0 или 1.
- Ниббл — это 4 бита .
- Байт — это 8 бит .
- Слово состоит из 2 байтов .
- Двойное слово (DWORD) — 4 байта . В два раза больше размера слова.
- Quad Word (QWORD) — 8 байт . В четыре раза больше размера слова.
Прежде чем перейти к другим типам данных, давайте поговорим о знаковых и беззнаковых числах. Знаковые числа могут 
  быть положительными или отрицательными. Беззнаковые числа могут быть только положительными. Названия происходят от 
  того, как они работают. Знаковым числам нужен бит знака, чтобы отличать, отрицательные они или нет, подобно тому, 
  как мы используем знаки + и -.

Тип данных Размеры
- Символ - 1 байт (8 бит).
- Int - Существуют 16-битные, 32-битные и 64-битные целые числа. Когда речь идет о целых числах, это обычно 32-битные.
  Для знаковых целых чисел один бит используется для указания того, является ли целое число положительным или отрицательным.
  - Подписано Int
    - 16 бит — это от -32 768 до 32 767.
    - 32 бита — это от -2 147 483 648 до 2 147 483 647.
    - 64-битный — от -9 223 372 036 854 775 808 до 9 223 372 036 854 775 807.
  - Unsigned Int — минимум равен нулю, максимум — в два раза больше, чем у знакового int (того же размера). 
  Например: беззнаковое 32-битное int принимает значения от 0 до 4 294 967 295. Это в два раза больше максимума знакового int, равного 2 147 483 647, однако его минимальное значение равно 0. Это связано с тем, что целые числа со знаком используют знаковый бит, что делает его недоступным для представления значения.
- Bool - 1 байт. Интересно, что bool нужен только 1 бит, потому что он может быть 1 или 0, но он все равно занимает 
  целый байт. Это потому, что компьютеры не склонны работать с отдельными битами из-за выравнивания (о котором мы поговорим позже). Поэтому вместо этого они работают с фрагментами, такими как 1 байт, 2 байта, 4 байта, 8 байтов и так далее.
    Для получения дополнительных типов данных перейдите по ссылке: https://www.tutorialspoint.com/cprogramming/c_data_types.htm

#### Офсеты
Позиции данных определяются тем, насколько далеко они находятся от адреса первого байта данных, известного как базовый адрес (или просто адрес) переменной. Расстояние, на котором находится фрагмент данных от своего базового адреса, считается смещением. Например, предположим, что у нас есть некоторые данные, 12345678. Просто для ясности предположим, что каждое число занимает 2 байта. С этой информацией 1 имеет смещение 0x0, 2 имеет смещение 0x2, 3 имеет смещение 0x4, 4 имеет смещение 0x6 и т. д. Вы можете ссылаться на эти значения с помощью формата BaseAddress+0x##. BaseAddress+0x0 или просто BaseAddress будет содержать 1, BaseAddress+0x2 будет содержать 2 и т. д.
### Ответьте на вопросы ниже
Сколько байт составляет СЛОВО?
```commandline
2
```
Сколько бит в СЛОВЕ?
```commandline
16
```

## Задание 4
Это будет кратким введением в то, как манипулируется двоичный код и как выполняются основные математические операции 
в двоичном коде. Давайте начнем с изучения того, что означают true и false для компьютера, затем мы поговорим о 
четырех фундаментальных операциях: NOT , AND , OR и XOR .

#### Правда/Ложь

В вычислениях false представляется значением 0, а true представляется как что угодно, кроме 0. Вот почему в двоичном 
коде true равно 1, а false равно 0. При программировании true может быть 1, 100, адресом памяти или символом. Опять 
же, true — это что угодно, кроме 0.

#### НЕ (отображается как «!»)
Операция НЕ просто инвертирует бит.

НЕ 1 = 0
НЕ 0 = 1


#### И (отображается как "&")

AND проверит, равны ли оба бита 1, и если да, то результатом будет 1, в противном случае результатом будет 0.

1 И 1 = 1
1 И 0 = 0
0 И 0 = 0


##### ИЛИ (отображается как «|»)

OR проверит, равен ли один из битов единице, и если да, то результат будет 1, в противном случае результат будет 0.

1 ИЛИ 1 = 1
1 ИЛИ 0 = 1
0 ИЛИ 0 = 0


#### XOR (отображается как «^»)

Результат равен 1, если хотя бы один из битов равен единице, но не оба одновременно, в противном случае результат 
равен 0. Другой способ представить себе операцию XOR — это проверка битов на различие.

1 XOR 1 = 0
1 XOR 0 = 1
0 XOR 0 = 0




Существуют обратные этим операциям операции, такие как NAND и NOR. Эти операции выполняют соответствующую первичную 
операцию, а затем выполняют NOT в конце. Например, NAND выполняет операцию AND, за которой следует операция NOT над 
результатом операции AND.

### Ответьте на вопросы ниже
Каков результат двоичной операции: 1011 И 1100?

```commandline
1000
```
Каков результат двоичной операции: 1011 NAND 1100? Включая ведущие нули.
```commandline
0111
```

## Задание 5
Примечание:  Существует два различных синтаксиса для ассемблера: Intel и AT&T. Мы сосредоточимся на Intel, потому 
что я думаю, что он самый простой для чтения и является стандартным для инструментов Windows. Обратите внимание, что 
при работе с Linux чаще используется AT&T.

#### Регистры
В зависимости от того, работаете ли вы с 64-битной или 32-битной сборкой, все может немного отличаться. Как уже 
упоминалось, этот курс фокусируется на 64-битной Windows.

#### Что такое Ассамблея?
Конечной целью компилятора является перевод высокоуровневого кода на язык, понятный ЦП. Этот язык — ассемблер. ЦП 
поддерживает различные инструкции, которые работают вместе, выполняя такие действия, как перемещение данных, 
выполнение сравнений, выполнение действий на основе сравнений, изменение значений и все остальное, что вы можете 
себе представить. Хотя у нас может не быть высокоуровневого исходного кода для какой-либо программы, мы можем 
получить ассемблерный код из исполняемого файла.

Сборка VS C:
Небольшой пример:
```commandline
if(x == 4){
    func1();
}else{
    return;
}
```

функционально аналогичен следующей псевдосборке:
```commandline
mov RAX, x
cmp RAX, 4
jne 5       ; Line 5 (ret)
call func1
ret
```

Это должно быть довольно понятно, но я кратко расскажу об этом. Сначала переменная x перемещается в RAX. RAX — это 
регистр, представьте его как переменную в ассемблере. Затем мы сравниваем это с 4. Если сравнение между RAX (4) и 5 
приводит к тому, что они не равны, то переходим (jne) на строку 5, которая возвращает. В противном случае они 
равны, поэтому вызываем func1().

#### Регистры
Давайте поговорим о регистрах общего назначения (GPR). Вы можете думать о них как о переменных, потому что по сути 
они ими и являются. У ЦП есть собственное хранилище, которое работает очень быстро. Это здорово, однако пространство 
в ЦП крайне ограничено. Любые данные, которые слишком велики для размещения в регистре, хранятся в памяти (ОЗУ). 
Доступ к памяти для ЦП намного медленнее, чем доступ к регистру. Из-за низкой скорости ЦП пытается поместить данные 
в регистры вместо памяти, если это возможно. Если данные слишком велики для размещения в регистре, регистр будет 
содержать указатель на данные, чтобы к ним можно было получить доступ.

#### Существует 8 основных регистров общего назначения:
Существует несколько GPR, каждый из которых имеет свою задачу. Однако эта задача скорее шаблонная, поскольку 
регистры обычно используются для чего угодно, за исключением нескольких. Независимо от этого, хорошо знать их 
назначенную цель, когда они используются в соответствии с их назначением.

- RAX — Известен как регистр-аккумулятор. Часто используется для хранения возвращаемого значения функции.
- RBX - Иногда называется базовым регистром, не путать с базовым указателем. Иногда используется как базовый 
  указатель для доступа к памяти.
- RDX — иногда его называют регистром данных.
- RCX - Иногда называется регистром счетчика. Используется как счетчик цикла.
- RSI — Известен как исходный индекс. Используется как исходный указатель в строковых операциях.
- RDI — известен как индекс назначения. Используется как указатель назначения в строковых операциях.
- RSP — указатель стека. Содержит адрес вершины стека.
- RBP — Базовый указатель. Содержит адрес базы (дна) стека.
Все эти регистры используются для хранения данных. Сразу следует отметить, что эти регистры можно использовать для 
  чего угодно. Опять же, их «использование» — это просто обычная практика. Например, RAX часто используется для 
  хранения возвращаемого значения функции, но это не обязательно (и часто не так). Однако представьте, что вы пишете 
  программу на ассемблере. Было бы крайне полезно знать, куда отправляется возвращаемое значение функции, иначе 
  зачем вызывать функцию? Также посмотрите на пример на ассемблере, который я привел ранее. Он использует RAX для 
  хранения переменной x.

С учетом сказанного, некоторые регистры лучше оставить в покое при работе с типичными данными. Например, RSP и RBP 
почти всегда следует использовать только для того, для чего они были разработаны. Они хранят местоположение текущего 
кадра стека (скоро мы перейдем к стеку), что очень важно. Если вы используете RBP или RSP, вам нужно будет сохранить 
их значения, чтобы вы могли восстановить их в исходное состояние, когда закончите. По мере продвижения вы поймете 
важность различных регистров на разных этапах выполнения.

#### Указатель инструкций
RIP, вероятно, самый важный регистр. RIP — это «указатель инструкций». Это адрес следующей строки кода, которая 
должна быть выполнена. Вы не можете напрямую записывать в этот регистр, только определенные инструкции, такие как 
ret, могут влиять на указатель инструкций.

#### Регистрация поломок
Каждый регистр можно разбить на более мелкие сегменты, на которые можно ссылаться с помощью других имен регистров. 
RAX — это 64 бита, на нижние 32 бита можно ссылаться с помощью EAX, а на нижние 16 бит можно ссылаться с помощью AX. 
AX разбит на две 8-битные части. На верхние/верхние 8 бит AX можно ссылаться с помощью AH. На нижние 8 бит можно 
ссылаться с помощью AL.

RAX состоит из всех 8 байтов, которые будут байтами 0-7. EAX состоит из байтов 4-7, AX состоит из байтов 6-7, AH 
состоит только из байта 6, а AL состоит только из байта 7 (последний байт).

Если 0x0123456789ABCDEFбыл загружен в 64-битный регистр, такой как RAX, то RAX относится к 0x0123456789ABCDEF, EAX 
относится к 0x89ABCDEF, AX относится к 0xCDEF, AH относится к 0xCD, AL относится к 0xEF.

В чем разница между префиксами "E" и "R"? Помимо того, что один из них является 64-битным регистром, а другой — 
32-битным, "E" означает extended. "R" означает register. Регистры "R" были недавно введены в x64, и нет, вы не 
увидите их в 32-битных системах.

Чтобы увидеть, как разделены все регистры, перейдите по ссылке:
https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/x64-architecture

#### Различные типы данных
- Значения с плавающей точкой — числа с плавающей точкой и двойной точностью.
- Целочисленные значения — целые числа, логические значения, символы, указатели и т. д.

Различные типы данных не могут быть помещены в любой регистр. Значения с плавающей точкой представлены иначе, чем 
целые числа. Из-за этого значения с плавающей точкой имеют специальные регистры. Эти регистры включают YMM0 - YMM15 
(64-битные) и XMM0 - XMM15 (32-битные). Регистры XMM являются нижней половиной регистров YMM, аналогично тому, как 
EAX является нижними 32 битами RAX. Уникальность этих регистров заключается в том, что их можно рассматривать как 
массивы. Другими словами, они могут содержать несколько значений. Например, регистры YMM# имеют ширину 256 бит 
каждый и могут содержать 4 64-битных значения или 8 32-битных значений. Аналогично, регистры XMM# имеют ширину 128 
бит и могут содержать 2 64-битных значения или 4 32-битных значения. Для использования этих регистров в качестве 
векторов необходимы специальные инструкции.

Подробную таблицу этих регистров и более подробную информацию о них можно найти здесь: https://en.wikipedia.org/wiki/Advanced_Vector_Extensions

#### Дополнительные регистры
Есть дополнительные регистры, которые следует упомянуть. Эти регистры не имеют специального применения. Есть 
регистры r8 - r15 , которые предназначены для использования целочисленными значениями (не числами с плавающей точкой 
или числами двойной точности). Доступ к нижним 4 байтам (32 бита), 2 байтам (16 бит) и 8 битам (1 байт) возможен. К 
ним можно получить доступ, добавив букву "d", "w" или "b".

Примеры:

- R8 — полный 64-битный (8 байт) регистр.
- R8D — Младшее двойное слово (4 байта).
- R8W - Младшее слово (2 байта)
- R8B — Младший байт.
#### Ответьте на вопросы ниже
Сколько байт занимает RAX?
```commandline
8
```
Сколько байт занимает EAX?
```commandline
4
```

## Задание 6
Примечание: Существует два различных синтаксиса для ассемблера: Intel и AT&T. Мы сосредоточимся на Intel, потому 
что я думаю, что он самый простой для чтения и является стандартным для инструментов Windows. Обратите внимание, что 
при работе с Linux чаще используется AT&T.

Инструкции
Умение читать и понимать ассемблерный код жизненно важно для обратного проектирования. Существует около 1500 
инструкций, однако большинство из них не используются повсеместно или являются просто вариациями (например, MOV и 
MOVS). Как и в высокоуровневом программировании, не стесняйтесь искать то, чего вы не знаете.

Прежде чем начать, вам следует знать три различных термина: немедленный, регистр и память.

Непосредственное значение (или просто немедленное, иногда IM) — это что-то вроде числа 12. Непосредственное значение 
— это не адрес памяти или регистр, а некий вид постоянных данных.

Регистр — это что-то вроде RAX, RBX, R12, AL и т. д.

Память или адрес памяти относится к местоположению в памяти (адресу памяти), например 0x7FFF842B.

Вы можете увидеть точку с запятой в конце или между несколькими инструкциями ассемблера. Это потому, что точка с 
запятой (;) используется для записи комментария в ассемблере.

Важно знать формат инструкций, который выглядит следующим образом:

(Инструкция/Опкод/Мнемоника) <Операнд назначения>, <Операнд источника>

Я буду называть инструкции/коды операций/мнемоники инструкциями, просто учтите, что некоторые люди называют их 
по-разному.

Пример:

mov RAX, 5
MOV — инструкция, RAX — операнд назначения, а 5 — операнд источника. Регистр инструкций или операндов не имеет 
значения. Вы увидите, что я использую смесь всех заглавных и всех строчных букв. В приведенном примере 5 — это 
непосредственное значение, поскольку это недопустимый адрес памяти и, конечно же, не регистр.

### Общие инструкции
#### Перемещение данных
MOV используется для перемещения/сохранения исходного операнда в место назначения. Источник не обязательно должен 
быть непосредственным значением, как в следующем примере. В следующем примере непосредственное значение 5 
перемещается в RAX.

Это эквивалентно RAX = 5.
`mov RAX, 5`

**LEA** — это сокращение от Load Effective Address. По сути, это то же самое, что и MOV, за исключением адресов. 
Ключевое различие между MOV и LEA заключается в том, что LEA не разыменовывается. Он также обычно используется для 
вычисления адресов. В следующем примере RAX будет содержать адрес/расположение памяти num1.
```commandline
lea RAX, num1
lea RAX, [struct+8]
mov RBX, 5
lea RAX, [RBX+1]
```

В первом примере RAX устанавливается на адрес num1. Во втором примере RAX устанавливается на адрес члена в структуре,
который находится на 8 байт от начала структуры. Обычно это второй член. В третьем примере RBX устанавливается на 5, 
затем LEA используется для установки RAX на RBX + 1. RAX будет равен 6.

**PUSH** используется для помещения данных в стек. Проталкивание означает помещение чего-либо на вершину стека. В 
следующем примере RAX помещается в стек. Проталкивание будет действовать как копия, поэтому RAX все еще будет 
содержать значение, которое у него было до помещения в стек. Проталкивание часто используется для сохранения данных 
внутри регистра путем помещения их в стек, а затем последующего восстановления с помощью `pop`.

`push RAX`

**POP** используется для того, чтобы взять все, что находится на вершине стека, и сохранить это в месте назначения. 
В следующем примере все, что находится на вершине стека, будет помещено в RAX.

`pop RAX`

Арифметика:
**INC** увеличит данные на единицу. В следующем примере RAX устанавливается на 8, а затем увеличивается. К концу RAX 
будет равен 9. 
```commandline
mov RAX, 8
inc RAX
```

**DEC** уменьшает значение. В следующем примере RAX заканчивается значением 7.
```commandline
mov RAX, 8
dec RAX
```

**ADD** добавляет источник к месту назначения и сохраняет результат в месте назначения. В следующем примере 2 
перемещается в RAX, 3 — в RBX, затем они складываются. Затем результат (5) сохраняется в RAX.

То же, что RAX = RAX + RBX или RAX += RBX.
```commandline
mov RAX, 2
mov RBX, 3
add RAX, RBX
```

**SUB** вычитает источник из назначения и сохраняет результат в назначении. В следующем примере RAX завершится значением 2.
То же, что RAX = RAX - RBX или RAX -= RBX.
```commandline
mov RAX, 5
mov RBX, 3
sub RAX, RBX
```

#### Умножение и деление немного отличаются.
Поскольку размеры данных могут различаться и сильно изменяться при умножении и делении, они используют конкатенацию 
двух регистров для хранения результата. Верхняя половина результата сохраняется в RDX, а нижняя половина — в RAX. 
Общий результат операции — RDX:RAX, однако ссылки только на RAX обычно достаточно. Кроме того, инструкции 
присваивается только один операнд. Все, что вы хотите умножить или разделить, хранится в RAX, а то, на что вы хотите 
умножить или разделить, передается в качестве операнда. Примеры приведены в следующих описаниях.
**MUL** (без знака) или **IMUL** (со знаком) умножает RAX на операнд. Результат сохраняется в RDX:RAX. В следующем примере 
RDX:RAX завершится значением 125.

Следующее то же самое, что и 25*5
```commandline
mov RAX, 25
mov RBX, 5
mul RBX ; Multiplies RAX (25) with RBX (5)
```

После выполнения этого кода результат сохраняется в RDX:RAX, но в этом случае, как и в большинстве случаев, RAX достаточно.
**DIV** (без знака) и **IDIV** (без знака) работают так же, как MUL. То, что вы хотите разделить (делимое), хранится 
в RAX, а то, на что вы хотите его разделить (делитель), передается как операнд. Результат хранится в RDX:RAX, но, 
опять же, одного RAX обычно достаточно.
```commandline
mov RAX, 18
mov RBX, 3
div RBX ; Divides RAX (18) by RBX (3)
```
После выполнения этого кода RAX будет равен 6.

#### Управление потоком:
**RET**  — это сокращение от return. Это вернет выполнение функции, которая вызвала текущую выполняемую функцию, то есть 
вызывающую. Как вы скоро узнаете, одна из целей RAX — хранить возвращаемые значения.  Следующий пример устанавливает 
RAX в 10, а затем возвращает. Это эквивалентно  в return 10; языках программирования более высокого уровня.

`mov RAX, 10 ret`

**CMP** сравнивает два операнда и устанавливает соответствующие флаги в зависимости от результата. Следующий код 
установит флаг нуля (ZF) на 1, что означает, что сравнение определило, что RAX равен пяти. Флаги обсуждаются в 
следующем разделе. Короче говоря, флаги используются для представления результата сравнения, например, равны ли два 
числа или нет.
```commandline
mov RAX, 5
cmp RAX, 5
```
Инструкции **JCC** — это условные переходы, которые осуществляются на основе установленных в данный момент флагов. JCC — 
это не инструкция, а скорее термин, используемый для обозначения набора инструкций, включающего JNE, JLE, JNZ и 
многие другие. Инструкции JCC обычно не требуют пояснений для прочтения. JNE выполняет переход, если сравнение не 
равно, а JLE выполняет переход, если меньше или равно, JG выполняет переход, если больше и т. д. Это ассемблерная 
версия операторов if.

Следующий пример вернет значение, если RAX не равен 5. Если он равен 5, то RBX будет установлен в 10, а затем будет 
выполнен возврат.
```commandline
mov RAX, 5
cmp RAX, 5
jne 5 ; Jump to line 5 (ret) if not equal.
mov RBX, 10
ret
```

**NOP** — это сокращение от No Operation (Нет операции). Эта инструкция фактически ничего не делает. Обычно она 
используется для заполнения, поскольку некоторые части кода любят находиться на определенных границах, например, 
16-битных или 32-битных границах.

Вернуться к примеру
Помните пример из 3.1? Вот он:
```commandline
if(x == 4){
    func1();
}
else{
    return;
}
```
то же самое, что и
```commandline
mov RAX, x
cmp RAX, 4
jne 5 ; Line 5 (ret)
call func1
ret
```

Надеюсь, теперь вы можете самостоятельно разобраться с версией сборки. Она перемещает переменную x в RAX, затем 
сравнивает ее x с 4. Если они не равны, то возвращается, если равны, то вызывается "func1".

#### Выхожу из себя
Помните, что компилятор — это прежде всего эффективность? Позвольте мне показать вам, как думает компилятор, 
поскольку вы будете видеть это постоянно.

Вместо того, что обычно пишет программист:
```commandline
if(x == 4){
    func1();
}
else{
    return;
}
```

Компилятор сгенерирует что-то похожее на:
```commandline
if(x != 4){
    goto __exit;
}
func1();
__exit:
return;
```

Компилятор генерирует код таким образом, потому что это почти всегда более эффективно и пропускает больше кода. 
Приведенные выше примеры могут не иметь большого улучшения производительности по сравнению друг с другом, однако в 
более крупных программах улучшение может быть весьма значительным.

#### Указатели
У ассемблера есть свои способы работы с указателями и адресами памяти, как и у C/C++. В C/C++ можно использовать 
разыменование, чтобы получить значение внутри адреса памяти. Например:
```commandline
int main(){
    int num = 10;
    int* ptr = &num
    return (*ptr + 5);
}
```

ptr является указателем на num, что означает, ptr что содержит адрес памяти num.
Затем верните сумму того, что находится по адресу внутри ptr( num то есть 10) и 5.

Две самые важные вещи, которые следует знать при работе с указателями и адресами в Ассемблере, — это LEA и 
квадратные скобки.

Квадратные скобки - квадратные скобки разыменовываются в ассемблере. Например, [var] это адрес, на который указывает 
var. Другими словами, при использовании [var] мы хотим получить доступ к адресу памяти, который var хранится.

**LEA** — игнорируйте все, что касается квадратных скобок при работе с LEA. LEA — это сокращение от Load Effective 
Address (эффективный адрес загрузки), и он используется для расчета и загрузки адресов.

Важно отметить, что при работе с инструкцией LEA квадратные скобки не разыменовываются.

LEA используется для загрузки и вычисления адресов, а НЕ данных. Неважно, есть ли там квадратные скобки или нет, он 
имеет дело ТОЛЬКО с адресами. LEA — это инструкция, которая будет мутить вам мозги, когда вы не выспитесь.

Вот простой пример разыменования и указателя на ассемблере:
```commandline
lea RAX, [var]
mov [RAX], 12
```

В приведенном выше примере адрес var загружается в RAX. Это LEA, с которым мы работаем, разыменования нет. RAX 
теперь действует как указатель, поскольку он хранит адрес переменной. Затем 12 перемещается в адрес, на который 
указывает RAX). Адрес, на который указывает RAX, является переменной var. Если бы эта сборка была выполнена, var было 
бы 12. Это все равно, что сделать mov var, 12.

Возвращаясь к примеру кода, с которого мы начали говорить об указателях, вот он в псевдоассемблере:
```commandline
mov num, 10
lea ptr, [num]
mov rax, [ptr]
add rax, 5
ret
```
Переместить 10 в num

Загрузить адрес num в ptr

Переместите данные, которые находятся по адресу внутри ptr (num который равен 10), в rax.

Добавьте ракс (10) и 5.

**RET** - Это вернет данные внутри RAX. Это объясняется позже в соглашениях о вызовах.

Ранее я говорил, что LEA можно использовать для расчета адресов, и часто так и происходит. Вот пример.
```commandline
lea RAX, [RCX+8] ;This will add 8 to the address inside RCX, and set RAX to the resulting address.
mov RAX, [RCX+8] ;This will add 8 to the address already held by RCX, then dereference the new address and put whatever is at that address into RAX.
```
Еще раз:

Важно отметить, что при работе с LEA квадратные скобки не разыменовываются.

Вы будете постоянно видеть использование LEA и MOV, поэтому убедитесь, что вы понимаете это, и обратите внимание на 
детали.

#### Нулевое расширение
Нулевое расширение устанавливает остальные оставшиеся биты в регистре в ноль при изменении других битов. Например, 
если вы переместили значение в EAX, должны ли измениться верхние 32 бита RAX?

В общем случае, перемещение в нижние 32 бита RAX через EAX обнулит /расширит верхние 32 бита. Перемещение в что-либо 
меньшее не обнулит расширение. Поэтому перемещение чего-либо в AX не обнулит остаток RAX. Если вы хотите расширить 
нулём несмотря ни на что, используйте, movzx который выполняет расширение нулем несмотря ни на что.

#### Мейсон из JMP, что они имеют в виду?!
Давайте поговорим о разнице между такими инструкциями, как jg(перейти, если больше) и ja(перейти, если выше). Знание 
разницы может помочь вам отсеять эти сложные для понимания типы данных. Существуют и другие инструкции, подобные 
этой, поэтому обязательно смотрите, что они делают, когда сталкиваетесь с ними. Например, существует несколько 
вариантов mov.

Вот краткое изложение инструкций по переходу, когда дело касается знаковых или незнаковых. Игнорируйте «CF» и «ZF», 
если вы не знаете, что они означают, я включил их для справки после того, как вы поймете флаги (рассмотренные далее).

Для беззнаковых сравнений:
- JB/JNAE (CF = 1); Перейти, если ниже/не выше или равно
- JAE/JNB (CF = 0); Переход, если выше или равно/не ниже
- JBE/JNA (CF = 1 или ZF = 1); Переход, если ниже или равно/не выше
- JA/JNBE (CF = 0 и ZF = 0); Переход, если выше/не ниже или равно

Для знаковых сравнений:
- JL/JNGE (SF <> OF) ; Переход, если меньше/не больше или равно
- JGE/JNL (SF = OF); Переход, если больше или равно/не меньше
- JLE/JNG (ZF = 1 или SF <> OF); Переход, если меньше или равно/не больше
- JG/JNLE (ZF = 0 и SF = OF); Переход, если больше/не меньше или равно

Простой способ запомнить это, и как я это помню:

Люди обычно работают со знаковыми числами, и мы обычно говорим больше или меньше. Вот как, я помню, знак идет с 
переходами больше и меньше.

Заключительное замечание
Есть еще много инструкций по сборке, которые я не охватил. По мере того, как мы продолжим, я буду представлять 
больше инструкций по мере их поступления. Не бойтесь искать инструкции, потому что, как я уже сказал, их довольно 
много (сотни или тысячи).

### Ответьте на вопросы ниже
Какую инструкцию возвращает функция?
```commandline
ret
```
Какая инструкция вызовет/выполнит функцию?
```commandline
call
```
Какую инструкцию можно использовать для сохранения регистра таким образом, чтобы его можно было впоследствии 
восстановить?
```commandline
PUSH
```

## Задание 7
#### Флаги
Флаги используются для обозначения результата ранее выполненной операции или сравнения. Например, если два числа 
сравниваются друг с другом, флаги будут отражать результаты, например, их четность. Флаги содержатся в регистре, 
который называется EFLAGS (x86) или RFLAGS (x64). Я обычно называю его просто регистром флагов. Существует 
фактический регистр FLAGS, который является 16-битным, но семантика — просто пустая трата времени. Если вы хотите 
вникнуть в эту тему, поищите, в Википедии есть хорошая статья об этом. Я расскажу вам, что вам нужно знать.

#### Флаги статуса
Вот флаги, которые вам следует знать. Обратите внимание, что когда я говорю «флаг установлен», я имею в виду, что 
флаг установлен на 1, что является истинным/включенным. 0 — ложным/выключенным.

- Флаг нуля (ZF) — устанавливается, если результат операции равен нулю. Не устанавливается, если результат операции 
не равен нулю.
- Флаг переноса (CF) — устанавливается, если последняя беззнаковая арифметическая операция перенесла (сложение) или 
  заимствовала (вычитание) немного за пределы регистра. Он также устанавливается, когда операция была бы отрицательной, если бы она не была беззнаковой.
- Флаг переполнения (OF) — устанавливается, если знаковая арифметическая операция слишком велика для регистра.
- Флаг знака (SF) — устанавливается, если результат операции отрицательный.
- Флаг настройки/дополнительный (AF) — то же, что и флаг переноса, но для операций с двоично-десятичным кодом (BCD).
- Флаг четности (PF) — устанавливается в 1, если число битов, установленных в последних 8 битах, четное. (10110100, 
  PF=1; 10110101, PF=0)
- Флаг ловушки (TF) — позволяет выполнять программы пошагово.
Полный список флагов смотрите здесь: https://www.tech-recipes.com/rx/1239/assembly-flags/

Примеры
Базовое сравнение
Вот несколько примеров, демонстрирующих установку флагов.

Вот первый пример. Следующий код пытается определить, равен ли RAX 4. Поскольку мы проверяем на равенство, ZF будет 
самым важным флагом.
В строке 2 есть инструкция CMP, которая будет проверять равенство между RAX и числом 4. CMP работает путем вычитания 
двух значений. Поэтому при cmp RAX, 4 запуске 4 вычитается из RAX (тоже 4). Вот почему сравнение дает ноль, потому 
что процесс вычитания буквально дает ноль. Поскольку результат равен нулю, флаг ZF устанавливается в 1 (on/true), 
чтобы обозначить, что операция дала значение 0, что также означает, что значения были равны! Это приводит нас к JNE, 
который переходит, если не равен/ноль. Поскольку ZF установлен, он не перейдет, так как они равны, и поэтому 
выполняется вызов func1(). Если бы они не были равны, был бы выполнен переход, который перепрыгнул бы через вызов 
функции прямо к возврату.
```commandline
mov RAX, 4
cmp RAX, 4
jne 5       ; Line 5 (ret)
call func1
ret
; ZF = 1, OF = 0, SF = 0
```
Вычитание
Следующий пример демонстрирует знаковую операцию. SF будет установлен в 1, поскольку операция вычитания дает 
отрицательное число. Использование инструкции cmp вместо sub даст тот же результат, за исключением того, что значение 
операции (-6) не будет сохранено ни в одном регистре.
```commandline
mov RAX, 2
sub RAX, 8  ; 2 - 8 = -6.
; ZF = 0, OF = 0, SF = 1
```
Добавление
Ниже приведен пример, в котором результат слишком велик для размещения в регистре. Здесь я использую 8-битные 
регистры, чтобы мы могли работать с небольшими числами. Наибольшее число, которое может поместиться в 8-битный 
регистр со знаком, — 128. В AL загружается 75, затем к нему добавляется 60. Результат сложения этих двух чисел 
должен дать 135, что превышает максимум. Из-за этого число циклически возвращается к нулю, и AL будет равно -121. 
Это устанавливает OF, поскольку результат слишком велик для регистра, и устанавливается флаг SF, поскольку результат 
отрицательный. Если бы это была беззнаковая операция, был бы установлен CF.
```commandline
mov AL, 75
add AL, 60
; ZF = 0, OF = 1, SF = 1
```
Заключительное замечание
Надеюсь, это даст вам хорошее представление о том, что такое флаги и как они работают. Помните, что CMP будет 
устанавливать флаги в зависимости от результата сравнения. Условные переходы будут просто смотреть на флаги. Это 
говорит нам о том, что условный переход не обязательно должен быть немедленно выполнен с помощью CMP, чтобы 
сработать. Кроме того, флаги устанавливаются вещами, отличными от инструкций CMP.

### Ответьте на вопросы ниже
Если сравнить два равных значения, какое значение будет установлено в ZF в результате сравнения?
```commandline
1
```

## Задание 8
Соглашение о вызовах Windows x64
Существует много соглашений о вызовах, я подробно расскажу о том, которое используется в x64 Windows. Как только вы 
поймете одно, вы сможете очень легко понять и другие, это просто вопрос запоминания, что есть что (если вы захотите).

Прежде чем начать, помните, что здесь очень важно внимание к деталям.

При вызове функции вы теоретически можете передавать параметры через регистры, стек или даже на диск. Вам просто 
нужно быть уверенным, что вызываемая вами функция знает, куда вы помещаете параметры. Это не такая уж большая 
проблема, если вы используете собственные функции, но все станет запутанным, когда вы начнете использовать 
библиотеки. Для решения этой проблемы у нас есть соглашения о вызовах, которые определяют, как параметры передаются 
в функцию, кто выделяет место для переменных и кто очищает стек.

Вызываемая функция относится к вызываемой функции, а вызывающая — к функции, осуществляющей вызов.

Существует несколько различных соглашений о вызовах, включая cdecl, syscall, stdcall, fastcall и другие. Поскольку я 
решил сосредоточиться на x64 Windows для простоты, мы будем работать с x64 fastcall. Если вы планируете выполнять 
обратную разработку на других платформах, обязательно изучите их соответствующие соглашения о вызовах.

Иногда вы увидите префикс с двойным подчеркиванием перед именем соглашения о вызове. Например: __fastcall. Я не 
буду этого делать, потому что это раздражает при наборе.

#### Быстрый вызов
**Fastcall** — это соглашение о вызовах для x64 Windows. Windows по умолчанию использует соглашение о вызовах 
fastcall с четырьмя регистрами. Краткая информация: когда речь идет о соглашениях о вызовах, вы услышите о чем-то, 
называемом «Application Binary Interface» (ABI). ABI определяет различные правила для программ, такие как соглашения 
о вызовах, обработка параметров и многое другое.

Как работает соглашение о вызовах x64 Windows?
- Первые четыре параметра передаются в регистрах СЛЕВА НАПРАВО. Параметры, которые не являются значениями с плавающей 
точкой, такие как целые числа, указатели и символы, будут переданы через RCX, RDX, R8 и R9 (в указанном порядке). 
  Параметры с плавающей точкой будут переданы через XMM0, XMM1, XMM2 и XMM3 (в указанном порядке). 
- Если есть смесь значений с плавающей точкой и целых чисел, они все равно будут переданы через регистр, 
  соответствующий их положению. Например, func(1, 3.14, 6, 6.28)первый параметр будет передан через RCX, второй 
  через XMM1, третий через R8 и последний через XMM3. 
- Если передаваемый параметр слишком велик для размещения в регистре, то он передается по ссылке (указателю на данные 
  в памяти). Параметры могут передаваться через любой соответствующий регистр. Например, RCX, ECX, CX, CH и CL могут 
  использоваться для первого параметра. Все остальные параметры помещаются в стек, СПРАВА на ЛЕВО.  
В стеке всегда будет выделено место для 4 параметров, даже если параметров нет. Это место не тратится полностью, 
  потому что компилятор может и часто будет его использовать. Обычно, если это отладочная сборка, компилятор 
  помещает копию параметров в это место. В релизных сборках компилятор будет использовать его для временного или 
  локального хранения переменных.

Вот еще несколько правил соглашения о вызовах:

- Базовый указатель (RBP) сохраняется при вызове функции, чтобы его можно было восстановить.
- Возвращаемое значение функции передается через RAX, если это целое число, bool, char и т. д., или через XMM0, если 
  это число с плавающей точкой или число двойной точности.
- Функции-члены имеют неявный первый параметр для указателя "this". Поскольку это указатель и это первый параметр, он 
  будет передан через RCX. Это может быть очень полезно знать.
- Вызывающий объект отвечает за выделение места для параметров для вызываемого объекта. Вызывающий объект всегда 
  должен выделять место для 4 параметров, даже если параметры не передаются.
- Регистры RAX, RCX, RDX, R8, R9, R10, R11 и XMM0-XMM5 считаются энергозависимыми и должны считаться уничтоженными 
  при вызовах функций.
- Регистры RBX, RBP, RDI, RSI, RSP, R12, R13, R14, R15 и XMM6-XMM15 считаются энергонезависимыми и должны сохраняться 
  и восстанавливаться функцией, которая их использует.

#### Доступ к стеку
К данным в стеке, таким как локальные переменные и параметры функций, часто обращаются с помощью RBP или RSP. На x64 
очень часто можно увидеть RSP, используемый вместо RBP для доступа к параметрам. Помните, что первые четыре 
параметра, даже если они передаются через регистры, все равно имеют зарезервированное для них место в стеке. Это 
пространство будет составлять 32 байта (0x20), по 8 байт на каждый из 4 регистров. Запомните это, потому что в 
какой-то момент вы увидите это смещение при доступе к параметрам, переданным в стеке.

1-4 Параметры:
Аргументы будут проталкиваться через соответствующие регистры слева направо. Компилятор, скорее всего, будет 
использовать RSP+0x0 по RSP+0x18 для других целей.

Более 4 параметров:
Первые четыре аргумента передаются через регистры слева направо, а остальные помещаются в стек, начиная со смещения 
RSP+0x20, справа налево. Это делает RSP+0x20 пятым аргументом, а RSP+0x28.
Вот очень простой пример, где числа от 1 до 8 передаются из одной функции в другую. Обратите внимание на порядок, в 
котором они размещены.
```commandline
function(1,2,3,4,5,6,7,8)
MOV RCX 0x1 ; Going left to right.
MOV RDX 0x2
MOV R8 0x3
MOV R9 0x4
PUSH 0x8 ; Now going right to left.
PUSH 0x7
PUSH 0x6
PUSH 0x5
CALL function
```
В этом случае доступ к параметрам стека должен осуществляться через RSP+0x20 — RSP+0x28.

Помещение их в регистры слева направо, а затем помещение их в стек справа налево, возможно, не имеет смысла, но это 
имеет смысл, если вы подумаете об этом. Сделав это, если бы вы вытащили параметры из стека, они были бы в порядке.
```commandline
POP R10 ; = 5
POP R11 ; = 6
POP R12 ; = 6
POP R13 ; = 7
```
Теперь вы можете получить к ним доступ слева направо по порядку: RCX, RDX, R8, R9, R10, R11, R12, R13.

Красиво :D

Дальнейшее исследование
Это соглашение о вызовах x64 Windows fastcall в двух словах. Изучение первого соглашения о вызовах похоже на 
изучение первого языка программирования. Сначала это кажется сложным и пугающим, но это, вероятно, потому, что вы 
слишком много думаете об этом. Более того, обычно сложнее выучить первое соглашение о вызовах, чем второе или третье.

Если вы хотите узнать больше об этом соглашении о вызовах, вы можете сделать это здесь:
https://docs.microsoft.com/en-us/cpp/build/x64-calling-convention?view=vs-2019
https://docs.microsoft.com/en-us/cpp/build/x64-software-conventions?view=vs-2019

Быстрое напоминание: не помешает вернуться и снова прочитать разделы регистров, структуры памяти и инструкций. Может 
быть, даже вернуться и прочитать этот раздел после них. Все эти концепции переплетены, поэтому это может помочь. Я 
знаю, что перечитывать это раздражает и иногда расстраивает, но поверьте мне, когда я говорю, что это того стоит.

`cdecl (Декларация C)`
После подробного рассмотрения fastcall давайте кратко рассмотрим cdecl.

Параметры передаются по стеку в обратном порядке (справа налево).
Базовый указатель (RBP) сохраняется для возможности восстановления.
Возвращаемое значение передается через EAX.
Вызывающий очищает стек. Это то, что делает cdecl крутым. Поскольку вызывающий очищает стек, cdecl допускает переменное количество параметров.
Как я уже сказал, после того, как вы поймете свою первую конвенцию о вызовах, изучение других будет довольно простым. Быстрое напоминание, это был только краткий обзор cdecl.

Более подробную информацию смотрите здесь:

https://docs.microsoft.com/en-us/cpp/build/x64-software-conventions?view=vs-2019
https://docs.microsoft.com/en-us/cpp/build/x64-calling-convention?view=vs-2019
https://docs.microsoft.com/en-us/cpp/build/prolog-and-epilog?view=vs-2019
https://www.gamasutra.com/view/news/171088/x64_ABI_Intro_to_the_Windows_x64_calling_convention.php
Ответьте на вопросы ниже
Какой 64-битный регистр в fastcall будет содержать возвращаемое значение функции?
RAX

Правильный ответ
В каком регистре передается первый параметр функции в fastcall?

RCX

Правильный ответ
З
```commandline
Ответ не нужен
```

## Задание 9
Макет памяти
Память системы организована определенным образом. Это делается для того, чтобы у каждой вещи было свое место.

#### Сегменты памяти
Существуют различные сегменты/разделы, в которых данные или код хранятся в памяти. Они следующие:

- Стек — содержит нестатические локальные переменные. Скоро будет рассмотрено более подробно.
- Куча — содержит динамически выделяемые данные, которые могут быть изначально неинициализированы.
- .data — содержит глобальные и статические данные, инициализированные ненулевым значением.
- .bss — содержит глобальные и статические данные, которые не инициализированы или инициализированы нулем.
- .text - Содержит код программы (не вините меня за название, я его не придумал).

#### Обзор разделов памяти
Вот общий обзор того, как организована память в Windows. Он предельно упрощен.

Важный:

На диаграмме выше показано направление, в котором переменные (и любые именованные данные, даже структуры) помещаются 
в память или извлекаются из нее. Фактические данные помещаются в память по-разному. Вот почему диаграммы стека так 
сильно различаются. Вы часто будете видеть диаграммы стека, в которых стек и куча растут друг к другу или верхние 
адреса памяти находятся наверху. Я объясню подробнее позже. Диаграмма, которую я показываю, наиболее актуальна для 
обратного проектирования. Низкие адреса, находящиеся наверху, также являются наиболее реалистичным изображением.

#### Объяснение каждого раздела:
**Стек** — область памяти, которую можно быстро использовать для статического распределения данных. Представьте себе 
стек с младшими адресами наверху и старшими адресами внизу. Это идентично обычному числовому списку. Данные 
считываются и записываются по принципу «последним пришел — первым ушел» (LIFO). Структура LIFO стека часто 
представлена в виде стопки пластин. Вы не можете просто вынуть третью пластину сверху, вам нужно снимать по одной 
пластине за раз, чтобы добраться до нее. Вы можете получить доступ только к той части данных, которая находится 
наверху стека, поэтому для доступа к другим данным вам нужно убрать то, что сверху, с дороги. Когда я сказал, что 
стек содержит статические данные, я имел в виду данные, которые имеют известную длину, например, целое число. Размер 
целого числа определяется во время компиляции, размер обычно составляет 4 байта, поэтому мы можем поместить его в 
стек. Если максимальная длина не указана, пользовательский ввод должен храниться в куче, поскольку данные имеют 
переменный размер. Однако адрес/расположение ввода, вероятно, будет сохранен в стеке для будущего использования. 
Когда вы помещаете данные наверх стека, вы помещаете их в стек. Когда данные помещаются в стек, стек растет вверх, в 
сторону нижних адресов памяти. Когда вы удаляете часть данных с вершины стека, вы выталкиваете ее из стека. Когда 
данные выталкиваются из стека, стек уменьшается вниз, в сторону верхних адресов. Все это может показаться странным, 
но помните, это как обычный числовой список, где 1, меньшее число, находится наверху. 10, большее число, находится 
внизу. Для отслеживания стека используются два регистра. Указатель стека (RSP/ESP/SP) используется для отслеживания 
верха стека, а указатель базы (RBP/EBP/BP) используется для отслеживания основания/дна стека. Это означает, что 
когда данные помещаются в стек, указатель стека уменьшается, поскольку стек растет в сторону нижних адресов. 
Аналогично, указатель стека увеличивается, когда данные выталкиваются из стека. Указатель базы не имеет причин 
меняться, когда мы что-то помещаем в стек или выталкиваем из него. Мы поговорим об указателе стека и указателе базы 
больше со временем.
Будьте осторожны, иногда вы будете видеть стек, представленный наоборот, но я обучаю тому, как вы увидите его в 
реальном мире.

**Куча** — похожа на стек, но используется для динамического выделения памяти и немного медленнее в доступе. Куча 
обычно используется для динамических данных (изменяющихся или непредсказуемых). Такие вещи, как структуры и 
пользовательский ввод, могут храниться в куче. Если размер данных неизвестен во время компиляции, они обычно 
хранятся в куче. Когда вы добавляете данные в кучу, она растет в сторону более высоких адресов.
Образ программы - Это программа/исполняемый файл, загруженный в память. В Windows это обычно Portable Executable ( PE ) .
Не стоит пока слишком беспокоиться о TEB и PEB. Это всего лишь краткое введение в них.

- TEB — блок среды потока (TEB) хранит информацию о текущих запущенных потоках.
- PEB — Process Environment Block (PEB) хранит информацию о процессе и загруженных модулях. Одна часть информации, 
  которую содержит PEB, — это «BeingDebugged», которая может использоваться для определения того, отлаживается ли текущий процесс.
Структура PEB: https://docs.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb
Вот краткий пример диаграммы стека и кучи с некоторыми данными на них.



На диаграмме выше stackVar1было создано ранее stackVar2 , аналогично для переменных кучи.

#### Стековые фреймы
Кадры стека — это фрагменты данных для функций. Эти данные включают локальные переменные, сохраненный базовый 
указатель, обратный адрес вызывающей стороны и параметры функции. Рассмотрим следующий пример:
```commandline
int Square(int x){
    return x*x;
}
int main(){
    int num = 5;
    Square(5);
}
```

В этом примере main() сначала вызывается функция. При main() вызове для нее создается стековый кадр. Стековый кадр для 
main(), перед вызовом функции в Square(), включает локальную переменную num и переданные ей параметры (в этом случае 
параметры не передаются в main). При main() вызове Square() сохраняются базовый указатель (RBP) и адрес возврата. 
Помните, что базовый указатель указывает на базу/дно стека. Базовый указатель сохраняется, потому что при вызове 
функции базовый указатель обновляется, чтобы указывать на базу стека этой функции. После возврата функции базовый 
указатель восстанавливается, поэтому он указывает на базу стекового кадра вызывающей функции. Адрес возврата 
сохраняется, поэтому после возврата функции программа знает, где возобновить выполнение. Адрес возврата — это 
следующая инструкция после вызова функции. Таким образом, в этом случае адрес возврата — это конец функции. Это main
() может показаться запутанным, надеюсь, это прояснит ситуацию:

```commandline
mov RAX, 15 ;RAX = 15
call func   ;Call func. Same as func();
mov RBX, 23 ;RBX = 23. This line is saved as the return address for the function call.
```

Я знаю, что это может немного сбивать с толку, но это довольно просто в том, как это работает. Это может быть просто 
не интуитивно понятно на первый взгляд. Это просто говорит компьютеру, куда идти (какую инструкцию выполнить), когда 
функция возвращается. Вы не хотите, чтобы он выполнял инструкцию, которая вызвала функцию, потому что это вызовет 
бесконечный цикл. Вот почему следующая инструкция используется вместо этого в качестве адреса возврата. Так что в 
приведенном выше примере RAX устанавливается в 15, затем func вызывается вызванная функция. После возврата она начнет 
выполняться с адреса возврата, который является строкой, содержащей mov RBX, 23.

Вот схема стекового кадра:


Отметьте расположение всего. Это пригодится в будущем.

Порядковый номер байтов

Учитывая значение 0xDEADBEEF, как его следует хранить в памяти? Это обсуждалось некоторое время и до сих пор 
вызывает споры. Сначала может показаться интуитивно понятным хранить его как есть, но если вы думаете об этом с 
точки зрения компьютера, то это не так просто. Из-за этого существует два способа, которыми компьютеры могут хранить 
данные в памяти — big-endian и little-endian.

- Big Endian - Самый старший байт (крайний слева) сохраняется первым. Это будет 0xDEADBEEF из примера.
- Little Endian - Наименее значимый байт (крайний правый) сохраняется первым. Это будет 0xEFBEADDE из примера.
Подробнее о порядке байтов можно узнать здесь: https://www.youtube.com/watch?v=NcaiHcBvDR4

#### Хранение данных
Как и обещал, я объясню, как данные записываются в память. Это немного отличается от того, как выделяется место для 
данных. Вкратце, место в стеке выделяется для переменных снизу вверх, или от более высоких адресов к более низким.

Данные помещаются в это выделенное пространство очень просто. Это как писать по-английски: слева направо, сверху 
вниз. Первая часть данных в переменной или структуре находится по самому низкому адресу в памяти по сравнению с 
остальными данными. По мере добавления данных они помещаются по более высокому адресу дальше вниз по стеку.



Эта диаграмма иллюстрирует две вещи. Во-первых, как данные помещаются в выделенное им пространство. Во-вторых, 
побочный эффект того, как данные помещаются в выделенную им память. Я разберу диаграмму. Слева — создаваемые 
переменные. Справа — результаты создания этих переменных. Я просто сосредоточусь на стеке для этого объяснения.

- Слева трем переменным даны значения. Первая переменная, как объяснялось ранее, помещается внизу. Следующая 
переменная помещается сверху нее, а следующая сверху нее.
- После выделения места для переменных данные помещаются в эти переменные. Все довольно просто, но с массивом 
происходит что-то интересное. Обратите внимание, что он выделил массив только из 2 элементов stackArr[2], но ему 
было дано 3. = {3,4,5}Поскольку данные записываются от меньших адресов к большим или слева направо и сверху вниз, 
они перезаписывают данные переменной под ними. Таким образом, вместо stackVar22 они перезаписываются 5, которые 
должны были быть в stackArr[2].
Надеюсь, все это имеет смысл. Вот краткий обзор:

Переменные размещаются в стеке одна над другой, как стопка лотков. Это означает, что они размещаются в стеке, 
начиная с более высоких адресов и переходя к более низким.

Данные в переменные помещаются слева направо, сверху вниз, то есть от меньших адресов к большим.

Это простая концепция, постарайтесь не усложнять ее слишком сильно, просто потому что я дал длинное объяснение. 
Важно, чтобы вы ее поняли, поэтому я потратил так много времени на объяснение этой концепции. Именно из-за этих 
концепций существует так много описаний памяти, которые идут в разных направлениях.

#### RBP и RSP на x64
На x64 часто можно увидеть RBP, используемый нетрадиционным способом (по сравнению с x86). Иногда для указания 
данных в стеке, таких как локальные переменные и параметры функций, используется только RSP, а RBP используется для 
общих данных (аналогично RAX). Это будет обсуждаться более подробно позже.

### Ответьте на вопросы ниже
В каком порядке данные извлекаются из стека или помещаются в стек? Укажите аббревиатуру.
```commandline
LIFO
```

## Задание 10
На этом мы завершаем вводный обзор обратного проектирования. Теперь вы должны немного больше узнать о низкоуровневых 
операциях, что такое регистры, как работает сборка и как организована память. Надеюсь, вам понравилась эта комната, 
однако, это была одна из самых скучных частей этой темы, так что не волнуйтесь. Обратное проектирование и анализ 
реального программного обеспечения — это то, где можно получить массу удовольствия, и это то, что вы узнаете в 
будущих комнатах этой серии!

Один из лучших способов научиться — написать собственное программное обеспечение и провести его обратное 
проектирование, чтобы увидеть, как оно выглядит. Я часто делаю это, когда хочу изучить или ознакомиться с новой 
темой. Это особенно полезно при изучении новых методов атаки или опробовании эксплойтов. Это также делает вас лучшим 
программистом, что хорошо для разработки эксплойтов и более продвинутых методов обратного проектирования.

Для дальнейшего чтения руководства Intel и AMD (раздел «Архитектура AMD64») — отличные места, где можно посмотреть, 
когда дело доходит до сборки. Они содержат массу информации непосредственно от людей, которые создали ваш процессор. 
Документация Microsoft (она же MSDN) по-прежнему является местом, к которому обращаются разработчики, и 
документированными низкоуровневыми концепциями Windows. Также ознакомьтесь с Awesome Reverse Engineering на GitHub.

В любом случае, надеюсь увидеть вас в следующей комнате этой серии!

Следующая комната
https://tryhackme.com/room/windowsreversingintro

### Ответьте на вопросы ниже
Идите вперед и творите великие дела!
```commandline
Ответ не нужен
```
[>> вернуться на главную страницу](https://github.com/BEPb/tryhackme/blob/master/README.md)