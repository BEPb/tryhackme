[>> вернуться на главную страницу](https://github.com/BEPb/tryhackme/blob/master/README.md)

# Комната [Introduction to Cryptography](https://tryhackme.com/r/room/cryptographyintro) 

Всего 9 заданий:
## Задание 1
Цель этого класса — познакомить пользователей с основными концепциями криптографии, такими как:

- Симметричное шифрование, например AES
- Асимметричное шифрование, такое как RSA
- Обмен ключами Диффи-Хеллмана
- Хеширование
- ИПК


Предположим, вы хотите отправить сообщение, которое никто не сможет понять, кроме предполагаемого получателя. Как бы 
вы это сделали? 

Совершенно секретный документ со словами WUB KDFN PH

Одним из самых простых шифров является шифр Цезаря, использовавшийся более 2000 лет назад. Шифр Цезаря сдвигает 
букву на фиксированное число позиций влево или вправо. Рассмотрим случай сдвига на 3 позиции вправо для шифрования, 
как показано на рисунке ниже.

Иллюстрация шифрования шифром Цезаря

Получателю необходимо знать, что текст был смещен на 3 символа вправо, чтобы восстановить исходное сообщение.

Иллюстрация расшифровки шифра Цезаря

Используя тот же ключ для шифрования «TRY HACK ME», мы получаем «WUB KDFN PH».

Описанный выше шифр Цезаря может использовать ключ от 1 до 25. С ключом 1 каждая буква сдвигается на одну позицию, 
где A становится B, а Z становится A. С ключом 25 каждая буква сдвигается на 25 позиций, где A становится Z, а B 
становится A. Ключ 0 означает отсутствие изменений; более того, ключ 26 также не приведет к каким-либо изменениям, 
поскольку это приведет к полному повороту. Следовательно, мы приходим к выводу, что шифр Цезаря имеет ключевое 
пространство 25; есть 25 различных ключей, из которых пользователь может выбирать.

Рассмотрим случай, когда вы перехватили сообщение, зашифрованное с помощью Caesar Cipher: «YMNX NX FQUMF GWFAT 
HTSYFHYNSL YFSLT MTYJQ RNPJ». Нас просят расшифровать его без знания ключа. Мы можем попытаться сделать это, 
используя грубую силу, т. е. мы можем попробовать все возможные ключи и посмотреть, какой из них имеет наибольший 
смысл. На следующем рисунке мы заметили, что ключ 5 имеет наибольший смысл: «ЭТО ALPHA BRAVO КОНТАКТИРУЕТСЯ С МАЙКОМ 
В ОТЕЛЕ TANGO».

Расшифровка зашифрованного текста путем перебора всех возможных ключей, т.е. методом грубой силы

Шифр Цезаря считается шифром замены, поскольку каждая буква в алфавите заменяется другой.

Другой тип шифра называется шифром перестановки , который шифрует сообщение, изменяя порядок букв. Давайте 
рассмотрим простой шифр перестановки на рисунке ниже. Мы начинаем с сообщения «ЭТО ALPHA BRAVO КОНТАКТИРУЕТ С МАЙКОМ 
В ОТЕЛЕ TANGO» и ключа 42351. После того, как мы запишем буквы нашего сообщения, заполняя один столбец за другим, мы 
переставляем столбцы на основе ключа, а затем считываем строки. Другими словами, мы пишем по столбцам и считываем по 
строкам. Также обратите внимание, что мы проигнорировали все пространство в открытом тексте в этом примере. 
Полученный шифртекст «NPCOTGHOTH…» считывается одна строка за другой. Другими словами, шифр перестановки просто 
переставляет порядок букв, в отличие от шифра подстановки, который заменяет буквы, не меняя их порядок.

Иллюстрация транспозиционного шифра

Эта задача представила простые шифры замены и перестановки и применила их к сообщениям, составленным из буквенных 
символов. Для того, чтобы алгоритм шифрования считался безопасным , должно быть невозможно восстановить исходное 
сообщение, т. е. открытый текст. (В математических терминах нам нужна сложная задача, т. е. задача, которую нельзя 
решить за полиномиальное время. Задача, которую можно решить за полиномиальное время, — это задача, которую можно 
решить даже для больших входных данных, хотя компьютеру может потребоваться некоторое время, чтобы ее решить.)

Если зашифрованное сообщение может быть взломано за одну неделю, то используемое шифрование будет считаться 
небезопасным. Однако, если зашифрованное сообщение может быть взломано за 1 миллион лет, то шифрование будет 
считаться практически безопасным.

Рассмотрим моноалфавитный шифр замены, где каждая буква сопоставляется с новой буквой. Например, в английском языке 
вы сопоставляете «a» с одной из 26 английских букв, затем вы сопоставляете «b» с одной из оставшихся 25 английских 
букв, а затем сопоставляете «c» с одной из оставшихся 24 английских букв и так далее.

Например, мы можем выбрать буквы в алфавите «abcdefghijklmnopqrstuvwxyz», которые будут сопоставлены с 
«xpatvrzyjhecsdikbfwunqgmol» соответственно. Другими словами, «a» становится «x», «b» становится «p» и т. д. 
Получателю необходимо знать ключ, «xpatvrzyjhecsdikbfwunqgmol», для успешной расшифровки зашифрованных сообщений.   

Этот алгоритм может выглядеть очень безопасным, особенно потому, что перебор всех возможных ключей невозможен. 
Однако для взлома зашифрованного текста с использованием такого алгоритма шифрования можно использовать различные 
методы. Одной из слабых сторон такого алгоритма является частота букв. В английских текстах наиболее 
распространенными буквами являются «e», «t» и «a», поскольку они встречаются с частотой 13%, 9,1% и 8,2% 
соответственно. Более того, в английских текстах наиболее распространенными первыми буквами являются «t», «a» и «o», 
поскольку они встречаются с частотой 16%, 11,7% и 7,6% соответственно. Добавьте к этому тот факт, что большинство 
слов сообщения являются словарными словами, и вы сможете взломать зашифрованный текст с помощью шифра алфавитной 
замены в кратчайшие сроки.

На самом деле нам не нужно использовать ключ шифрования для расшифровки полученного зашифрованного текста: «Uyv sxd 
gyi siqvw x sinduxjd pvzjdw po axffojdz xgxo wsxcc wuidvw». Как показано на рисунке ниже, при использовании такого 
веб-сайта, как quipqiup , потребуется некоторое время, чтобы обнаружить, что исходный текст был «Человек, который 
двигает гору, начинает с того, что уносит небольшие камни». Этот пример ясно показывает, что этот алгоритм 
неисправен и не должен использоваться для конфиденциальной связи.

Скриншот сайта quipquip

### Ответьте на вопросы ниже
Вы получили следующее зашифрованное сообщение:

`«Xjnvw lc sluxjmw jsqm wjpmcqbg jg wqcxqmnvw; xjzjmmjd lc wjpm sluxjmw jsqm bqccqm zqy». Zlwvzjxj Zpcvcol`

Вы можете догадаться, что это цитата. Кто это сказал?
```commandline
Miyamoto Musashi
```

## Задание 2
Давайте рассмотрим терминологию:

- Криптографический алгоритм или шифр : этот алгоритм определяет процессы шифрования и дешифрования.
- Ключ : Криптографическому алгоритму необходим ключ для преобразования открытого текста в зашифрованный текст и 
  наоборот.
- открытый текст — это исходное сообщение, которое мы хотим зашифровать
- шифротекст — это сообщение в зашифрованном виде
- Симметричный алгоритм шифрования использует один и тот же ключ для шифрования и дешифрования. Следовательно, 
  общающиеся стороны должны договориться о секретном ключе, прежде чем смогут обмениваться сообщениями.

На следующем рисунке отправитель предоставляет процессу шифрования открытый текст и ключ для получения шифротекста. 
Шифротекст обычно отправляется по некоторому каналу связи. 

Общая структурная схема шифрования с использованием секретного ключа

На другом конце получатель предоставляет процесс расшифровки с тем же ключом, который использовал отправитель для 
восстановления исходного открытого текста из полученного шифртекста. Без знания ключа получатель не сможет 
восстановить открытый текст.  

Общая структурная схема дешифрования с использованием секретного ключа

Национальный институт стандартов и технологий ( NIST ) опубликовал Стандарт шифрования данных ( DES ) в 1977 году. 
DES — это симметричный алгоритм шифрования, использующий ключ размером 56 бит. В 1997 году была решена задача взлома 
сообщения, зашифрованного с помощью DES . Следовательно, было продемонстрировано, что стало возможным использовать 
перебор методом подбора, чтобы найти ключ и взломать сообщение, зашифрованное с помощью DES . В 1998 году ключ DES 
был взломан за 56 часов. Эти случаи показали, что DES больше не может считаться безопасным.

NIST опубликовал Advanced Encryption Standard (AES) в 2001 году. Как и DES , это симметричный алгоритм шифрования; 
однако он использует размер ключа 128, 192 или 256 бит, и он по-прежнему считается безопасным и используется сегодня.
AES повторяет следующие четыре преобразования несколько раз:  
- SubBytes(state): Это преобразование ищет каждый байт в заданной таблице подстановки (S-box) и заменяет его соответствующим значением. Это state16 байт, т.е. 128 бит, сохраненных в массиве 4 на 4.
- ShiftRows(state): Вторая строка смещена на одну позицию, третья строка смещена на две позиции, а четвертая строка 
  смещена на три позиции. Это показано на рисунке ниже.
- MixColumns(state): Каждый столбец умножается на фиксированную матрицу (массив 4 на 4).
- AddRoundKey(state): Раундовый ключ добавляется к состоянию с помощью операции XOR .

Иллюстрация функции ShiftRows при применении к массиву четыре на четыре

Общее количество раундов преобразования зависит от размера ключа.

Не волнуйтесь, если вы найдете это загадочным, потому что так оно и есть! Наша цель — не изучить детали работы AES и 
не реализовать его как библиотеку программирования; цель — оценить разницу в сложности между древними алгоритмами 
шифрования и современными. Если вам интересно углубиться в детали, вы можете проверить спецификации AES, включая 
псевдокод и примеры в опубликованном стандарте FIPS PUB 197 .

Помимо AES , многие другие алгоритмы симметричного шифрования считаются безопасными. Вот список алгоритмов 
симметричного шифрования, поддерживаемых GPG (GnuPG) 2.37.7, например:

Все упомянутые до сих пор алгоритмы являются алгоритмами симметричного шифрования блочного шифра. Алгоритм блочного 
шифра преобразует входные данные (открытый текст) в блоки и шифрует каждый блок. Блок обычно составляет 128 бит. На 
рисунке ниже мы хотим зашифровать открытый текст «TANGO HOTEL MIKE», всего 16 символов. Первым шагом является 
представление его в двоичном виде. Если мы используем ASCII, «T» находится 0x54в шестнадцатеричном формате, «A» — 
0x41и так далее. Каждые две шестнадцатеричные цифры составляют 8 бит и представляют один байт. Блок из 128 бит 
фактически составляет 16 байт и представлен в массиве 4 на 4. 128-битный блок подается как одна единица в метод 
шифрования.

Пример алгоритма блочного шифрования, применяемого к массиву четыре на четыре

Другой тип алгоритма симметричного шифрования — это потоковые шифры, которые шифруют открытый текст байт за байтом. 
Рассмотрим случай, когда мы хотим зашифровать сообщение «TANGO HOTEL MIKE»; каждый символ необходимо преобразовать в 
его двоичное представление. Если мы используем ASCII, «T» будет 0x54в шестнадцатеричном формате, а «A» — 0x41и так 
далее. Метод шифрования будет обрабатывать один байт за раз. Это представлено на рисунке ниже.

Пример алгоритма потокового шифрования, примененного к массиву байтов

Симметричное шифрование решает множество проблем безопасности, обсуждавшихся в комнате принципов безопасности . 
Предположим, что Алиса и Боб встретились, выбрали алгоритм шифрования и договорились о конкретном ключе. Мы 
предполагаем, что выбранный алгоритм шифрования безопасен и что секретный ключ хранится в безопасности. Давайте 
посмотрим, чего мы можем достичь:

- Конфиденциальность : Если Ева перехватит зашифрованное сообщение, она не сможет восстановить открытый текст. 
Следовательно, все сообщения, которыми обмениваются Алиса и Боб, являются конфиденциальными, пока они отправляются в зашифрованном виде.
- Целостность : Когда Боб получает зашифрованное сообщение и успешно расшифровывает его с помощью ключа, 
  согласованного с Алисой, Боб может быть уверен, что никто не сможет подделать сообщение по каналу. При 
  использовании современных безопасных алгоритмов шифрования любое незначительное изменение шифротекста помешает 
  успешному расшифровыванию или приведет к бессмыслице в виде открытого текста.  
- Подлинность : Возможность расшифровать зашифрованный текст с помощью секретного ключа также доказывает подлинность 
  сообщения, поскольку секретный ключ знают только Алиса и Боб.
Мы только начинаем, и мы знаем, как сохранять конфиденциальность, проверять целостность и обеспечивать подлинность 
  передаваемых сообщений. Более практичные и эффективные подходы будут представлены в последующих задачах. Вопрос на 
  данный момент в том, масштабируемо ли это.  

С Алисой и Бобом нам нужен один ключ. Если у нас есть Алиса, Боб и Чарли, нам нужно три ключа: один для Алисы и Боба,
другой для Алисы и Чарли и третий для Боба и Чарли. Однако количество ключей быстро растет; для общения между 100 
пользователями требуется почти 5000 различных секретных ключей. (Если вам интересна математика, стоящая за этим, то 
это 99 + 98 + 97 + … + 1 = 4950).

Более того, если одна система будет скомпрометирована, им нужно будет создать новые ключи для использования с 
другими 99 пользователями. Другой проблемой будет поиск безопасного канала для обмена ключами со всеми остальными 
пользователями. Очевидно, что это быстро выйдет из-под контроля.

В следующей задаче мы рассмотрим асимметричное шифрование. Одна из проблем, решаемых асимметричным шифрованием, 
заключается в том, что 100 пользователям нужно поделиться всего 100 ключами для безопасного общения. (Как 
объяснялось ранее, симметричное шифрование потребовало бы около 5000 ключей для защиты коммуникаций для 100 
пользователей.)

Существует множество программ для симметричного шифрования. Мы остановимся на двух, которые широко используются и 
для асимметричного шифрования: 
- Защита конфиденциальности GNU
- Проект OpenSSL
- Защита конфиденциальности GNU
GNU Privacy Guard , также известный как GnuPG или GPG , реализует стандарт OpenPGP.

Мы можем зашифровать файл с помощью GnuPG ( GPG ), используя следующую команду:

`gpg --symmetric --cipher-algo CIPHER message.txt`, где CIPHER — имя алгоритма шифрования. Вы можете проверить 
поддерживаемые шифры с помощью команды gpg --version. Зашифрованный файл будет сохранен как message.txt.gpg. 

По умолчанию вывод осуществляется в двоичном формате OpenPGP; однако, если вы предпочитаете создать 
ASCII-армированный вывод, который можно открыть в любом текстовом редакторе, следует добавить опцию --armor. 
Например, `gpg --armor --symmetric --cipher-algo CIPHER message.txt.`  

Расшифровать можно с помощью следующей команды:

`gpg --output original_message.txt --decrypt message.gpg`

Проект OpenSSL
Проект OpenSSL поддерживает программное обеспечение OpenSSL.

Мы можем зашифровать файл с помощью OpenSSL, используя следующую команду:

`openssl aes-256-cbc -e -in message.txt -out encrypted_message`

Полученный файл можно расшифровать с помощью следующей команды:

`openssl aes-256-cbc -d -in encrypted_message -out original_message.txt`

Чтобы сделать шифрование более безопасным и устойчивым к атакам методом подбора, мы можем добавить 
-pbkdf2использование функции вывода ключа на основе пароля 2 (PBKDF2); кроме того, мы можем указать количество 
итераций пароля для получения ключа шифрования с помощью -iter NUMBER. Для итерации 10 000 раз предыдущая команда 
будет выглядеть следующим образом:   

`openssl aes-256-cbc -pbkdf2 -iter 10000 -e -in message.txt -out encrypted_message`

Следовательно, команда расшифровки становится такой:

`openssl aes-256-cbc -pbkdf2 -iter 10000 -d -in encrypted_message -out original_message.txt`

В следующих вопросах мы будем использовать gpg и opensslна AttackBox для выполнения симметричного шифрования.

Необходимые файлы для этого задания находятся в `/root/Rooms/cryptographyintro/task02`.  ZIP-файл, прикрепленный к 
этому заданию, может быть использован для решения вопросов заданий 2, 3, 4, 5 и 6 . 

### Ответьте на вопросы ниже
Расшифруйте файл quote01, зашифрованный (с помощью AES256) ключом,  s!kR3T55 используя  gpg. Какое третье слово в файле?
```commandline
waste
```
Расшифруйте файл  quote02 , зашифрованный (с помощью AES256-CBC) ключом,  s!kR3T55 используя  openssl. Какое третье слово в файле?
```commandline
science
```
Расшифруйте файл  quote03 , зашифрованный (с помощью CAMELLIA256) ключом с  s!kR3T55 помощью  gpg. Какое третье слово в файле?
```commandline
understand
```

## Задание 3
Симметричное шифрование требует от пользователей поиска безопасного канала для обмена ключами. Под безопасным 
каналом мы в основном подразумеваем конфиденциальность и целостность. Другими словами, нам нужен канал, где никакая 
третья сторона не сможет подслушать и прочитать трафик; более того, никто не сможет изменить отправленные сообщения 
и данные.   

Асимметричное шифрование позволяет обмениваться зашифрованными сообщениями без защищенного канала; нам просто нужен 
надежный канал. Под надежным каналом мы подразумеваем, что нас в основном интересует целостность канала, а не 
конфиденциальность.  

При использовании асимметричного алгоритма шифрования мы бы сгенерировали пару ключей: открытый ключ и закрытый ключ.
Открытый ключ передается миру или, точнее, людям, которые хотят безопасно общаться с нами. Закрытый ключ должен 
храниться в безопасности, и мы никогда не должны позволять кому-либо получать к нему доступ. Более того, невозможно 
получить закрытый ключ, несмотря на знание открытого ключа.   

#### Как работает эта пара ключей?

Если сообщение зашифровано одним ключом, его можно расшифровать другим. Другими словами:

- Если Алиса зашифрует сообщение, используя открытый ключ Боба, его можно будет расшифровать только с помощью 
закрытого ключа Боба.
- И наоборот, если Боб зашифрует сообщение, используя свой закрытый ключ, его можно будет расшифровать только с 
  помощью открытого ключа Боба.
#### Конфиденциальность
Мы можем использовать асимметричное шифрование для достижения конфиденциальности, шифруя сообщения с помощью 
открытого ключа получателя. На следующих двух рисунках мы видим, что:

Алиса хочет обеспечить конфиденциальность в своем общении с Бобом. Она шифрует сообщение, используя открытый ключ 
Боба, а Боб расшифровывает его, используя свой закрытый ключ. Ожидается, что открытый ключ Боба будет опубликован в 
общедоступной базе данных или на его веб-сайте, например.

При использовании асимметричного шифрования Алиса шифрует сообщения с помощью открытого ключа Боба перед отправкой 
их Бобу. Боб расшифровывает сообщения с помощью своего закрытого ключа.

Когда Боб хочет ответить Алисе, он шифрует свои сообщения, используя открытый ключ Алисы, а Алиса может расшифровать 
их, используя свой закрытый ключ.

При использовании асимметричного шифрования Боб шифрует сообщения с помощью открытого ключа Алисы перед отправкой их 
Алисе. Алиса расшифровывает сообщения с помощью своего закрытого ключа.

Другими словами, становится легко общаться с Алисой и Бобом, обеспечивая при этом конфиденциальность сообщений. 
Единственное требование заключается в том, чтобы все стороны имели свои открытые ключи, доступные для 
заинтересованных отправителей.

Примечание: На практике алгоритмы симметричного шифрования обеспечивают более быстрые операции, чем асимметричное 
шифрование; поэтому позже мы рассмотрим, как можно использовать лучшее из обоих миров.

#### Целостность, подлинность и неотказуемость
Помимо конфиденциальности, асимметричное шифрование может решить вопросы целостности, подлинности и неотказуемости. 
Предположим, что Боб хочет сделать заявление и хочет, чтобы все могли подтвердить, что это заявление действительно 
исходит от него. Бобу нужно зашифровать сообщение, используя свой закрытый ключ; получатели могут расшифровать его, 
используя открытый ключ Боба. Если сообщение успешно расшифровывается открытым ключом Боба, это означает, что 
сообщение было зашифровано с помощью закрытого ключа Боба. (На практике он зашифровал бы хэш исходного сообщения. Мы 
подробнее остановимся на этом позже.)

Успешная расшифровка с использованием открытого ключа Боба приводит к нескольким интересным выводам.

Во-первых, сообщение не было изменено по пути (каналу связи); это доказывает целостность сообщения .
Во-вторых, зная, что никто не имеет доступа к закрытому ключу Боба, мы можем быть уверены, что это сообщение действительно пришло от Боба; это доказывает подлинность сообщения .
Наконец, поскольку никто, кроме Боба, не имеет доступа к закрытому ключу Боба, Боб не может отрицать отправку этого сообщения; это устанавливает неотказуемость.
Чтобы доказать подлинность с помощью асимметричного шифрования, Боб шифрует сообщение, используя свой закрытый ключ, а получатели могут расшифровать его, используя открытый ключ Боба.

Мы увидели, как асимметричное шифрование может помочь установить конфиденциальность, целостность, подлинность и 
неотказуемость. В реальных сценариях асимметричное шифрование может быть относительно медленным для шифрования 
больших файлов и огромных объемов данных. В другой задаче мы увидим, как можно использовать асимметричное шифрование 
в сочетании с симметричным шифрованием для достижения этих целей безопасности относительно быстрее.

ЮАР
RSA получил свое название от своих изобретателей, Ривеста, Шамира и Адлемана. Он работает следующим образом:

Терминал
```commandline
user@TryHackMe$ openssl genrsa -out private-key.pem 2048

user@TryHackMe$ openssl rsa -in private-key.pem -pubout -out public-key.pem
writing RSA key

user@TryHackMe$ cat public-key.pem
-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAymcAeYg1ohPQLHu7u9l1
UutN8bCP7r6czRX2zrQrpElYrm5mHERi1xweWEhTJ/0Q13FJcHLGtLbdQc0rGpOd
DnYJBuzrqXU2hC7E7dlqLsj63NPADqlOGYCGCWnm/HGM2WuVtDXqRitN4zeNKEWI
QmEctfucopZx5AVJ1vTn+qMv/0D6QU7Mm65MTSYg1SCRA0D0N9NLMj4rYlLOIr5q
5g3iunAE4tCROMcHf7fxWMuWdJTdtxTv7+4P5XGkWrWriO22JFHp9N22Fm96V9jH
7aASRkIZvQFmx+1dl7btZDhsm2ezU07LBabv9efj0gIwz6P3mTJVm+wxaDH6jiXB
dwIDAQAB
-----END PUBLIC KEY-----

user@TryHackMe$ openssl rsa -in private-key.pem -text -noout
Private-Key: (2048 bit, 2 primes)
modulus:
    00:ca:67:00:79:88:35:a2:13:d0:2c:7b:bb:bb:d9:
    75:52:eb:4d:f1:b0:8f:ee:be:9c:cd:15:f6:ce:b4:
    2b:a4:49:58:ae:6e:66:1c:44:62:d7:1c:1e:58:48:
    53:27:fd:10:d7:71:49:70:72:c6:b4:b6:dd:41:cd:
    2b:1a:93:9d:0e:76:09:06:ec:eb:a9:75:36:84:2e:
    c4:ed:d9:6a:2e:c8:fa:dc:d3:c0:0e:a9:4e:19:80:
    86:09:69:e6:fc:71:8c:d9:6b:95:b4:35:ea:46:2b:
    4d:e3:37:8d:28:45:88:42:61:1c:b5:fb:9c:a2:96:
    71:e4:05:49:d6:f4:e7:fa:a3:2f:ff:40:fa:41:4e:
    cc:9b:ae:4c:4d:26:20:d5:20:91:03:40:f4:37:d3:
    4b:32:3e:2b:62:52:ce:22:be:6a:e6:0d:e2:ba:70:
    04:e2:d0:91:38:c7:07:7f:b7:f1:58:cb:96:74:94:
    dd:b7:14:ef:ef:ee:0f:e5:71:a4:5a:b5:ab:88:ed:
    b6:24:51:e9:f4:dd:b6:16:6f:7a:57:d8:c7:ed:a0:
    12:46:42:19:bd:01:66:c7:ed:5d:97:b6:ed:64:38:
    6c:9b:67:b3:53:4e:cb:05:a6:ef:f5:e7:e3:d2:02:
    30:cf:a3:f7:99:32:55:9b:ec:31:68:31:fa:8e:25:
    c1:77
publicExponent: 65537 (0x10001)
privateExponent:
    10:fe:00:be:33:3f:3d:72:28:61:f3:a9:59:25:f2:
    81:99:9b:9b:94:d5:20:98:04:15:fb:a8:12:c6:71:
    7b:83:64:dc:90:0c:26:87:5f:3c:eb:f1:68:3b:fa:
    2f:3b:41:b4:b4:a0:13:be:af:0b:f0:e6:36:66:01:
    1e:64:12:25:6a:a7:6b:5b:6c:95:77:6f:b2:3d:32:
    ef:3c:f7:7b:22:08:5d:8d:b1:6c:09:ae:b2:d9:65:
    67:58:ea:b9:7a:d6:f6:51:df:e9:97:35:29:da:ec:
    d9:0c:8a:df:3c:a7:29:db:79:4b:95:ea:1a:84:42:
    df:7f:ca:29:2f:ba:62:02:37:05:c0:b0:c2:ff:42:
    6b:fb:e1:36:40:10:ae:11:0f:d8:87:2f:fe:10:2e:
    a4:60:de:ff:fe:c8:ab:0b:29:fa:6c:20:ec:87:33:
    46:c0:cd:96:36:cb:9b:ca:81:17:e5:c3:eb:34:b2:
    83:0f:52:cc:e9:68:bd:cb:d2:85:2f:fe:c4:47:76:
    df:94:69:ce:7b:8a:50:71:36:96:e6:35:fb:fb:b4:
    4a:ac:63:9b:9d:1b:bb:32:71:31:45:a2:25:33:cc:
    f7:a5:fb:9f:66:b1:4e:30:ce:9d:71:e8:fa:7d:5f:
    33:a0:c1:94:0a:b7:b7:f3:16:7e:4f:ad:89:3d:ba:
    51
prime1:
    00:e0:3d:87:b3:d3:1f:d2:c6:66:23:83:a5:95:d5:
    20:35:f8:d8:c0:94:cf:cc:d2:04:d4:e4:ef:cf:c2:
    94:00:10:cd:d1:4a:df:09:4e:7e:95:f8:70:08:b1:
    20:98:8a:e3:88:f7:cc:a8:32:62:32:68:f6:1f:c0:
    fb:c1:71:41:8c:21:a3:ff:20:e6:96:d0:6e:4b:66:
    61:08:d0:b7:26:48:27:62:a7:d3:ff:36:55:c8:e1:
    ab:91:48:90:fb:b5:b1:92:be:90:06:a8:40:1b:2a:
    2d:53:1e:87:fc:a7:8a:57:72:0b:e5:35:71:7b:dd:
    8c:e5:b5:ab:64:7c:37:c5:0d
prime2:
    00:e7:11:ac:50:f5:dc:16:cf:20:46:77:5d:ca:16:
    29:36:35:89:95:c0:f8:4b:42:ef:03:a0:f1:ce:2e:
    1b:da:55:a9:ff:5a:28:4d:78:c5:8a:e2:55:9b:94:
    b4:56:ec:ab:1b:dd:b8:07:be:dd:d5:0f:49:90:b3:
    ed:a2:d7:78:38:24:d5:9e:7d:a2:e8:8c:e0:2a:33:
    32:21:1f:0e:6b:aa:0b:b4:11:6a:bd:8f:d9:86:3f:
    ad:42:c8:bc:42:23:21:39:8d:0c:60:f2:ca:2a:00:
    0a:8e:de:fb:1a:3c:51:9d:f2:dc:0a:59:80:d6:a4:
    47:5c:02:a3:d0:30:1d:47:93
[...]
```
Мы выполнили три команды:

`openssl genrsa -out private-key.pem 2048`: С помощью opensslмы использовали genrsaдля генерации закрытого ключа RSA.
Используя -out, мы указали, что полученный закрытый ключ сохраняется как private-key.pem. Мы добавили 2048, чтобы 
указать размер ключа 2048 бит.  
`openssl rsa -in private-key.pem -pubout -out public-key.pem`: Используя openssl, мы указали, что используем 
алгоритм RSA с rsa опцией. Мы указали, что хотим получить открытый ключ, используя -pubout. Наконец, мы установили 
закрытый ключ в качестве входных данных, используя `-in private-key.pem`, и сохранили выходные данные, используя `-out public-key.pem`. 
`openssl rsa -in private-key.pem -text -noout`: Нам любопытно увидеть реальные переменные RSA, поэтому мы 
использовали -text -noout. Значения p , q , N , e , и d равны prime1, prime2, modulus, publicExponent, и 
privateExponent, соответственно.  
Если у нас уже есть открытый ключ получателя, мы можем зашифровать его с помощью команды `openssl pkeyutl -encrypt -in plaintext.txt -out ciphertext -inkey public-key.pem -pubin`

Получатель может расшифровать его с помощью команды `openssl pkeyutl -decrypt -in ciphertext -inkey private-key.pem -out decrypted.txt`

### Ответьте на вопросы ниже
В AttackBox вы можете найти каталог для этой задачи по адресу  `/root/Rooms/cryptographyintro/task03`; в качестве 
альтернативы вы можете использовать файл задачи из Задачи 2 для работы на своей собственной машине. 

Боб получил файл  ciphertext_message , отправленный ему Алисой. Вы можете найти нужный вам ключ в той же папке. 
Какое первое слово исходного открытого текста? 
```commandline
Perception
```
Взгляните на закрытый ключ RSA Боба. Каков последний байт  p ?
```commandline
e7
```
Взгляните на закрытый ключ RSA Боба. Какой последний байт  q ?
```commandline
27
```

## Задание 4
Алиса и Боб могут общаться по незащищенному каналу. Под незащищенным мы подразумеваем, что есть подслушивающие, которые могут читать сообщения, которыми обмениваются по этому каналу. Как Алиса и Боб могут договориться о секретном ключе в такой обстановке? Одним из способов было бы использование обмена ключами Диффи-Хеллмана.

Диффи-Хеллман — это асимметричный алгоритм шифрования. Он позволяет обмениваться секретом по общедоступному каналу. Мы пропустим модульную арифметику и приведем простой числовой пример. Нам понадобятся две математические операции: степень и модуль. x p , т. е. x в степени p , — это x , умноженный сам на себя p раз. Кроме того, x mod m , т. е. x modulus m , — это остаток от деления x на m .

Мы видим, что Алиса и Боб пришли к одному и тому же ключу.

Графическая иллюстрация, показывающая числовой пример пяти шагов Диффи-Хеллмана

Хотя выбранные нами числа позволяют легко найти a и b , даже без использования компьютера, в реальных примерах будет выбрано q длиной 256 бит. В десятичных числах это 115 с 75 нулями справа (я тоже не знаю, как это читать, но мне сказали, что это читается как 115 кваттуорвигинтиллион). Такое большое q сделает невозможным найти a или b , несмотря на знание q ,  g ,  A , и B .

Давайте взглянем на фактические параметры Диффи-Хеллмана. Мы можем использовать opensslдля их генерации; нам нужно указать опцию, dhparamчтобы указать, что мы хотим сгенерировать параметры Диффи-Хеллмана вместе с указанным размером в битах, например 2048или 4096.

В выводе консоли ниже мы можем просмотреть простое число Pи генератор Gс помощью команды openssl dhparam -in dhparams.pem -text -noout. (Это похоже на то, что мы делали с закрытым ключом RSA.)

Терминал
```commandline
user@TryHackMe$ openssl dhparam -out dhparams.pem 2048
Generating DH parameters, 2048 bit long safe prime
[...]
$ openssl dhparam -in dhparams.pem -text -noout
    DH Parameters: (2048 bit)
    P:   
        00:82:3b:9d:b5:29:31:f8:12:fe:21:e1:90:30:37:
        ac:d2:48:41:f7:d7:55:e5:d2:5d:dd:87:67:9e:bd:
        b3:97:df:05:a9:d2:d9:56:4f:66:b5:d9:d8:65:06:
        58:c3:8f:b3:0e:30:d2:9a:0b:c3:0a:56:8d:fc:0f:
        f2:e2:9e:4f:16:16:93:4e:b9:a4:c3:9c:09:2d:48:
        a2:ec:b6:97:92:63:a3:b4:75:36:3f:51:77:ca:ac:
        44:6d:99:eb:4d:4a:97:d5:4b:52:c8:07:f8:16:30:
        37:d3:b2:47:30:e6:4e:bc:6a:53:d1:9b:6a:4d:91:
        7a:4b:4f:af:3b:f0:ce:b9:ed:91:4d:8b:52:5a:3f:
        bb:6b:06:ae:32:95:7d:53:da:9b:ce:b0:ec:7d:81:
        25:05:d8:ce:ca:76:e7:d1:5a:31:13:d2:9f:62:b4:
        d5:ad:7d:cd:c9:ab:3d:28:e3:92:27:9f:f3:66:a0:
        be:61:49:cc:47:21:d8:e0:2c:e8:c6:35:4b:2f:ba:
        35:36:8f:bb:41:c6:89:b2:60:3c:62:bb:fe:bf:59:
        d3:7f:05:69:55:dc:61:1b:b4:bb:68:fa:65:1e:2e:
        46:2f:2d:21:62:d1:9f:a0:2b:aa:81:df:3a:f9:7d:
        0b:9d:0e:47:68:01:4f:6e:81:cc:4c:2a:91:fc:8c:
        f4:6f
    G:    2 (0x2)
```
Алгоритм обмена ключами Диффи-Хеллмана позволяет двум сторонам согласовывать секрет по незащищенному каналу. Однако 
обсуждаемый обмен ключами подвержен атаке Man-in-the-Middle (MitM); злоумышленник может ответить Алисе, 
притворившись Бобом, и ответить Бобу, притворившись Алисой. Мы обсуждаем решение этой проблемы в Задаче 6.  

### Ответьте на вопросы ниже
В AttackBox вы можете найти каталог для этой задачи по адресу  `/root/Rooms/cryptographyintro/task04`; в качестве 
альтернативы вы можете использовать файл задачи из Задачи 2 для работы на своей собственной машине. 

Набор параметров Диффи-Хеллмана можно найти в файле  dhparam.pem. Каков размер простого числа в битах?
```commandline
4096
```
Каков последний байт простого числа (младший байт)?
```commandline
4f
```

## Задание 5
Криптографическая хэш-функция — это алгоритм, который принимает данные произвольного размера в качестве входных 
данных и возвращает фиксированное значение размера, называемое дайджестом сообщения или контрольной суммой , в 
качестве выходных данных. Например, sha256sum вычисляет дайджест сообщения SHA256 (Secure Hash Algorithm 256). SHA256,
как следует из названия, возвращает контрольную сумму размером 256 бит (32 байта). Эта контрольная сумма обычно 
записывается с использованием шестнадцатеричных цифр. Зная, что шестнадцатеричная цифра представляет 4 бита, 
контрольную сумму в 256 бит можно представить в виде 64 шестнадцатеричных цифр.

В выводе терминала ниже мы вычисляем хэш-значения SHA256 для трех файлов разного размера: 4 байта, 275 МБ и 5,2 ГБ. 
Используя sha256sum для вычисления дайджеста сообщения для каждого из трех файлов, мы получаем три совершенно разных 
значения, которые кажутся случайными. Стоит подчеркнуть, что длина полученного дайджеста сообщения или контрольной 
суммы одинакова, независимо от того, насколько мал или велик файл. В частности, четырехбайтовый файл abc.txtи файл 5,
2 ГБ привели к дайджестам сообщений одинаковой длины независимо от размера файла.

Терминал
```commandline
user@TryHackMe$ ls -lh
total 5.5G
-rw-r--r--. 1 strategos strategos    4  7月 21 12:46 abc.txt
-rw-r--r--. 1 strategos strategos 275M  2月 12 19:08 debian-hurd.img.tar.xz
-rw-r--r--. 1 strategos strategos 5.2G  4月 26 16:55 Win11_English_x64v1.iso
$ sha256sum *
c38bb113c89d8fec6475a9936411007c45563ecb7ce8acd5db7fb58c0872bda0  abc.txt
0317ff0150e0d64b70284b28c97bb788310585ea7ac46cc8139d5a3c850dea55  debian-hurd.img.tar.xz
4bc6c7e7c61af4b5d1b086c5d279947357cff45c2f82021bb58628c2503eb64e  Win11_English_x64v1.iso
```
Но зачем нам такая функция? Есть много применений, в частности:

Хранение паролей: вместо хранения паролей в открытом виде сохраняется хэш пароля. Следовательно, если произойдет утечка данных, злоумышленник получит список хэшей паролей вместо исходных паролей. (На практике пароли также «солятся», как обсуждается в более поздней задаче.)
Обнаружение изменений: Любое незначительное изменение исходного файла приведет к радикальному изменению значения хэш-функции, т. е. контрольной суммы.
В следующем выводе терминала у нас есть два файла, text1.txtи text2.txt, которые почти идентичны, за исключением 
(буквально) одного бита, который отличается; буквы Tи t отличаются одним битом в их представлении ASCII. Несмотря на то, что мы перевернули только один бит, очевидно, что контрольные суммы SHA256 совершенно разные. Следовательно, если мы используем безопасный алгоритм хэш-функции, мы можем легко подтвердить, были ли внесены какие-либо изменения. Это может помочь защитить как от преднамеренного вмешательства, так и от ошибок передачи файлов.

Терминал
```commandline
user@TryHackMe$ hexdump text1.txt -C
00000000  54 72 79 48 61 63 6b 4d  65 0a                    |TryHackMe.|
0000000a
$ hexdump text2.txt -C
00000000  74 72 79 48 61 63 6b 4d  65 0a                    |tryHackMe.|
0000000a
$ sha256sum text1.txt
f4616fd825a10ded9af58fbaee09f3e31751d15591f9323ea68b03a0e8ac3783  text1.txt
$ sha256sum text2.txt
9ffa3533ee33998aeb1df76026f8031c8af6ccabd8393eca002d5b7471a0b536  text2.txt
```
Вот некоторые из используемых алгоритмов хеширования, которые по-прежнему считаются безопасными:

SHA224, SHA256, SHA384, SHA512
RIPEMD160
Некоторые старые хэш-функции, такие как MD5 (Message Digest 5) и SHA-1, криптографически взломаны. Под взломанными мы подразумеваем возможность создания другого файла с той же контрольной суммой, что и у заданного файла. Это означает, что мы можем создать коллизию хэшей. Другими словами, злоумышленник может создать новое сообщение с заданной контрольной суммой, и обнаружение подделки файла или сообщения будет невозможно.

HMAC
Код аутентификации сообщений на основе хэша (HMAC) — это код аутентификации сообщений (MAC), который использует криптографический ключ в дополнение к хэш-функции.

Согласно RFC2104 , HMAC требует:

секретный ключ
внутренний пад (ipad) — константная строка. (RFC2104 использует байт, 0x36повторяющийся B раз. Значение B зависит от выбранной хэш-функции.)
внешний промежуток (opad) — постоянная строка. (RFC2104 использует байт, 0x5Cповторяющийся B раз.)
Расчет HMAC выполняется в следующей последовательности, как показано на рисунке:


На рисунке выше представлены шаги, выраженные в следующей формуле: H ( K ⊕ o p a d , H ( K ⊕ i p a d , t e x t )) .

Для расчета HMAC в системе Linux можно использовать любой из доступных инструментов, таких как hmac256(или sha224hmac, sha256hmac, sha384hmac, и sha512hmac, где секретный ключ добавляется после опции --key). Ниже мы покажем пример расчета HMAC с использованием hmac256и sha256hmacс двумя разными ключами.

Терминал
```commandline
user@TryHackMe$ hmac256 s!Kr37 message.txt
3ec65b7e80c5bf2e623e52e0528f1c6a74f605b10616621ba1c22a89fb244e65  message.txt

user@TryHackMe$ hmac256 1234 message.txt
4b6a2783631180fca6128592e3d17fb5bff6b0e563ad8f1c6afc1050869e440f  message.txt

user@TryHackMe$ sha256hmac message.txt --key s!Kr37
3ec65b7e80c5bf2e623e52e0528f1c6a74f605b10616621ba1c22a89fb244e65  message.txt

user@TryHackMe$ sha256hmac message.txt --key 1234
4b6a2783631180fca6128592e3d17fb5bff6b0e563ad8f1c6afc1050869e440f  message.txt
```
### Ответьте на вопросы ниже
В AttackBox вы можете найти каталог для этой задачи по адресу  /root/Rooms/cryptographyintro/task05; в качестве альтернативы вы можете использовать файл задачи из Задачи 2 для работы на своей собственной машине.

Какова контрольная сумма SHA256 файла  order.json?
```commandline
2c34b68669427d15f76a1c06ab941e3e6038dacdfb9209455c87519a3ef2c660
```
Откройте файл  order.json и измените сумму с  1000 на  9000. Какова новая контрольная сумма SHA256?
```commandline
11faeec5edc2a2bad82ab116bbe4df0f4bc6edd96adac7150bb4e6364a238466
```
Используя SHA256 и ключ  3RfDFz82, каков HMAC  order.txt?
```commandline
c7e4de386a09ef970300243a70a444ee2a4ca62413aeaeb7097d43d2c5fac89f
```
## Задание 6
Использование обмена ключами, такого как обмен ключами Диффи-Хеллмана, позволяет нам согласовать секретный ключ на глазах и ушах подслушивающих лиц. Этот ключ можно использовать с симметричным алгоритмом шифрования для обеспечения конфиденциальной связи. Однако описанный нами ранее обмен ключами не защищен от атаки Man-in-the-Middle ( MITM ). Причина в том, что у Алисы нет возможности убедиться, что она общается с Бобом, а у Боба нет возможности убедиться, что он общается с Алисой при обмене секретным ключом.

Алиса и Боб продолжают общаться, думая, что общаются напрямую, не подозревая, что общаются с Мэллори, которая может читать и изменять сообщения перед отправкой их предполагаемому получателю.

Иллюстрация, демонстрирующая атаку «Человек посередине» против обмена ключами Диффи-Хеллмана

Эта восприимчивость требует некоторого механизма, который позволил бы нам подтвердить личность другой стороны. Это приводит нас к инфраструктуре открытых ключей ( PKI ).

Рассмотрим случай, когда вы просматриваете сайт example.org по HTTPS. Как вы можете быть уверены, что вы действительно общаетесь с сервером example.org(ами)? Другими словами, как вы можете быть уверены, что никакой посредник не перехватил пакеты и не изменил их до того, как они достигли вас? Ответ кроется в сертификате сайта.

На рисунке ниже показана страница, которую мы получаем при просмотре example.org. Большинство браузеров представляют зашифрованное соединение с помощью значка замка. Этот значок замка указывает на то, что соединение защищено по протоколу HTTPS с действительным сертификатом.

Скриншот браузера, на котором показан значок замка для зашифрованного соединения

На момент написания статьи example.org использует сертификат, подписанный DigiCert Inc., как показано на рисунке ниже. Другими словами, DigiCert подтверждает, что этот сертификат действителен (до определенной даты).

Скриншот, показывающий действительность сертификата веб-сайта

Чтобы сертификат был подписан центром сертификации, нам необходимо:

- Генерация запроса на подпись сертификата (CSR): вы создаете сертификат и отправляете свой открытый ключ на подпись 
третьей стороне.
- Отправьте ваш CSR в центр сертификации (CA): цель — чтобы центр сертификации подписал ваш сертификат. 
  Альтернативным и обычно небезопасным решением будет самостоятельно подписать ваш сертификат.
- Чтобы это сработало, получатель должен распознать и доверять CA, подписавшему сертификат. И, как мы и ожидали, наш 
  браузер доверяет DigiCert Inc как подписывающему органу; в противном случае он бы выдал предупреждение 
  безопасности вместо перехода на запрошенный веб-сайт. 

Снимок экрана, показывающий центры сертификации, которым доверяет веб-браузер

Вы можете использовать openssl для генерации запроса на подпись сертификата с помощью команды `openssl req -new -nodes -newkey rsa:4096 -keyout key.pem -out cert.csr`. Мы использовали следующие параметры:

- req -new создать новый запрос на подпись сертификата
- -nodes сохранить закрытый ключ без парольной фразы
- -newkey сгенерировать новый закрытый ключ
- rsa:4096 сгенерировать ключ RSA размером 4096 бит
- -keyout укажите где сохранить ключ
- -out сохранить запрос на подпись сертификата

Затем вам будет предложено ответить на ряд вопросов, как показано в выводе консоли ниже.

Терминал
```commandline
user@TryHackMe$ openssl req -new -nodes -newkey rsa:4096 -keyout key.pem -out cert.csr
[...]
-----
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [XX]:UK
State or Province Name (full name) []:London
Locality Name (eg, city) [Default City]:London
[...]
```
Как только файл CSR будет готов, вы можете отправить его в выбранный вами центр сертификации, чтобы он был подписан и готов к использованию на вашем сервере.

Как только клиент, т. е. браузер, получает подписанный сертификат, которому он доверяет, происходит рукопожатие SSL/TLS. Целью будет согласование шифров и секретного ключа.

Мы только что описали, как PKI применяется к веб- и SSL/TLS-сертификатам. Доверенная третья сторона необходима для масштабируемости системы.

Для целей тестирования мы создали самоподписанный сертификат. Например, следующая команда сгенерирует самоподписанный сертификат.

`openssl req -x509 -newkey -nodes rsa:4096 -keyout key.pem -out cert.pem -sha256 -days 365`

Указывает -x509, что мы хотим сгенерировать самоподписанный сертификат вместо запроса на сертификат. -sha256 
Указывает на использование дайджеста SHA-256 . Он будет действителен в течение одного года, поскольку мы добавили -days 365.

Чтобы ответить на вопросы ниже, вам нужно проверить файл сертификата cert.pemв task06каталоге. Вы можете использовать следующую команду для просмотра вашего сертификата:

`openssl x509 -in cert.pem -text`

### Ответьте на вопросы ниже
В AttackBox вы можете найти каталог для этой задачи по адресу  /root/Rooms/cryptographyintro/task06; в качестве 
альтернативы вы можете использовать файл задачи из Задачи 2 для работы на своей собственной машине. 

Каков размер открытого ключа в битах?
```commandline
4096
```
До какого года действителен этот сертификат?
```commandline
2039
```

## Задание 7
Давайте посмотрим, как криптография может помочь повысить безопасность паролей. С помощью PKI и SSL/TLS мы можем связываться с любым сервером и предоставлять наши учетные данные для входа, гарантируя, что никто не сможет прочитать наши пароли, пока они перемещаются по сети. Это пример защиты данных при передаче. Давайте рассмотрим, как мы можем защитить пароли, когда они сохраняются в базе данных, т. е. данные в состоянии покоя.

Наименее безопасным методом было бы сохранение имени пользователя и пароля в базе данных. Таким образом, любая утечка данных раскроет пароли пользователей. Не требуется никаких усилий, кроме чтения базы данных, содержащей пароли.


Улучшенный подход заключается в сохранении имени пользователя и хешированной версии пароля в базе данных. Таким образом, утечка данных раскроет хешированные версии паролей. Поскольку хеш-функция необратима, злоумышленнику необходимо продолжать пробовать разные пароли, чтобы найти тот, который даст тот же хеш. В таблице ниже показана сумма MD5 паролей. (Мы выбрали MD5 только для того, чтобы сохранить поле пароля небольшим для примера; в противном случае мы бы использовали SHA256 или что-то более безопасное.)


Предыдущий подход выглядит безопасным; однако наличие радужных таблиц сделало этот подход небезопасным. Радужная таблица содержит список паролей вместе с их хэш-значением. Следовательно, злоумышленнику нужно только посмотреть хэш, чтобы восстановить пароль. Например, было бы легко посмотреть, d8578edf8458ce06fbc5bb76a58c5ca4чтобы узнать исходный пароль alice. Следовательно, нам нужно найти более безопасные подходы для безопасного сохранения паролей; мы можем добавить соль. Соль — это случайное значение, которое мы можем добавить к паролю перед его хэшированием. Пример показан ниже.


В таблице выше использовалось hash(password + salt); другой подход — использовать hash(hash(password) + salt). Обратите внимание, что мы использовали относительно небольшую соль вместе с хэш-функцией MD5 . Мы должны переключиться на (более) безопасную хэш-функцию и большую соль для лучшей безопасности, если бы это была реальная настройка.

Еще одно улучшение, которое мы можем сделать перед сохранением пароля, — это использовать функцию вывода ключа, такую ​​как PBKDF2 (Password-Based Key Derivation Function 2). PBKDF2 берет пароль и соль и передает его через определенное количество итераций, обычно сотни тысяч.

Если вы хотите узнать о других методах, связанных с хранением паролей, рекомендуем вам ознакомиться с памяткой по хранению паролей.

### Ответьте на вопросы ниже
Вы проводили аудит системы, когда обнаружили, что MD5-хэш пароля администратора равен  3fc0a7acf087f549ac2b266baf94b8b1. Каков исходный пароль?
```commandline
qwerty123
```

## Задание 8
В этой задаче мы хотели бы изучить, что происходит, когда мы заходим на веб-сайт по протоколу HTTPS.

- Клиент запрашивает SSL/TLS-сертификат сервера
- Сервер отправляет сертификат SSL/TLS клиенту
- Клиент подтверждает, что сертификат действителен
Роль криптографии начинается с проверки сертификата. Чтобы сертификат считался действительным, он должен быть 
  подписан. Подписание означает, что хэш сертификата шифруется закрытым ключом доверенной третьей стороны; зашифрованный хэш добавляется к сертификату. 

Если третья сторона доверена, клиент будет использовать открытый ключ третьей стороны для расшифровки зашифрованного 
хеша и сравнения его с хешем сертификата. Однако, если третья сторона не распознана, соединение не будет установлено 
автоматически.  

Как только клиент подтверждает, что сертификат действителен, запускается рукопожатие SSL/TLS. Это рукопожатие 
позволяет клиенту и серверу согласовать секретный ключ и алгоритм симметричного шифрования, среди прочего. С этого 
момента все соответствующие сеансовые коммуникации будут шифроваться с использованием симметричного шифрования.  

Последним шагом будет предоставление учетных данных для входа. Клиент использует зашифрованный сеанс SSL/TLS для 
отправки их на сервер. Сервер получает имя пользователя и пароль и должен подтвердить, что они совпадают. 

Следуя рекомендациям по безопасности, мы ожидаем, что сервер сохранит хешированную версию пароля после добавления к 
нему случайной соли. Таким образом, если база данных будет взломана, восстановить пароли будет сложно. 

### Ответьте на вопросы ниже
Убедитесь, что вы прочитали и поняли приведенный выше сценарий. Цель состоит в том, чтобы увидеть, как симметричное 
и асимметричное шифрование используются вместе с хешированием во многих защищенных коммуникациях. 
```commandline
Ответ не нужен
```

## Задание 9
Криптография — обширная тема. В этой комнате мы попытались сосредоточиться на основных концепциях, которые помогут 
вам понять общепринятые термины в криптографии. Эти знания жизненно важны для понимания параметров конфигурации 
систем, использующих шифрование и хеширование.  

### Ответьте на вопросы ниже
Обязательно запишите все концепции и команды, рассмотренные в этой комнате.
```commandline
Ответ не нужен
```

[>> вернуться на главную страницу](https://github.com/BEPb/tryhackme/blob/master/README.md)