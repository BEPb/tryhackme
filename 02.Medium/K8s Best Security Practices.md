[>> вернуться на главную страницу](https://github.com/BEPb/tryhackme/blob/master/README.md)

# Комната [K8s Best Security Practices](https://tryhackme.com/r/room/k8sbestsecuritypractices) 

Всего 7 заданий:
## Задание 1
Эта комната для всех тех, кто стремится стать инженерами DevSecOps , и тех энтузиастов Kubernetes, которые нашли 
время, чтобы изучить основы инструмента. Она для тех, кто знает инструмент, как он работает и какие первые шаги 
необходимо предпринять при создании безопасного кластера Kubernetes. Но что теперь? Вы создали безопасный кластер, 
но как сохранить его в безопасности? Поскольку Kubernetes используется в качестве платформы для оркестровки 
контейнерных приложений, необходимо учитывать множество различных соображений безопасности на разных уровнях. Это 
может быть ошеломляющим для тех, кто хочет запрыгнуть на борт DevSecOps Express, или даже для тех, кто уже на борту.
Поэтому эта комната направлена на то, чтобы собрать некоторые ключевые лучшие практики безопасности Kubernetes, 
чтобы сделать ваше путешествие еще более плавным. Все на борт!          


Предпосылки обучения

Как было указано выше, эта комната предполагает наличие базовых знаний как Kubernetes, так и технологий контейнеров. 
Если вы новичок в Kubernetes, вам нужно будет пройти комнату Intro to Kubernetes , прежде чем приступать к ней. Эта 
комната является прямым продолжением комнаты Cluster Hardening , поэтому ее также следует пройти. Если вы не знакомы 
с контейнеризацией в целом, вам следует рассмотреть такие комнаты, как Intro to Containerisation , Intro to Docker и 
Container Hardening.

Цели обучения 
- Понять важность внедрения лучших практик безопасности в Kubernetes 
- Понимать ServiceAccounts в Kubernetes, их функции и лучшие практики безопасности, связанные с ними, уметь 
самостоятельно определять свои собственные
- Понять, как независимо определять роли и привязки ролей для реализации RBAC в кластере, и зачем это нужно
- Понимание запросов API в Kubernetes

### Ответьте на вопросы ниже
Нажмите, чтобы перейти к следующему заданию!

```commandline
Ответ не нужен
```

## Задание 2
Что такое ServiceAccount ( Kubernetes )?

Одной из важнейших практик безопасности в Kubernetes является эффективная и безопасная реализация контроля доступа. 
Учетные записи служб являются частью головоломки контроля доступа, которую вам нужно будет решить, чтобы понять, как 
реализовать. Учетные записи служб были кратко затронуты в комнате Введение в Kubernetes, но теперь пришло время 
более подробно рассмотреть, что они собой представляют и как они используются в Kubernetes. «Учетная запись службы» 
— это общий термин, который вам может быть знаком, если вы используете другие облачные технологии. В этой задаче мы 
определим учетную запись службы в контексте Kubernetes, объект ServiceAccount.

Учетные записи служб можно рассматривать как цифровые удостоверения или нечеловеческие учетные записи. В Kubernetes 
эта идентификация используется в контексте безопасности для связывания удостоверения с определенным процессом. 
Другими словами, системные компоненты Kubernetes, модули приложений или другие сущности, как внутри, так и за 
пределами кластера, могут использовать учетные данные ServiceAccount для идентификации в качестве этого 
ServiceAccount. С точки зрения безопасности это означает, что может иметь место аутентификация API или, как только 
что было упомянуто, контроль удостоверения/доступа может быть реализован с использованием этих ServiceAccount.

Учетные записи служб против пользователей 

Здесь было бы неплохо подчеркнуть аспект "нечеловеческой учетной записи" ServiceAccount и прояснить любую путаницу 
относительно аутентификации/авторизации пользователей-людей в кластере. Вот некоторая информация относительно 
ServiceAccounts и пользователей.

ServiceAccounts	Пользователи
Управляется K8s	Управляется вне K8s
Создано API
Объекта  Kubernetes «Пользователь» не существует
Имеют связанные учетные данные, которые хранятся как секреты 
Невозможно создать с помощью API

По сути, доступ пользователей обычно обрабатывается с помощью какого-либо решения по управлению учетными записями. В 
Kubernetes есть одно встроенное решение, но оно обычно интегрировано с другой системой управления пользователями, 
такой как LDAP или AD. Нечеловеческий доступ к кластеру и его ресурсам обрабатывается с помощью Kubernetes 
ServiceAccounts.

Пользователь и учетная запись службы

Расскажите мне больше… 

ServiceAccounts характеризуются следующими атрибутами:

Легковесность: Kubernetes ServiceAccounts позволяет вам создать учетную запись, связанную с определенной 
задачей/процессом в вашем кластере Kubernetes . Это избавляет от многих проблем, связанных с использованием учетной 
записи пользователя для запуска процессов (со специальными системами и бизнес-логикой, привязанными к базам данных, 
участвующим в создании учетной записи пользователя), и упрощает определение более детализированных, специфичных для 
задачи разрешений в соответствии с принципом наименьших привилегий.

Пространство имен: в Kubernetes ServiceAccounts — это ресурс пространства имен, то есть имена ServiceAccount должны 
быть уникальными только в пределах пространства имен, с которым они связаны. Каждое пространство имен при создании 
получает связанный с ним ServiceAccount по умолчанию, метко названный «default». Предположим, вы вручную не 
определяете ServiceAccount в определении модуля/развертывания. В этом случае этот «стандартный» ServiceAccount (в 
пространстве имен, в котором создается модуль) будет ему назначен, а учетные данные ServiceAccounts (токен) будут 
смонтированы к нему как секрет. Обратите внимание, что «стандартный» ServiceAccount по умолчанию имеет мало 
разрешений, поэтому, если задаче требуется больше, необходимо создать ServiceAccount.

Переносимость: поскольку ServiceAccounts являются легкими и должны быть уникальными только на уровне пространства 
имен, их можно объединять для использования в других пространствах имен или проектах, что делает их переносимыми.

Эти атрибуты подходят для нескольких вариантов использования. Как инженер DevSecOps, ваше чувство ServiceAccount 
должно зазвенеть, когда вы имеете дело с ними. Вот несколько примеров:

Задача/процесс, работающий в pod, должен взаимодействовать с API для получения секретной или конфиденциальной 
информации. ServiceAccount может быть использован здесь для предоставления доступа только для чтения к этому секрету.

У вас есть pod, работающий в "example-namespace". Его процесс включает обеспечение того, чтобы все pod работали в 
"other-namespace". Здесь можно использовать ServiceAccount с комбинацией RBAC (подробнее об этом позже), чтобы 
гарантировать, что у этого pod достаточно прав для перечисления pod в "other-namespace".

ServiceAccounts можно использовать для аутентификации внешних служб. Например, представьте, что у вас есть конвейер 
CI / CD , и этап в этом конвейере включает аутентификацию в вашем кластере Kubernetes.
Создание и настройка учетных записей служб

ServiceAccounts очень легко определить с помощью kubectl. Вы можете создать ServiceAccount в своем кластере, 
используя следующую команду.
Примечание: serviceaccount можно сократить до sa

Kubectl Создать учетную запись службы
`thm@k8s:~$ kubectl create serviceaccount example-name --namespace example-namespace`
Если вы хотите, чтобы этот ServiceAccount был связан с определенным модулем, вы должны определить это в YAML 
-конфигурации модуля/развертывания следующим образом:
```commandline
apiVersion: v1
kind: Pod
metadata:
  name: example-pod
  Namespace: example-namespace
spec:
  serviceAccountName: example-sa
  containers:
  - name: example-container
    image: nginx:latest
    ports:
    - containerPort: 80
```
### Ответьте на вопросы ниже
В каком виде хранятся учетные данные, связанные с ServiceAccount?
```commandline
secrets
```
Учетные записи Kubernetes ServiceAccounts являются облегченными, имеют пространство имен и какие еще атрибуты?
```commandline
Portable
```

## Задание 3
Почему RBAC ?

Частью лучших практик безопасности является подготовка к наихудшим сценариям. Вы надежно построили свой кластер 
Kubernetes и следовали лучшим практикам для его укрепления, но вам нужно быть готовым к сценариям, в которых 
злоумышленники получат доступ к кластеру. А именно, злоумышленник получит доступ либо к pod/приложению, либо к 
пользователю; другими словами, они аутентифицируются в кластере. Оба будут иметь соответствующие разрешения и будут 
авторизованы для выполнения определенных действий. Затем работа инженера DevSecOps заключается в том, чтобы 
гарантировать, что эти разрешения настроены с учетом минимальных привилегий.

Например, pod, который проверяет состояние выполнения в пространстве имен "x", должен иметь ТОЛЬКО необходимые 
разрешения для выполнения этого действия и никаких других. Таким образом, если злоумышленник получит доступ к этому 
ресурсу, он сможет выполнять только авторизованные действия, которые в этом случае дадут ему небольшой доступ. Мы 
можем реализовать это с помощью RBAC (Role Based Access Controls).

Комикс RBAC, иллюстрирующий сценарии принятия и отклонения

Для начала давайте определим, какие четыре различных объекта Kubernetes можно определить при реализации RBAC : 

Роль: Что может делать эта роль и с какими ресурсами? Разрешения являются аддитивными, то есть нет запрещающих 
разрешений. Думайте об этом как о списке разрешений для доступа к API. Вы предоставите глагол (что может делать эта 
роль), например, «get» или «delete», и ресурс (и с чем), например, «pods» или «secrets». Обратите внимание, что 
здесь также можно определить подресурсы с помощью / после имени ресурса, например, pods/log. Скоро это будет 
наглядно показано на примере конфигурации. Роли — это пространства имен, то есть они могут разрешать действия в 
пределах заданного пространства имен, а не всего кластера.

RoleBinding: Объект RoleBinding делает то, что заявлено на упаковке. Он привязывает роль (определенную выше) к 
ServiceAccount или User. Поскольку роли имеют пространство имен, роль, упомянутая в конфигурации RoleBinding YAML, 
должна существовать в том же пространстве имен, что и RoleBinding.

ClusterRole: ClusterRole функционально то же самое, что и Role, за исключением того, что роли предоставляются на 
уровне кластера (не в пространстве имен). Это будет использоваться, если необходим доступ к ресурсам уровня кластера,
таким как узлы или ресурсы в нескольких пространствах имен. Опять же, только если это НУЖНО, с учетом минимальных 
привилегий.

ClusterRoleBinding: ClusterRoleBinding функционально аналогичен RoleBinding, за исключением того, что он привязывает 
ClusterRole к ServiceAccount или пользователю.

RBAC в контексте 

Теперь, когда мы определили различные типы объектов RBAC, давайте предоставим больше контекста относительно того, 
где они будут использоваться. Как уже упоминалось, роли могут быть привязаны либо к ServiceAccounts, либо к Users. 
ServiceAccounts будут использоваться, если мы предоставляем авторизацию приложению, например, приложению, 
работающему в модуле в кластере или сторонней внешней службе, такой как Istio . Между тем, пользователи будут 
использоваться, если мы предоставляем авторизацию, как вы уже догадались, пользователям! Давайте теперь рассмотрим 
RBAC в контексте обоих из них.


Роль/Привязка к роли	ClusterRole/ClusterRoleBinding
ServiceAccount	
Роль и RoleBinding будут использоваться для того, чтобы разрешить приложению/модулю выполнять определенное действие 
над ресурсом пространства имен. Например, разрешить модулю получать запущенные модули в пространстве имен. Затем 
модулю будет назначен этот ServiceAccount.

То же, что и Role/RoleBinding, но для выполнения действий на ресурсе уровня кластера, например узле.

Пользователи	Представьте, что пользователю "Боб" было поручено следить за подами в пространстве имен "dev", чтобы 
убедиться, что развертывание находится в рабочем состоянии и может быть развернуто в "staging". Для этого 
пользователю должно быть предоставлено разрешение "получить" "поды" в пространстве имен "dev". Использование роли в 
этом случае было бы предпочтительнее, поскольку мы определяем ресурс пространства имен, и пользователь должен иметь 
доступ только к тому, что ему НУЖНО, а не к подам во всех пространствах имен.
Теперь представьте, что есть другой пользователь, "Алиса". Алиса — администратор кластера, и ей нужны разрешения на 
"создание" нескольких типов ресурсов во всех пространствах имен для настройки кластера. Для авторизации необходимо 
определить ClusterRole (и привязать к пользователю Алисы с помощью ClusterRoleBinding), поскольку авторизация 
требуется на уровне кластера.
  
Определение RBAC

Давайте рассмотрим пример, упомянутый ранее. Допустим, у нас есть pod, который должен проверять состояние выполнения 
pod в пространстве имен "example-namespace". Под идентифицируется как ExampleServiceAccount. Определение pod YAML 
может выглядеть примерно так:   

```commandline
apiVersion: v1
kind: Pod
metadata:
  name: up-checker
  namespace: example-namespace
spec:
  serviceAccountName: ExampleServiceAccount
  containers:
  - name: kubectl
    image: bitnami/kubectl:latest
    command:
  # commands for pod status check logic would go here
```

Затем мы хотим убедиться, что этот pod имеет только разрешения, необходимые для выполнения этой проверки. Чтобы 
сделать это, мы сначала определим роль, выглядящую примерно так:

```commandline
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: up-checker-role
  namespace: example-namespace
rules:
- apiGroups: [""]
  resources: ["pods"]
  verbs: ["get", "list", "watch"]
```

Эта роль позволяет использовать глаголы get, list и watch ТОЛЬКО в подах и ТОЛЬКО в пространстве имен 
example-namespace. Далее нам нужно будет привязать эту роль к пользователю или ServiceAccount. Поскольку наш под 
использует ServiceAccount ExampleServiceAccount, мы хотим привязать этот ServiceAccount к up-checker-role. Для этого 
мы определим RoleBinding следующим образом:

```commandline
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: up-checker-role-binding
  namespace: example-namespace
subjects:
- kind: ServiceAccount
  name: ExampleServiceAccount
  namespace: example-namespace
roleRef:
  kind: Role
  name: up-checker-role
  apiGroup: rbac.authorization.k8s.io
```

Здесь мы сообщаем Kubernetes субъекты (или, в данном случае, один субъект), к которым мы хотим привязать эту роль 
(ServiceAccount ExampleServiceAccount) и к какой роли мы хотели бы привязать этот субъект (up-checker-role). Помните,
что мы можем применить каждую конфигурацию YAML с помощью следующей команды:

Kubectl Применить ЯМЛ
`thm@k8s:~$ kubectl apply -f filename.yaml`
Определение ClusterRole/ClusterRoleBindng почти идентично, за исключением того, что нет необходимости определять 
пространство имен, а «вид» изменится на ClusterRole/ClusterRoleBindng.

### Ответьте на вопросы ниже
Вы определили «Роль». Что вам теперь следует определить, чтобы связать эту роль с личностью?
```commandline
RoleBinding
```
Теперь вы хотите определить разрешения на уровне кластера. Что вы определяете?
```commandline
ClusterRole
```
В каком поле в разделе «правила» вы бы определили действия, которые можно выполнять над ресурсом? (в роли YAML/spec)
```commandline
verbs
```
В каком поле в разделе «правила» вы бы определили, к чему должны применяться эти действия? (в роли YAML/spec)
```commandline
resources
```

## Задание 4
Итак, если вы собираетесь защитить что-либо и следовать лучшим практикам, принципиально важно понимать, как именно к 
этому осуществляется доступ. Между этой комнатой и предварительным условием Cluster Hardening вы накопили достаточно 
знаний, чтобы понять, как осуществляется доступ к кластеру Kubernetes. Эта задача соберет полученные на данный 
момент знания и использует их для объяснения методов доступа к кластеру Kubernetes и задействованных этапов запроса  
API.

значок доступа к кластеру

Доступ к API Kubernetes

Доступ к кластеру Kubernetes осуществляется с помощью API Kubernetes . Это наш канал связи с кластером, и существуют 
различные методы доступа к самому API Kubernetes:

Kubectl — мы уже рассматривали это ранее. Kubectl — это инструмент командной строки Kubernetes. При доступе к 
кластеру вам нужно знать две вещи: местоположение кластера и учетные данные. После настройки kubectl обрабатывает 
поиск и аутентификацию на сервере API , что упрощает выполнение действий на кластере с помощью различных команд 
kubectl. Это наиболее распространенный метод доступа к кластеру Kubernetes ; однако, если вы хотите получить прямой 
доступ к кластеру самостоятельно (используя curl, wget или браузер), есть несколько способов сделать это, которые 
будут рассмотрены далее.

Proxy - Kubectl можно запустить в "режиме прокси" с помощью команды kubectl proxy. Эта команда запустит 
прокси-сервер на порту 8080, который будет пересылать запросы на сервер API Kubernetes . Это рекомендуемый метод для 
прямого доступа к API Kubernetes , поскольку он использует сохраненное местоположение сервера API и проверяет 
подлинность сервера API с помощью самоподписанного сертификата, что означает, что атака "человек посередине" ( MITM )
невозможна.

Auth Token — этот метод напрямую обращается к API Kubernetes, предоставляя HTTP-клиенту местоположение кластера и 
учетные данные. По этой причине он не рекомендуется (так как будет уязвим для атаки MITM ).

Программный - Kubernetes поддерживает программный доступ к API с использованием клиентских библиотек. Он официально 
поддерживает клиентские библиотеки, такие как Python, Java, Javascript, Go, и некоторые библиотеки, поддерживаемые 
сообществом (хотя они не имеют официальной поддержки Kubernetes ).

Этапы запроса API

Это различные методы, которые можно использовать для доступа к API/кластеру Kubernetes. С этого момента разговор 
переходит к тому, как мы контролируем доступ к кластеру. Вам будет приятно узнать, что многое из того, что вы узнали 
до сих пор, было методами контроля доступа к кластеру. Давайте рассмотрим их в контексте, рассмотрев этапы запроса 
API Kubernetes. Когда вы взаимодействуете с API Kubernetes, вы будете просить что-то сделать, будь то получение 
журналов, создание pod или удаление службы. Когда вы выполняете одно из этих действий, вы отправляете запрос в API. 
Этот запрос пройдет несколько этапов, прежде чем будет выполнен. Давайте рассмотрим, что это за этапы:

Аутентификация — Вы тот, за кого себя выдаете?

Аутентификация запроса API может быть выполнена несколькими способами. К ним относятся методы, рассмотренные в 
комнате Cluster Hardening  (рассматриваемой в задачах 4 и 5) , такие как настройка аутентификации клиентского 
сертификата или использование токенов носителя API . Аутентификация также может быть выполнена с использованием 
других плагинов аутентификации, таких как Authenticating Proxy или HTTP basic auth. Другим методом аутентификации 
будут токены ServiceAccount, которые используются для аутентификации Kubernetes ServiceAccount. Можно использовать 
несколько методов аутентификации, и часто бывает так, что используются как минимум два (токены ServiceAccount и 
другой плагин аутентификации для аутентификации пользователя). Запрос проходит этот этап только тогда, когда у него 
есть правильные атрибуты, необходимые для подтверждения личности запрашиваемого.

значок аутентификации

Разрешение — есть ли у вас разрешение делать то, что вы пытаетесь сделать?

После аутентификации личности запрашивающего необходимо определить, разрешено ли этому пользователю/ServiceAccount 
делать этот запрос (например, получать доступ к этому ресурсу). Например, имеет ли пользователь example-user 
достаточные разрешения для удаления pod example-pod. Запрос должен быть авторизован. В Kubernetes есть четыре режима 
авторизации. Один из наиболее часто используемых и наиболее важных для нашего текущего контекста ( лучшие практики 
безопасности Kubernetes ) — это RBAC . Есть еще три режима авторизации:    

Авторизация узла: Как вы помните, в кластере Kubernetes на каждом узле запущен процесс kubelet. Этот процесс 
взаимодействует с API . Этот метод авторизации используется для авторизации запросов, выполняемых процессами kubelet.
Он не предназначен для авторизации пользователей.

ABAC (Attribute Based Access Control) — ABAC похож на RBAC , но вместо предоставления авторизации на основе ролей он 
предоставляет доступ на основе, как вы уже догадались! Атрибутов. Эти атрибуты включают атрибуты пользователя (такие 
как имя, должность, уровень допуска и т. д.), атрибуты ресурса (дата создания, владелец ресурса, группа ресурсов) 
или атрибуты среды (такие как время и место, из которого осуществляется доступ к ресурсу). ABAC допускает очень 
детализированный уровень контроля доступа; например, вы можете разрешить пользователю доступ к ресурсу из одного 
места (офиса), но не из другого (из дома). Однако реализация этого для растущей базы пользователей может быстро 
стать сложной, а поддержание политик ABAC может стать трудным. Это часто упоминается как причина, по которой RBAC 
предпочитают ABAC для организаций: простота его реализации.

Webhook — еще один метод авторизации — делегирование авторизации внешней http-службе (известной как webhook). 
Webhook позволяет пользователю/организации определять собственную логику для авторизации и авторизовать запросы API 
с использованием этой логики. Это полезно для организаций с более сложными требованиями к авторизации или для тех, 
кто хочет доверить принятие решений об авторизации внешней службе (например, Active Directory или LDAP и т. д.). 
Затем webhook отправит ответ на основе результата.
Используя один из вышеперечисленных методов, запрос проверяется на предмет того, имеет ли аутентифицированный 
пользователь право доступа к ресурсам/выполнения запрошенного действия. Перед тем, как запрос будет принят, есть еще 
один этап.

значок авторизации

Контролеры допуска — Прошел ли этот запрос все проверки?

После аутентификации и авторизации запроса следующим этапом запроса API являются контроллеры допуска. Контроллеры 
допуска, рассматриваемые в разделе «Укрепление кластера  » (описанном в Задании 6), — это проверки, выполняемые в 
отношении запроса API. Они могут быть валидирующими (разрешено ли это действие, нарушает ли оно проверку) или 
изменяющими (например, в запросе на создание модуля может потребоваться изменить имя модуля, чтобы оно 
соответствовало пользовательскому соглашению об именовании). Помимо встроенных контроллеров допуска, вы, возможно, 
помните, что можно определять пользовательские проверки. Эти контроллеры допуска запускаются после этапов 
аутентификации и авторизации, и только после прохождения всех проверок контроллеров допуска этот запрос будет 
сохранен.

значок контроллера допуска

Мы проследили API Request на всех его этапах. Когда вас спрашивают, как ограничить доступ к кластеру Kubernetes, вы 
теперь должны быть в состоянии объяснить больше, чем просто «укрепить свой кластер», и обсудить, как осуществляется 
доступ к кластеру и как можно ограничить доступ на каждом этапе. Отличная работа! Ваши навыки DevSecOps растут с 
каждой задачей.

Изображение этапов запроса API

### Ответьте на вопросы ниже
Какой метод доступа к кластеру будет уязвим для атаки MITM?
```commandline
Auth Token
```

На каком этапе запроса API будет задействован RBAC?

```commandline
Authorisation
```

На каком этапе запроса API мы увидим слова «Mutating» и «Validating»? 

```commandline
Admission Controllers
```

На каком этапе запроса API токен ServiceAccount будет использоваться для проверки ServiceAccount?

```commandline
Authentication
```

## Задание 5
С полученными знаниями ваше понимание Kubernetes растет. Более глубокий взгляд на RBAC и Kubernetes ServiceAccounts 
позволил глубже понять доступ к кластеру. Эта задача будет посвящена тому, чтобы выкрикнуть некоторые другие 
примечательные Kubernetes Best Security Practices, набор DO, когда дело касается безопасности K8s. Без лишних слов, 
давайте начнем!

Сканирование изображений 

Давайте начнем с того, что вернемся на шаг назад. Зачем нам Kubernetes в первую очередь? Для развертывания наших 
приложений, верно? Ну, эти приложения создаются с использованием образов. Образ приложения будет содержать все 
необходимое для запуска приложения в контейнере, но что еще он содержит? Сканирование образов — один из способов 
узнать это! Образы обычно состоят из серии команд (или слоев), которые создают каталоги/пользователей, 
копируют/запускают скрипты и устанавливают инструменты/библиотеки. Все это имеет последствия для безопасности:

Инструменты, библиотеки и код, которые мы используем в нашем приложении, могут быть получены из ненадежного 
источника. Это может привести к появлению бэкдоров в коде вашего приложения (преднамеренных или иных), что даст 
злоумышленнику доступ.

Официальные образы контейнеров часто используются в качестве базового образа (и надстраиваются на нем) при создании 
приложения. Например, если вы создаете веб-приложение, вы можете использовать базовый образ Nginx, или если вы 
создаете приложение базы данных, вы можете использовать любой из базовых образов Postgres, Nginx, MongoDB или Redis. 
Эти официальные образы контейнеров часто считаются безопасными, потому что... ну, они "официальные". Однако эти 
официальные образы контейнеров могут содержать уязвимости, и они часто это делают. Конечно, неофициальные образы и 
устаревшие образы также могут представлять проблемы безопасности.

В связи с вышеупомянутыми проблемами безопасности наилучшей практикой безопасности является минимизация поверхности 
атаки в вашем образе путем использования только тех библиотек, которые НЕОБХОДИМЫ приложению, и использования 
наиболее легкого базового образа для его предполагаемого назначения.

значок сканирования изображения

Эти последствия безопасности не следует воспринимать легкомысленно, поскольку уязвимость в образе вашего приложения 
может быть именно тем, что ищет злоумышленник. Злоумышленник может воспользоваться этой уязвимостью и использовать 
ее для взлома контейнера, в котором запущено приложение, и получить доступ к хосту, посеяв хаос в кластере и получив 
доступ к критически важной информации кластера, такой как сертификаты/токены аутентификации API kubelet. Это будет 
серьезным инцидентом безопасности. Вот почему сканирование образов всегда должно быть включено в конвейер CI / CD в 
качестве лучшей практики безопасности.

Инструменты сканирования изображений (например, Snyk ) сканируют используемое изображение по базе данных уязвимостей 
и ищут такие вещи, как жестко закодированные секреты. С помощью шага сканирования изображений вы можете быть 
спокойны, зная, что то, что развертывается в вашем кластере, безопасно.

Значок сканирования изображений в конвейере CI/CD

Модернизация кластера

Поддержание актуальности — это общая лучшая практика безопасности, а не специфичная для Kubernetes . Запуск старой 
версии Kubernetes сопряжен со всеми теми же проблемами безопасности; если злоумышленник обнаружит кластер, 
работающий на узле старой версии, он может знать несколько уязвимостей, которые с тех пор были исправлены. И, 
конечно же, обновление кластера Kubernetes сопряжено с теми же соображениями Stable vs Latest. Стабильные выпуски 
были тщательно и полностью протестированы (и поэтому, как правило, предпочтительны с точки зрения безопасности). 
Однако последняя версия (которая будет проверена внутри компании) будет включать исправления для проблем в 
стабильной версии. В конечном счете, пока вы используете хотя бы стабильную версию, вы следуете лучшим практикам 
безопасности k8s.

Примечание: При выборе версии для обновления (например, последней стабильной версии) вы не можете пропустить 
второстепенные версии. Например, вы не можете обновить свой кластер с версии 1.21 -> 1.23, так как вы пропустите 
второстепенную версию 1.22. Таким образом, если последняя стабильная версия была 1.23, вам придется сделать 1.21 -> 
1.22, затем 1.22 -> 1.23.

Обновление кластера обычно ложится на плечи инженера DevSecOps, или, по крайней мере, инженер DevSecOps будет 
работать вместе с инженером DevOps, чтобы гарантировать, что это сделано. Из-за особенностей управления версиями 
постоянно выпускаются новые версии, и поддержание кластера в актуальном состоянии может стать непростой задачей. 
Из-за этого команды иногда упускают из виду процесс обновления и отстают на несколько версий. Следуя лучшим 
практикам безопасности k8s, ваша команда будет регулярно назначать вам тикеты для обновления кластера. Обычно это 
нужно делать в следующем порядке:

Обновление (основного) узла плоскости управления (обновление компонентов в следующем порядке: etcd, kube-apiserver, 
kube-controller-manager, kube-scheduler, cloud controller manager)
Если в кластере есть дополнительные узлы плоскости управления, обновите их.
Обновление рабочих узлов
Обновите клиенты, такие как kubectl 
Внесите изменения в манифесты и ресурсы на основе изменений в новой версии (например, если некоторые из ваших 
ресурсов используют устаревшую функцию, обновите их, чтобы использовать замену)
значок управления версиями

Вот некоторые моменты, которые следует учитывать при обновлении кластера: 
- Одновременно можно обновить более одного рабочего узла.
- При обновлении кластера Kubernetes затрагиваются только внутренние компоненты. Другими словами, ваши приложения и 
  рабочие нагрузки должны оставаться нетронутыми и невредимыми. Однако всегда полезно сделать резервную копию 
  важных компонентов перед обновлением, на всякий случай. 
- Необходимо очистить узлы; таким образом модули будут исключены из кластера, а рабочие нагрузки не изменятся. 
- Обновление кластера часто сопровождается простоем. В зависимости от важности рабочих нагрузок, выполняемых в 
  кластере, это может привести к простою внешних служб (внутренних или внешних). По этой причине следует отправить 
  уведомление о простое с прикрепленным окном обслуживания затронутым сторонам.
Запуск  некорневого контейнера

Если в этом нет производственной необходимости (которой почти никогда не бывает), контейнер следует запускать как 
не-root-пользователь. Это связано с тем, что если, как уже было сказано, ваш образ имеет уязвимости и злоумышленник 
получает доступ к контейнеру, вы значительно облегчаете ему жизнь, если у этого контейнера есть root-привилегии.

значок некорневого контейнера

Это можно сделать при определении образа. Однако некоторые спецификации в YAML-конфигурации вашего пода могут 
переопределить это. Как инженер DevSecOps, вы, вероятно, будете просматривать свою долю конфигураций ресурсов. Если 
вы видите в спецификации в разделе «securityContext» такие значения, как (где UID имеет привилегии root) или , ваши 
тревожные колокольчики должны зазвонить. Вам следует убедиться, что это не требуется (что, опять же, почти никогда 
не будет обязательным), и изменить спецификацию пода, чтобы она выглядела примерно так:runAsUser: 
<UID>allowPrivilegeEscalation: true

Запретить повышение привилегий
```commandline
apiVersion: v1
kind: Pod
metadata:
  name: example-pod
  Namespace: example-namespace
spec:
  securityContext: 
      allowPrivilegeEscalation: false
```

Пользователь без прав root
```commandline
apiVersion: v1
kind: Pod
metadata:
  name: example-pod
  Namespace: example-namespace
spec:
  securityContext: 
      runAsUser:
```

Безопасный и т.д.

Как вы помните, etcd — это хранилище ключей и значений Kubernetes, в котором хранятся данные кластера. Вы слышите 
«данные кластера хранятся», злоумышленник слышит «золотая жила», и он прав. Изменения, внесенные в кластер (например,
удаление пода), затем отражаются в хранилище etcd. Однако это работает в обоих направлениях: если бы было внесено 
изменение в etcd (например, новая запись пода), это изменение отразилось бы в кластере. Представьте теперь, что 
злоумышленник получает доступ к etcd. Внезапно они не так обеспокоены поиском способов получения доступа API к 
кластеру, но они нашли способ вообще обойти API . Получение злоумышленником полного доступа к etcd — это одно из 
худших событий, которые могут произойти в кластере Kubernetes , поскольку это по сути неограниченный доступ.

значок защищенного etcd

Это подводит нас к некоторым лучшим практикам безопасности, которые следует соблюдать для защиты хранилища etcd: 
- Etcd можно изолировать от кластера и запускать отдельно, устанавливая расстояние между кластером и хранилищем etcd 
  в случае взлома кластера. 
- Поместите etcd за брандмауэр, обеспечив возможность доступа к нему только через API (пройдя соответствующие этапы 
  запроса API ).
- Зашифруйте все данные etcd, это будет сделано с использованием встроенных механизмов шифрования в состоянии покоя 
  или поставщика шифрования. Таким образом, если злоумышленник сможет получить доступ к etcd, он не сможет 
  расшифровать содержимое. 
### Ответьте на вопросы ниже
Какую наилучшую практику безопасности следует внедрить в конвейер CI/CD?
```commandline
Image Scanning
```
Какое значение в конфигурации следует установить как «false», чтобы гарантировать невозможность повышения привилегий контейнера?
```commandline
allowPrivilegeEscalation
```
Чтобы обеспечить безопасность etcd, его следует изолировать, поместив за брандмауэр и?
```commandline
encrypted
```
Сколько обновлений кластера вам придется сделать, чтобы перейти с версии 1.21 на 1.25?
```commandline
4
```

## Задание 6
Это еще одна неделя для вас в Kubernetes Laboratories. Ваше путешествие DevSecOps продолжается еще одним 
стендап-совещанием. Всем, включая вас, выдается билет! Билет, который вам был назначен, — «проверить конфигурацию 
RBAC для проверки тестовых камер». Хорошо, похоже, вы сможете применить свои знания о лучших практиках безопасности 
Kubernetes. Давайте сначала загрузим машину, нажав зеленую кнопку «запустить машину». Машина запустится в режиме 
разделенного экрана . Если виртуальная машина не видна, используйте синюю кнопку «Показать разделенный вид » в 
верхней части страницы. Дайте ей немного времени на загрузку, и вы сможете начать свое расследование DevSecOps!

Для начала загрузим кластер с помощью команды (подождите пару минут, пока кластер загрузится).

Запуск Minikube
`thm@k8s:~$ minikube start`
Кластер запущен. Давайте взглянем на пространство имен "test-chamber"; именно здесь мы будем просматривать 
конфигурацию. Используйте эту команду, чтобы увидеть, что запущено в этом пространстве имен (pod-status-checker 
может потребоваться минута или две, чтобы войти в состояние "running"):

Получение стручков
`thm@k8s:~$ kubectl get pods -n test-chambers`
Мы видим три работающих пода test-chamber, а также «pod-status-checker», именно для этого чекера в тикете говорится, 
что мы должны проверить конфигурацию RBAC. В тикете подробно описывается цель этого чекера, и он просто перечисляет 
статус подов в «test-chamber» и регистрирует его. Давайте получим некоторую информацию о поде с помощью команды. 
Используйте свои навыки DevSecOps , чтобы проанализировать эту информацию о поде и посмотреть, сможете ли вы найти 
какие-либо красные флаги:

Получение информации о Pod
`thm@k8s:~$ kubectl describe pod -n test-chambers pod-status-checker`
Красный флаг, о котором идет речь, был в первых нескольких строках. Мы видим, что этот pod настроен на использование 
ServiceAccount "pod-admin". Похоже, что этот pod работает с более высокими разрешениями, чем требуется. В тикете 
также подробно описывается текущая конфигурация RBAC для этого pod-status-checker. Он сообщает нам, что pod работает 
с использованием pod-admin ServiceAccount (который мы теперь знаем), с использованием "pod-admin-role" ClusterRole и 
привязан к pod-admin ServiceAccount с использованием pod-admin-binding ClusterRoleBinding. Хорошо, ваши тревожные 
колокольчики DevSecOps также должны здесь зазвонить. Учитывая область действия функции этого pod, ему нужен доступ 
только к одному пространству имен, а не ко всему кластеру. Для этой конфигурации RBAC использование Role и 
Rolebinding имеет больше смысла. Давайте рассмотрим ClusterRole и ClusterRoleBinding с помощью следующих команд:

Описание роли
`thm@k8s:~$ kubectl describe clusterrole -n test-chambers pod-admin-role`
Описание ролиBinding
`thm@k8s:~$ kubectl describe clusterrolebinding -n test-chambers pod-admin-binding`
Наибольший интерес для нас представляют следующие результаты: 

Вывод глаголов
```commandline
thm@k8s:~$ kubectl describe clusterrole -n test-chambers pod-admin-role
Name:         pod-admin-role
Labels:       
Annotations:  
PolicyRule:
  Resources  Non-Resource URLs  Resource Names  Verbs
  ---------  -----------------  --------------  -----
  pods       []                 []              [get list create delete]
  secrets    []                 []              [get list create delete]
  services   []                 []              [get list create delete]

```
Мы видим, что эта роль (и поскольку роль привязана к ServiceAccount, используемому подом, то и под) имеет доступ к 
получению, перечислению, созданию и удалению подов, секретов и служб. Это, как мы и подозревали, не соответствует 
лучшим практикам безопасности Kubernetes. Под должен иметь доступ только к ресурсам пода и иметь возможность 
«получать» и «перечислять» их.

Ваша работа? Перенастройте RBAC вокруг этого модуля, выполнив следующие задачи:

1) Создайте учетную запись службы под названием «pod-checker»
2) Создайте роль с именем «pod-checker-role», которая может «получать» и «перечислять» только ресурсы «pod».
3) Создайте RoleBinding, который связывает «pod-checker-role» с ServiceAccount «pod-checker»
4) Удалить модуль  pod-status-checker 
5) Внесите изменения в конфигурацию ~/Documents/pod-config/pod-checker.yaml, чтобы pod использовал ServiceAccount 
   pod-checker вместо pod-admin, затем примените эту конфигурацию Если вы выполнили эти шаги, то вы сделали это! Еще 
   один тикет закрыт, и вы на пути к прохождению испытательного срока здесь, в Kubernetes Laboratories. Чтобы 
   выполнить задачу,  выполните  следующую команду:



Kubectl Опишите роль
`thm@k8s:~$ kubectl describe role pod-checker-role -n test-chambers`

Вставьте вывод в этот кодировщик base64; закодированный вывод и есть ответ!
### Ответьте на вопросы ниже
Какова закодированная роль?
```commandline
TmFtZTogICAgICAgICBwb2QtY2hlY2tlci1yb2xlCkxhYmVsczogICAgICAgPG5vbmU+CkFubm90YXRpb25zOiAgPG5vbmU+ClBvbGljeVJ1bGU6CiAgUmVzb3VyY2VzICBOb24tUmVzb3VyY2UgVVJMcyAgUmVzb3VyY2UgTmFtZXMgIFZlcmJzCiAgLS0tLS0tLS0tICAtLS0tLS0tLS0tLS0tLS0tLSAgLS0tLS0tLS0tLS0tLS0gIC0tLS0tCiAgcG9kcyAgICAgICBbXSAgICAgICAgICAgICAgICAgW10gICAgICAgICAgICAgIFtnZXQgbGlzdF0=
```

## Задание 7
Пройдя этот урок, вы продолжили свой путь DevSecOps, попутно изучив некоторые лучшие практики безопасности 
Kubernetes . Медленно, но верно ваши знания об инструменте и архитектуре кластера начнут поддерживать ваши знания  о 
практиках безопасности, так что вы будете знать не только, что внедрять, но и почему. Прежде чем закончить эту 
комнату, давайте рассмотрим, что мы рассмотрели:

Kubernetes ServiceAccounts можно использовать для реализации контроля доступа. В контексте безопасности эти 
ServiceAccounts привязывают приложение/pod/сервис к цифровой идентификации, чтобы доступ можно было ограничить на 
основе этой идентификации.

Как упоминалось выше, RBAC — это один из методов ограничения разрешений на основе личности. RBAC следует настраивать 
с учетом принципа наименьших привилегий в кластере, учитывая вариант использования каждого пользователя/приложения 
перед назначением роли или роли кластера.

При выполнении API- запроса он проходит следующие этапы запроса перед выполнением:  Аутентификация -> Авторизация -> 
Контроллеры допуска.

Уязвимости в образе, который запускает ваше приложение, могут привести к взлому вашего кластера Kubernetes. Чтобы 
избежать этого, следует внедрить сканирование образов в конвейер CI / CD.

Обновление кластера Kubernetes  гарантирует, что кластер будет работать с последними исправлениями и функциями. 

Чтобы ограничить возможности злоумышленника по повышению привилегий в случае получения им доступа к контейнеру,  
контейнеры должны работать без привилегий root.

Получение доступа к etcd злоумышленником станет катастрофой. По этой причине etcd следует изолировать от кластера, 
защитить брандмауэром и зашифровать. 
На этом эта комната завершена!  С этими знаниями ваш мозг теперь является более ценным ресурсом для таких компаний,
как Kubernetes Laboratories, который можно защитить от неправильных конфигураций и злоумышленников.

### Ответьте на вопросы ниже
Все готово!
```commandline
Ответ не нужен
```
[>> вернуться на главную страницу](https://github.com/BEPb/tryhackme/blob/master/README.md)