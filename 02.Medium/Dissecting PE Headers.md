[>> вернуться на главную страницу](https://github.com/BEPb/tryhackme/blob/master/README.md)

# Комната [Dissecting PE Headers](https://tryhackme.com/r/room/dissectingpeheaders) 

Всего 9 заданий:
## Задание 1
В операционной системе Windows вы, возможно, часто видели файлы с расширением .exe. .exe Здесь расширение означает 
исполняемый. Как следует из названия, исполняемый файл содержит код, который может быть выполнен. Поэтому все, что 
необходимо запустить в операционной системе Windows, выполняется с помощью исполняемого файла, также называемого 
переносимым исполняемым файлом (PE-файлом), поскольку его можно запустить в любой системе Windows. PE-файл — это 
структура данных Common Object File Format (COFF). COFF состоит из файлов Windows PE, DLL, общих объектов в Linux и 
файлов ELF. В этой комнате мы рассмотрим только файлы Windows PE.

Учитывая эти базовые знания, становится важным понимать PE-файл, чтобы изучить анализ вредоносных программ. Эта 
комната познакомит нас со следующими концепциями:
- Понимание различных заголовков в PE-файле
- Учимся читать заголовки PE
- Определить упакованные исполняемые файлы
- Используйте информацию из заголовков PE для анализа вредоносного ПО
Прежде чем приступить к изучению этой комнаты, рекомендуется пройти курс «Введение в анализ вредоносных программ».

### Ответьте на вопросы ниже
Пройдите раздел «Введение в анализ вредоносных программ».
```commandline
Ответ не нужен
```

## Задание 2
На диске исполняемый файл PE выглядит так же, как и любая другая форма цифровых данных, т. е. комбинация битов. Если 
мы откроем файл PE в шестнадцатеричном редакторе, мы увидим случайный набор шестнадцатеричных символов. Этот набор 
шестнадцатеричных символов — инструкции, необходимые ОС Windows для выполнения этого двоичного файла.

Файл PE, отображаемый в Hex-редакторе

В предстоящих задачах мы попытаемся разобраться в шестнадцатеричных числах, которые мы видим на снимке экрана выше, 
и описать их так, как их понимает Windows. Мы также рассмотрим, как использовать эту информацию для анализа 
вредоносных программ. Мы воспользуемся утилитой, присутствующей в прикрепленной виртуальной машине wxHexEditor 
следующей задачи, для выполнения этой задачи.

Просматривая файл в Hex-редакторе, мы замечаем, что ручная интерпретация всех этих данных может стать слишком 
утомительной. Поэтому мы воспользуемся инструментом pe-tree в присоединенной виртуальной машине, который поможет нам 
проанализировать заголовок PE. Вот что мы видим, когда открываем файл PE с помощью pe-tree.

Файл PE, показанный утилитой pe-tree

На правой панели здесь мы видим некоторые выпадающие меню древовидной структуры. Левая панель — это просто ярлыки 
для выпадающих меню правой панели. Некоторые важные заголовки, которые мы обсудим в этой комнате:Изображение 
структуры заголовка PE-файла
```commandline
IMAGE_DOS_HEADER
IMAGE_NT_HEADERS
ЗАГОЛОВОК_ФАЙЛА
ДОПОЛНИТЕЛЬНЫЙ_ЗАГОЛОВОК
ИЗОБРАЖЕНИЕ_ЗАГОЛОВОК_РАЗДЕЛА
IMPORT_DESCRIPTOR_ИЗОБРАЖЕНИЯ
```
Все эти заголовки имеют тип данных STRUCT. Структура — это определяемый пользователем тип данных, который 
объединяет несколько различных типов элементов данных в одной переменной. Поскольку он определяется пользователем, 
нам нужно просмотреть документацию, чтобы понять тип для каждой переменной STRUCT. Документацию для каждого 
заголовка можно найти на MSDN, где вы можете найти типы данных различных полей внутри этих заголовков.

Пожалуйста, помните, что пока мы используем инструменты, упомянутые ранее, различные другие инструменты выполняют 
схожие задачи. Однако цель состоит не в том, чтобы узнать об инструментах, а в том, чтобы изучить формат PE, чтобы 
мы могли выполнить тот же анализ, используя любые другие инструменты, с которыми мы столкнемся, предоставляя ту же 
функциональность.

Теперь давайте перейдем к следующим задачам и изучим каждую из этих частей PE- файла.

### Ответьте на вопросы ниже
Какой тип данных имеют заголовки PE?
```commandline
STRUCT
```

## Задание 3
Для этой задачи нам понадобится использовать присоединенную виртуальную машину. Для этого нажмите кнопку «Запустить 
машину» в правом верхнем углу этой задачи, чтобы запустить присоединенную машину. Машина запустится в режиме 
разделенного экрана. Если машина не видна, используйте синюю кнопку «Показать разделенный вид» в правом верхнем углу 
страницы. В качестве альтернативы вы можете войти в машину, используя следующие учетные данные:

Имя пользователя: ubuntu
Пароль: 123456

После запуска машины мы можем обнаружить, что на рабочем столе машины есть каталог с именем Samples. В этом каталоге 
мы найдем несколько PE-файлов. Давайте откроем файл с именем redline в Hex-редакторе, чтобы посмотреть, как он 
выглядит. Мы можем использовать wxHexEditor утилиту в прикрепленной виртуальной машине, чтобы открыть требуемый файл. 
Чтобы открыть wxHexEditor, нажмите меню в верхнем левом углу виртуальной машины и найдите wxHexEditor, как показано 
на следующем снимке экрана.

Поиск Remnux, показывающий wxHexEditor

Вот как будет выглядеть отредактированный PE в шестнадцатеричном редакторе.

Файл PE, отображаемый в Hex-редакторе

Поскольку это кажется немного сложным для понимания, давайте воспользуемся помощью утилиты pe-tree, чтобы увидеть, 
как выглядит заголовок PE. Если мы запустим следующую команду в терминале в подключенной виртуальной машине, она 
откроет файл redline PE в утилите. pe-tree
`pe-tree Desktop/Samples/redline`
Обратите внимание, что утилита pe-tree откроется примерно через 8 минут. В это время вы можете продолжить чтение 
текста и вернуться, когда он откроется. Вот как pe-tree будет выглядеть вывод, когда мы откроем утилиту redline.

Файл PE, как он отображается в утилите pe-tree

На снимке экрана выше показана некоторая базовая информация о PE-файле в правой панели. Мы видим размер, хэши, 
энтропию, архитектуру и дату компиляции PE-файла. Эта информация не извлекается напрямую из заголовка; вместо этого 
она вычисляется или извлекается из разных частей заголовка, как мы увидим позже. Заголовок начинается под этой 
информацией, с заголовка IMAGE_DOS_HEADER. Давайте углубимся в это и узнаем, какую информацию он содержит.

IMAGE_DOS_HEADER:
IMAGE_DOS_HEADER состоит из первых 64 байт PE- файла. Ниже мы проанализируем некоторую ценную информацию, найденную 
в IMAGE_DOS_HEADER. На снимке экрана ниже IMAGE_DOS_HEADER выделен в Hex Editor.

Файл PE в шестнадцатеричном редакторе с выделенным IMAGE_DOS_HEADER

На скриншоте выше из Hex Editor обратите внимание на первые два байта, которые говорят 4D 5A. Они преобразуются в  
MZ символы ASCII, как показано на правой панели Hex Editor. Так что же означают эти символы?

Символы MZ обозначают инициалы Марка Збиковски, одного из архитекторов Microsoft, создавших формат файла MS-DOS. 
Символы MZ являются идентификатором формата Portable Executable. Когда эти два байта присутствуют в начале файла, ОС 
Windows считает его файлом формата Portable Executable.

Вот как это будет выглядеть, когда мы развернем выпадающее меню IMAGE_DOS_HEADER:

IMAGE_DOS_HEADER, как он отображается в утилите pe-tree

Обратите внимание на первую запись в раскрывающемся меню IMAGE_DOS_HEADER. Она говорит e_magicи имеет значение 
0x5a4d MZ. Это то же самое, что мы видели в Hex Editor выше, но порядок байтов обратный из-за порядка байтов . 
Архитектура Intel x86 использует формат little-endian, в то время как ARM использует формат big-endian.

Последнее значение в IMAGE_DOS_HEADER называется e_lfanew. На приведенном выше снимке экрана оно имеет значение 
0x000000d8. Это обозначает адрес, с которого начинаются IMAGE_NT_HEADERS. Следовательно, в этом PE-файле 
IMAGE_NT_HEADERS  начинаются  с адреса 0x000000d8. Мы можем видеть это значение выделенным в шестнадцатеричном 
редакторе ниже.

Hex-редактор, отображающий адрес IMAGE_NT_HEADER как выделенный текст

Мы должны помнить, что порядок байтов меняется, когда мы сравниваем те, которые сообщает утилита pe-tree, и те, 
которые мы видим в шестнадцатеричном редакторе, из-за  порядка байтов.

IMAGE_DOS_HEADER обычно не используется в дополнение к этим полям, особенно во время реверс-инжиниринга вредоносных 
программ. Единственная причина, по которой он там есть, — это обратная совместимость между MS- DOS и Windows.

DOS_STUB:
В утилите pe-tree мы видим, что следующее выпадающее меню после IMAGE_DOS_HEADER — это DOS STUB. Давайте развернем 
его и посмотрим, что мы там найдем.

DOS-STUB, как он виден в утилите pe-tree

DOS STUB содержит сообщение, которое мы также видим в Hex Editor , как показано на снимке экрана ниже.  Обратите 
внимание, что размер, хэши и энтропия, показанные здесь pe-tree, не связаны с PE- файлом; вместо этого они относятся 
к конкретному разделу, который мы анализируем. Эти значения рассчитываются на основе данных в определенном заголовке 
и не включены.!This program cannot be run in DOS mode

Значение размера обозначает размер раздела в байтах. Затем мы видим различные хэши для раздела. Мы узнали о хэшах в 
комнате Введение в анализ вредоносных программ . Энтропия — это количество случайности, обнаруженное в данных. Чем 
выше значение энтропии, тем более случайны данные. Мы узнаем о полезности энтропии, когда узнаем больше об анализе 
вредоносных программ.

DOS-STUB выделен в шестнадцатеричном редакторе

DOS STUB — это небольшой фрагмент кода, который запускается только в том случае, если PE- файл несовместим с 
системой, на которой он запущен. Он отображает сообщение, упомянутое выше. Например, поскольку этот PE- файл, 
который мы рассматриваем, является исполняемым файлом Windows, если он запущен в MS-DOS, PE- файл завершит работу 
после отображения сообщения в DOS STUB.

### Ответьте на вопросы ниже
Сколько байт содержится в IMAGE_DOS_HEADER?
```commandline
64
```
Что означает MZ?
```commandline
Mark Zbikowski
```
В какой переменной IMAGE_DOS_HEADER сохранен адрес IMAGE_NT_HEADERS?
```commandline
e_lfanew
```
В присоединенной виртуальной машине откройте PE-файл Desktop/Samples/zmsuz3pinwl в pe-tree. Каков адрес 
IMAGE_NT_HEADERS для этого PE-файла?
```commandline
0x000000f8
```

## Задание 4
Остальная часть комнаты будет посвящена различным частям IMAGE_NT_HEADERS. Подробности IMAGE_NT_HEADERS можно найти 
в документации Microsoft . Этот заголовок содержит большую часть важной информации, связанной с PE- файлом. В 
pe-tree IMAGE_NT_HEADERS выглядит следующим образом:

IMAGE_NT_HEADERS, как показано в утилите pe-tree

NT_ЗАГОЛОВКИ:
Прежде чем углубляться в детали NT_HEADERS, давайте сделаем обзор NT_HEADERS. NT_HEADERS состоят из следующего:

Подпись
ЗАГОЛОВОК_ФАЙЛА
ДОПОЛНИТЕЛЬНЫЙ_ЗАГОЛОВОК
В этой задаче мы рассмотрим Signature и FILE_HEADER, а в следующей задаче — OPTIONAL_HEADER.

Поле подписи выделено в утилите pe-tree

Начальный адрес IMAGE_NT_HEADERS находится в e_lfanew из IMAGE_DOS_HEADER. В двоичном файле redline мы увидели, что 
этот адрес был  0x000000D8. Итак, давайте начнем с перехода к этому смещению и посмотрим, что мы там найдем. Мы 
можем сделать это, нажав  Ctrl+G в окне Hex Editor или перейдя в Edit>Go to offset из GUI.

ПЕРЕЙТИ в меню «Смещение» в шестнадцатеричном редакторе

Для получения правильных результатов нам нужно убедиться, что выбрана  From beginning опция  Type of branch внизу и 
установлен тип данных Hex.

Подпись:
Первые 4 байта NT_HEADERS состоят из подписи. Мы можем видеть это как байты 50 45 00 00в Hex или символы PEв ASCII, 
как показано в редакторе Hex.

Подпись, как она отображается в шестнадцатеричном редакторе, в выделенном тексте

Подпись обозначает начало NT_HEADER. Помимо подписи, NT_HEADER содержит FILE_HEADER и IMAGE_OPTIONAL_HEADER.

ЗАГОЛОВОК_ФАЙЛА:
FILE_HEADER содержит некоторую важную информацию. Следующий снимок экрана показывает FILE_HEADER, как показано в утилите pe-tree.

FILE_HEADER, как он отображается в утилите pe-tree

 Как видно на снимке экрана выше, FILE_HEADER имеет следующие поля:

- Machine:  В этом поле упоминается тип архитектуры, для которой написан PE- файл. В приведенном выше примере мы 
видим, что архитектура — i386, что означает, что этот PE- файл совместим с 32-битной архитектурой Intel.
- NumberOfSections:  PE - файл содержит различные разделы, в которых хранится код, переменные и другие ресурсы. Это 
  поле IMAGE_FILE_HEADER указывает количество разделов в PE- файле. В нашем случае PE- файл имеет пять разделов. Мы узнаем о разделах позже в этой комнате.
- TimeDateStamp:  это поле содержит время и дату двоичной компиляции. 
- PointerToSymbolTable и NumberOfSymbols:  Эти поля обычно не связаны с PE -файлами. Вместо этого они здесь из-за 
  заголовков COFF-файлов.
- SizeOfOptionalHeader:  Это поле содержит размер необязательного заголовка, о котором мы узнаем в следующей задаче. 
  В нашем случае размер составляет 224 байта. 
- Характеристики:  Это еще одно критическое поле. В этом поле упоминаются различные характеристики PE- файла. В нашем 
  случае это поле сообщает нам, что PE- файл имеет удаленную информацию о перемещении, номера строк и информацию о локальных символах. Это исполняемый образ, совместимый с 32-разрядной машиной.
Пока мы смотрели на FILE_HEADER с помощью утилиты pe-tree, мы видим, что шестнадцатеричные значения для каждого поля также отображаются в утилите pe-tree. Можете ли вы посмотреть на редактор Hex и найти, где находится каждое значение?

FILE_HEADER, как он отображается в шестнадцатеричном редакторе, в выделенном тексте

Мы ведь сейчас начинаем учиться читать Hex, не так ли? Чтобы узнать больше о FILE_HEADER, вы можете ознакомиться с документацией Microsoft . 

### Ответьте на вопросы ниже
В прикрепленной виртуальной машине есть файл Desktop\Samples\zmsuz3pinwl. Откройте этот файл в pe-tree. Этот PE-файл скомпилирован для 32-битной машины или для 64-битной машины?
```commandline
32-bit machine
```
Каков TimeDateStamp этого файла?
```commandline
0x62289d45 Wed Mar  9 12:27:49 2022 UTC
```

## Задание 5
OPTIONAL_HEADER также является частью NT_HEADERS. Он содержит часть наиболее важной информации, присутствующей в 
заголовках PE. Давайте посмотрим, как это выглядит в утилите pe-tree.

OPTIONAL_HEADER, как он виден в утилите pe-tree

В Hex-редакторе OPTIONAL_HEADER начинается сразу после конца FILE_HEADER. Ниже вы можете увидеть начало 
OPTIONAL_HEADER двоичного файла redline в Hex-редакторе.

Начало OPTIONAL_HEADER, как оно отображается в шестнадцатеричном редакторе, в выделенном тексте

Давайте узнаем о некоторых важных полях в OPTIONAL_HEADER.

- Magic:  Magic-число сообщает, является ли файл PE 32-битным или 64-битным приложением. Если значение равно 0x010B, 
оно обозначает 32-битное приложение; если значение равно 0x020B, оно представляет 64-битное приложение. На приведенном выше снимке экрана Hex Editor показаны выделенные байты, которые показывают magic загруженного файла PE . Поскольку значение равно 0x010B, оно показывает, что это 32-битное приложение.
- AddressOfEntryPoint:  Это поле имеет значение с точки зрения анализа вредоносного ПО/обратной разработки. Это адрес,
  с которого Windows начнет выполнение. Другими словами, первая инструкция, которая должна быть выполнена, находится по этому адресу. Это относительный виртуальный адрес (RVA), то есть он находится со смещением относительно базового адреса изображения (ImageBase) после загрузки в память.
- BaseOfCode и BaseOfData:  это адреса разделов кода и данных соответственно относительно ImageBase.
- ImageBase:  ImageBase — это предпочтительный адрес загрузки PE-файла в памяти. Обычно ImageBase для .exe-файлов — 
  0x00400000, что также относится к нашему PE-файлу. Поскольку Windows не может загрузить все PE- файлы по этому предпочтительному адресу, некоторые перемещения выполняются при загрузке файла в память. Затем эти перемещения выполняются относительно ImageBase.
- Подсистема:  Это представляет собой подсистему, необходимую для запуска образа. Подсистема может быть собственной 
  Windows, GUI (графический пользовательский интерфейс), CUI (интерфейс командной строки) или какой-либо другой подсистемой. На снимке экрана выше из утилиты pe-tree показано, что подсистема — 0x0002, представляющая подсистему Windows GUI. Полный список можно найти в документации Microsoft .
- DataDirectory:  DataDirectory — это структура, которая содержит информацию об импорте и экспорте PE -файла 
  (называется Import Address Table и Export Address Table). Эта информация удобна, поскольку дает представление о том, что PE- файл может пытаться сделать. Мы подробнее остановимся на информации об импорте позже в этой комнате.
Хотя в OPTIONAL_HEADER есть больше информации, мы не будем вдаваться в них в этом зале.  Если вы хотите узнать 
  больше о OPTIONAL_HEADER, вы можете ознакомиться с документацией Microsoft об этом заголовке.

### Ответьте на вопросы ниже
Какая переменная из OPTIONAL_HEADER указывает, является ли файл 32- или 64-разрядным приложением?
```commandline
Magic
```
Какое значение Magic указывает на то, что файл является 64-разрядным приложением?
```commandline
0x020B
```
Какая подсистема у файла  Desktop\Samples\zmsuz3pinwl?
```commandline
0x0003 WINDOWS_CUI
```

## Задание 6
Данные, необходимые PE- файлу для выполнения своих функций, такие как код, значки, изображения, элементы 
пользовательского интерфейса и т. д., хранятся в разных разделах. Информацию об этих разделах можно найти в 
IMAGE_SECTION_HEADER. В утилите pe-tree IMAGE_SECTION_HEADER отображается для каждого отдельного раздела, как 
показано на снимке экрана ниже.

IMAGE_SECTION_HEADER, как показано в утилите pe-tree, с также расширенным разделом .text

Как мы видим, IMAGE_SECTION_HEADER имеет различные разделы, а именно .text, .rdata, .data, .ndataи .rsrc. Прежде чем 
перейти к информации, представленной в заголовке каждого раздела, давайте узнаем о часто встречающихся разделах в 
PE- файле. 

.text:  Раздел .text обычно является разделом, содержащим исполняемый код для приложения. Мы видим выше, что Характеристики для этого раздела включают CODE, EXECUTE и READ, что означает, что этот раздел содержит исполняемый код, который можно читать, но нельзя записывать.
.data:  Этот раздел содержит инициализированные данные приложения. Он имеет разрешения READ/WRITE, но не имеет разрешений EXECUTE.
. rdata/.idata:  Эти разделы часто содержат информацию об импорте файла PE . Информация об импорте помогает файлу PE импортировать функции из других файлов или API Windows .
.ndata:  Раздел .ndata содержит неинициализированные данные.
.reloc:  Этот раздел содержит информацию о перемещении PE- файла.
.rsrc:  раздел ресурсов содержит значки, изображения и другие ресурсы, необходимые для пользовательского интерфейса приложения.
Теперь, когда мы знаем, какие типы разделов обычно встречаются в PE-файле, давайте посмотрим, какую важную информацию содержат заголовки каждого раздела:

VirtualAddress:  в этом поле указывается относительный виртуальный адрес (RVA) данного раздела в памяти.
VirtualSize:  в этом поле указывается размер раздела после загрузки в память.
SizeOfRawData:  это поле представляет размер раздела, сохраненный на диске дозагрузки PE- файла в память.
Характеристики:  Поле характеристик сообщает нам разрешения, которые имеет раздел. Например, имеет ли раздел разрешения READ, разрешения WRITE или разрешения EXECUTE.
### Ответьте на вопросы ниже
Сколько разделов в файле Desktop\Samples\zmsuz3pinwl?
```commandline
7
```
Каковы характеристики раздела .rsrc файла  Desktop\Samples\zmsuz3pinwl?
```commandline
0xe0000040 INITIALIZED_DATA | EXECUTE | READ | WRITE
```

## Задание 7
Файлы PE не содержат весь код, необходимый для выполнения их функций. В операционной системе Windows файлы PE используют код из API Windows для выполнения многих функций. Структура IMAGE_IMPORT_DESCRIPTOR содержит информацию о различных API Windows, которые загружает файл PE при выполнении. Эта информация полезна для определения потенциальной активности, которую может выполнять файл PE . Например, если файл PE импортирует API CreateFile , это указывает на то, что он может создать файл при выполнении.

Вот как выглядит IMAGE_IMPORT_DESCRIPTOR в утилите pe-tree.

IMAGE_IMPORT_DESCRIPTOR, как показано с помощью утилиты pe-tree

Здесь мы видим, что рассматриваемый нами PE-файл импортирует функции из ADVAPI32.dll, SHELL32.dll, ole32.dll, COMCTL32.dll и USER32.dll. Эти файлы представляют собой динамически подключаемые библиотеки, которые экспортируют функции Windows или API для других PE-файлов. На приведенном выше снимке экрана показано, что PE-файл импортирует некоторые функции, которые выполняют некоторые действия с реестром. Чтобы узнать больше о том, что делает эта функция, мы можем ознакомиться с документацией Microsoft. Например, по этой ссылке есть подробности о функции RegCreateKeyExW.

На скриншоте выше мы видим значения OriginalFirstThunk и FirstThunk. Операционная система использует эти значения для построения таблицы адресов импорта (IAT) PE- файла. Мы узнаем больше об этих значениях в следующих комнатах.

Изучая функции импорта PE- файла, мы можем определить некоторые действия, которые может выполнять PE- файл.

Импорт PE-файла, как показано в утилите pe-tree, с выделением API WriteFile, CreateProcessW и CreateDirectoryW

Возьмем в качестве примера двоичный файл redline из присоединенной виртуальной машины . Его IMAGE_IMPORT_DESCRIPTOR импортирует примечательные функции, такие как CreateProcessW, CreateDirectoryW и WriteFile из kernel32.dll. Это подразумевает, что этот PE- файл намеревается создать процесс, создать каталог и записать некоторые данные в файл. Аналогично, изучая остальной импорт, мы можем потенциально определить другие действия, которые PE- файл намеревается выполнить.

### Ответьте на вопросы ниже
Файл PE Desktop\Samples\redline импортирует функцию CreateWindowExW. Из какого файла dll он импортирует эту функцию?
```commandline
User32.dll
```

## Задание 8
Поскольку информацию из PE-файла можно легко извлечь с помощью Hex-редактора или такого инструмента, как pe-tree, он становится нежелательным для людей, которые не хотят, чтобы их код был подвергнут реверс-инжинирингу. Вот тут-то и появляются упаковщики. Упаковщик — это инструмент для обфускации данных в PE-файле, чтобы их нельзя было прочитать без распаковки. Проще говоря, упаковщики упаковывают PE-файл в слой обфускации, чтобы избежать реверс-инжиниринга и сделать статический анализ PE-файла бесполезным. Когда PE-файл выполняется , он запускает процедуру распаковки для извлечения исходного кода, а затем выполняет его. Разработчики легитимного программного обеспечения используют упаковку для решения проблем пиратства, а авторы вредоносных программ — чтобы избежать обнаружения. Так как же нам идентифицировать упаковщиков?

Из заголовков разделов
В предыдущих задачах мы узнали, что обычно PE -файл имеет раздел .text, раздел .data и раздел .rsrc, где только раздел .text имеет установленный флаг выполнения, поскольку он содержит код. Теперь возьмем пример файла с именем zmsuz3pinwl. Когда мы открываем этот файл в pe-tree, мы обнаруживаем, что у него нетрадиционные имена разделов (или вообще нет имен, в данном случае).

IMAGE_SECTION_HEADERS, как показано в утилите pe-tree, показывающей ненормальные разделы

Мы можем подумать, что это как-то связано с инструментом, который мы используем для анализа файла. Поэтому давайте проверим его с помощью другого инструмента анализа PE , называемого pecheck. Инструмент pecheck предоставляет ту же информацию, которую мы собирали из инструмента pe-tree, но это инструмент командной строки. Мы переходим в каталог Desktop\Samples в терминале и даем следующую команду для запуска инструмента pecheck.

`pecheck zmsuz3pinwl`

Давайте посмотрим информацию в заголовке PE Sections в выходных данных:

ЧП
Проверить полезность
```commandline
user@machine$ pecheck zmsuz3pinwl
PE check for 'zmsuz3pinwl':
Entropy: 7.978052 (Min=0.0, Max=8.0)
MD5     hash: 1ebb1e268a462d56a389e8e1d06b4945
SHA-1   hash: 1ecc0b9f380896373e81ed166c34a89bded873b5
SHA-256 hash: 98c6cf0b129438ec62a628e8431e790b114ba0d82b76e625885ceedef286d6f5
SHA-512 hash: 6921532b4b5ed9514660eb408dfa5d28998f52aa206013546f9eb66e26861565f852ec7f04c85ae9be89e7721c4f1a5c31d2fae49b0e7fdfd20451191146614a
 entropy: 7.999788 (Min=0.0, Max=8.0)
 entropy: 7.961048 (Min=0.0, Max=8.0)
 entropy: 7.554513 (Min=0.0, Max=8.0)
.rsrc entropy: 6.938747 (Min=0.0, Max=8.0)
 entropy: 0.000000 (Min=0.0, Max=8.0)
.data entropy: 7.866646 (Min=0.0, Max=8.0)
.adata entropy: 0.000000 (Min=0.0, Max=8.0)
.
.
.
.
.
.
----------PE Sections----------

[IMAGE_SECTION_HEADER]
0x1F0      0x0   Name:                          
0x1F8      0x8   Misc:                          0x3F4000  
0x1F8      0x8   Misc_PhysicalAddress:          0x3F4000  
0x1F8      0x8   Misc_VirtualSize:              0x3F4000  
0x1FC      0xC   VirtualAddress:                0x1000    
0x200      0x10  SizeOfRawData:                 0xD3400   
0x204      0x14  PointerToRawData:              0x400     
0x208      0x18  PointerToRelocations:          0x0       
0x20C      0x1C  PointerToLinenumbers:          0x0       
0x210      0x20  NumberOfRelocations:           0x0       
0x212      0x22  NumberOfLinenumbers:           0x0       
0x214      0x24  Characteristics:               0xE0000040
Flags: IMAGE_SCN_CNT_INITIALIZED_DATA, IMAGE_SCN_MEM_EXECUTE, IMAGE_SCN_MEM_READ, IMAGE_SCN_MEM_WRITE
Entropy: 7.999788 (Min=0.0, Max=8.0)
MD5     hash: fa9814d3aeb1fbfaa1557bac61136ba7
SHA-1   hash: 8db955c622c5bea3ec63bd917db9d41ce038c3f7
SHA-256 hash: 24f922c1cd45811eb5f3ab6f29872cda11db7d2251b7a3f44713627ad3659ac9
SHA-512 hash: e122e4600ea201058352c97bb7549163a0a5bcfb079630b197fe135ae732e64f5a6daff328f789e7b2285c5f975bce69414e55adba7d59006a1f0280bf64971c
.
.
.
.
.
```
Здесь мы видим, что имя раздела пустое, и это не сбой в инструменте, который мы использовали для анализа PE- файла.

Еще одна вещь, которую мы могли бы здесь заметить, это то, что энтропия раздела .data и трех из четырех неименованных разделов выше семи и приближается к 8. Как мы обсуждали в предыдущей задаче, более высокая энтропия представляет более высокий уровень случайности в данных. Случайные данные обычно генерируются, когда исходные данные обфусцированы, указывая на то, что эти значения могут указывать на упакованный исполняемый файл.

Помимо названий разделов, еще одним индикатором упакованного исполняемого файла являются разрешения каждого раздела. Для PE- файла в терминале выше мы видим, что раздел содержит инициализированные данные и имеет разрешения READ, WRITE и EXECUTE. Аналогично, некоторые другие разделы также имеют разрешения READ, WRITE и EXECUTE. Этого также нет в обычном распакованном PE- файле, где только раздел .text имеет разрешения EXECUTE, как мы видели в образце вредоносного ПО redline.

Еще одна ценная информация из заголовков разделов для идентификации упакованного исполняемого файла — SizeOfRawData и Misc_VirtualSize. В упакованном исполняемом файле SizeOfRawData всегда будет значительно меньше Misc_VirtualSize в разделах с разрешениями WRITE и EXECUTE. Это происходит потому, что когда PE- файл распаковывается во время выполнения, он записывает данные в этот раздел, увеличивая свой размер в памяти по сравнению с размером на диске, а затем выполняет его.

Из функций импорта:
Последний важный индикатор упакованного исполняемого файла, который мы здесь обсуждаем, — это его функции импорта. Файл redline PE , который мы анализировали ранее, импортировал множество функций, что указывает на активность, которую он потенциально выполняет. Однако для файла PE zmsuz3pinwl мы увидим только несколько импортов, особенно GetProcAddress, GetModuleHandleA и LoadLibraryA. Эти функции часто являются одними из немногих импортов упакованного файла PE , поскольку эти функции предоставляют функциональность для распаковки файла PE во время выполнения.

Импорт исполняемого файла, как он выглядит с помощью утилиты pe-tree, показывающий очень мало импортированных функций

Подводя итог, можно сказать, что следующие признаки указывают на упакованный исполняемый файл, если посмотреть на 
данные его PE- заголовка:

- Нетрадиционные названия разделов
- Разрешения EXECUTE для нескольких разделов
- Высокая энтропия, приближающаяся к 8, для некоторых участков.
- Значительная разница между SizeOfRawData и Misc_VirtualSize некоторых разделов PE
- Очень мало функций импорта

### Ответьте на вопросы ниже
Какой из файлов в прикрепленной виртуальной машине в каталоге Desktop\Samples, по-видимому, является упакованным исполняемым файлом?
```commandline
zmsuz3pinwl
```

## Задание 9
На этом мы завершаем эту комнату о Dissecting PE headers. В этой комнате мы узнали:
- Что такое заголовок PE
- Каковы различные части заголовка PE?
- Как прочитать информацию из заголовка PE
- Идентификация упакованных исполняемых файлов с использованием заголовка PE
Дайте нам знать, что вы думаете об этой комнате на нашем канале Discord или  в аккаунте Twitter . Увидимся.   

### Ответьте на вопросы ниже
Присоединяйтесь к обсуждению в наших социальных сетях.
```commandline
Ответ не нужен
```
[>> вернуться на главную страницу](https://github.com/BEPb/tryhackme/blob/master/README.md)