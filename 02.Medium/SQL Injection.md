[>> вернуться на главную страницу](https://github.com/BEPb/tryhackme/blob/master/README.md)

# Комната [SQL Injection](https://tryhackme.com/r/room/sqlinjectionlm) 

Всего 10 заданий:
## Задание 1
SQL (язык структурированных запросов) инъекция, в основном называемая SQLi, представляет собой атаку на сервер базы 
данных веб-приложений, которая приводит к выполнению вредоносных запросов. Когда веб-приложение взаимодействует с 
базой данных, используя ввод пользователя, который не был должным образом проверен, существует потенциальная 
возможность того, что злоумышленник сможет украсть, удалить или изменить личные и клиентские данные, а также 
атаковать методы аутентификации веб-приложения в личных или клиентских областях. Вот почему SQLi является одной из 
старейших уязвимостей веб-приложений, и она также может быть наиболее разрушительной.

В этой комнате вы узнаете, что такое базы данных, что такое SQL с некоторыми базовыми командами SQL, как обнаружить 
уязвимости SQL, как использовать уязвимости SQLi и, как разработчик, как вы можете защитить себя от SQL- инъекции. 

### Ответьте на вопросы ниже
Что означает SQL?

```commandline
Structured Query Language
```

## Задание 2
Если вы не привыкли работать с базами данных или использовать их, вам, вероятно, придется привыкнуть к какой-то 
новой терминологии, поэтому давайте начнем с основ структуры и работы баз данных. 

#### Что такое база данных?
База данных — это способ электронного хранения наборов данных в организованном виде. База данных управляется СУБД, 
что является аббревиатурой от Database Management System (система управления базами данных). СУБД делятся на два 
лагеря: реляционные и нереляционные; в этой комнате основное внимание будет уделено реляционным базам данных; 
некоторые из наиболее распространенных, с которыми вы столкнетесь, — это MySQL, Microsoft SQL Server, Access, 
PostgreSQL и SQLite. Мы объясним разницу между реляционными и нереляционными базами данных в конце этого задания, но 
сначала важно выучить несколько терминов.


В СУБД у вас может быть несколько баз данных, каждая из которых содержит свой собственный набор связанных данных. 
Например, у вас может быть база данных под названием « магазин ». В этой базе данных вы хотите хранить информацию о 
продуктах, доступных для покупки , пользователях , которые зарегистрировались в вашем интернет-магазине, и 
информацию о полученных вами заказах . Вы бы хранили эту информацию отдельно в базе данных, используя то, что 
называется таблицами. Таблицы идентифицируются уникальным именем для каждой из них. Вы можете увидеть эту структуру 
на диаграмме ниже, но вы также можете увидеть, как у компании могут быть другие отдельные базы данных для хранения 
информации о персонале или команде по работе с клиентами.

#### Что такое таблицы?

Таблица состоит из столбцов и строк. Таблицу удобно представить в виде сетки, в которой столбцы идут сверху слева 
направо и содержат имя ячейки, а строки идут сверху вниз, и в каждой из них содержатся фактические данные.

#### Столбцы:

Каждый столбец, который лучше называть полем, имеет уникальное имя для каждой таблицы. При создании столбца вы также 
задаете тип данных, которые он будет содержать, распространенными из которых являются целые числа (числа), строки 
(стандартный текст) или даты. Некоторые базы данных могут содержать гораздо более сложные данные, такие как 
геопространственные, которые содержат информацию о местоположении. Установка типа данных также гарантирует, что 
неверная информация не будет сохранена, например, строка «hello world» будет сохранена в столбце, предназначенном 
для дат. Если это произойдет, сервер базы данных обычно выдаст сообщение об ошибке. Столбец, содержащий целое число, 
также может иметь включенную функцию автоинкремента; это дает каждой строке данных уникальный номер, который растет 
(приращается) с каждой последующей строкой. Это создает то, что называется ключевым полем; ключевое поле должно быть 
уникальным для каждой строки данных, что может использоваться для поиска этой точной строки в SQL- запросах.

Ряды:

Строки или записи содержат отдельные строки данных. При добавлении данных в таблицу создается новая строка/запись; 
при удалении данных строка/запись удаляется.


#### Реляционные и нереляционные базы данных:
Реляционная база данных хранит информацию в таблицах, и часто таблицы обмениваются информацией между собой; они 
используют столбцы для указания и определения хранимых данных, а строки — для фактического хранения данных. Таблицы 
часто содержат столбец с уникальным идентификатором (первичным ключом), который затем будет использоваться в других 
таблицах для ссылки на него и установления связи между таблицами, отсюда и название реляционная база данных.

С другой стороны, нереляционные базы данных, иногда называемые NoSQL, — это любые базы данных, которые не используют 
таблицы, столбцы и строки для хранения данных. Не нужно создавать определенную структуру базы данных, поэтому каждая 
строка данных может содержать различную информацию, что обеспечивает большую гибкость по сравнению с реляционной 
базой данных. Некоторые популярные базы данных этого типа — MongoDB, Cassandra и ElasticSearch.

Теперь, когда вы узнали, что такое база данных, давайте узнаем, как можно с ней взаимодействовать с помощью SQL.

### Ответьте на вопросы ниже
Какова аббревиатура программного обеспечения, управляющего базой данных?
```commandline
DBMS
```
Как называется сетчатая структура, в которой хранятся данные?
```commandline
table
```

## Задание 3
SQL (Structured Query Language) — это многофункциональный язык, используемый для запросов к базам данных. Такие SQL- 
запросы лучше называть операторами. 

Самая простая из команд, которые мы рассмотрим в этой задаче, используется для извлечения (выбора), обновления, 
вставки и удаления данных. Хотя они несколько похожи, некоторые серверы баз данных имеют свой собственный синтаксис 
и небольшие изменения в том, как все работает. Все эти примеры основаны на базе данных MySQL. После изучения уроков 
вы легко сможете искать альтернативный синтаксис в Интернете для разных серверов. Стоит отметить, что синтаксис SQL 
не чувствителен к регистру.



ВЫБИРАТЬ
Первый тип запроса, который мы изучим, — это запрос `SELECT`, используемый для извлечения данных из базы данных. 
`select * from users;`

Первое слово SELECT сообщает базе данных, что мы хотим получить некоторые данные; * сообщает базе данных, что мы 
хотим получить обратно все столбцы из таблицы. Например, таблица может содержать три столбца (id, username и 
password). "from users" сообщает базе данных, что мы хотим получить данные из таблицы с именем users. Наконец, точка 
с запятой в конце сообщает базе данных, что это конец запроса.

Следующий запрос аналогичен предыдущему, но на этот раз вместо использования * для возврата всех столбцов в таблице 
базы данных мы просто запрашиваем поле имени пользователя и пароля. 

`select username,password from users;`

Следующий запрос, как и первый, возвращает все столбцы с помощью селектора *, а затем предложение "LIMIT 1" 
заставляет базу данных возвращать только одну строку данных. Изменение запроса на "LIMIT 1,1" заставляет запрос 
пропускать первый результат, а затем "LIMIT 2,1" пропускает первые два результата и т. д. Вам нужно запомнить, что 
первое число сообщает базе данных, сколько результатов вы хотите пропустить, а второе число сообщает базе данных, 
сколько строк нужно вернуть. 

`select * from users LIMIT 1;`

Наконец, мы собираемся использовать предложение where; именно так мы можем точно выбрать нужные нам данные, 
возвращая данные, которые соответствуют нашим конкретным предложениям: 

`select * from users where username='admin';`
Это вернет только те строки, в которых имя пользователя равно admin.

`select * from users where username != 'admin';`
Это вернет только те строки, в которых имя пользователя  НЕ  равно admin.

`select * from users where username='admin' or username='jon';`

Это вернет только те строки, в которых имя пользователя равно  admin  или jon. 

`select * from users where username='admin' and password='p4ssword';`

Это вернет только те строки, в которых имя пользователя равно  admin, а пароль равен  p4ssword.

Использование предложения like позволяет указать данные, которые не являются точным совпадением, но вместо этого 
начинаются, содержат или заканчиваются определенными символами, выбрав место для размещения подстановочного знака, 
представленного знаком процента %.

`select * from users where username like 'a%';`

Возвращает все строки с именем пользователя, начинающимся с буквы a.

`select * from users where username like '%n';`

Возвращает все строки с именем пользователя, заканчивающимся на букву n.

`select * from users where username like '%mi%';`

Возвращает все строки с именем пользователя, содержащим символы  mi  .

Оператор UNION объединяет результаты двух или более операторов SELECT для извлечения данных из одной или нескольких 
таблиц; правила этого запроса таковы, что оператор UNION должен извлекать одинаковое количество столбцов в каждом 
операторе SELECT, столбцы должны иметь схожий тип данных, а порядок столбцов должен быть одинаковым. Это может 
показаться не совсем понятным, поэтому давайте воспользуемся следующей аналогией. Допустим, компания хочет создать 
список адресов для всех клиентов и поставщиков, чтобы разместить новый каталог. У нас есть одна таблица с именем 
customers со следующим содержимым:     

И еще одно письмо, названное поставщикам, со следующим содержанием:

Используя следующий оператор SQL, мы можем собрать результаты из двух таблиц и поместить их в один набор результатов:
`SELECT name,address,city,postcode from customers UNION SELECT company,address,city,postcode from suppliers;`

Оператор  INSERT  сообщает базе данных, что мы хотим вставить новую строку данных в таблицу.  «into users»  сообщает 
базе данных, в какую таблицу мы хотим вставить данные,  «(username,password)»  указывает столбцы, для которых мы 
предоставляем данные, а затем  «values ('bob','password');»  указывает данные для ранее указанных столбцов.

`insert into users (username,password) values ('bob','password123');`

Оператор  UPDATE  сообщает базе данных, что мы хотим обновить одну или несколько строк данных в таблице. Вы 
указываете таблицу, которую хотите обновить, используя " update %tablename% SET ", а затем выбираете поле или поля, 
которые хотите обновить, в виде списка, разделенного запятыми, например " username='root',password='pass123' ", 
затем, наконец, аналогично оператору SELECT, вы можете точно указать, какие строки нужно обновить, используя 
предложение where, например " where username='admin; ".

`update users SET username='root',password='pass123' where username='admin';`

Оператор  DELETE  сообщает базе данных, что мы хотим удалить одну или несколько строк данных. За исключением 
отсутствия столбцов, которые вы хотите вернуть, формат этого запроса очень похож на SELECT. Вы можете точно указать, 
какие данные следует удалить, используя предложение  where  , а количество строк, которые следует удалить, используя 
предложение LIMIT.
`delete from users where username='martin';`

Поскольку в запросе не использовалось предложение WHERE, все данные были удалены из таблицы.

### Ответьте на вопросы ниже
Какой оператор SQL используется для извлечения данных?
```commandline
SELECT
```
Какое предложение SQL можно использовать для извлечения данных из нескольких таблиц?
```commandline
UNION
```
Какой оператор SQL используется для добавления данных?
```commandline
INSERT
```

## Задание 4
#### Что такое SQL- инъекция?
Веб-приложение, использующее SQL, может превратиться в SQL- инъекцию, когда предоставленные пользователем данные 
включаются в SQL- запрос. 

Как это выглядит?
Возьмем следующий сценарий, в котором вы наткнулись на онлайн-блог, и каждая запись блога имеет уникальный 
идентификационный номер. Записи блога могут быть установлены как публичные или частные, в зависимости от того, 
готовы ли они к публичному выпуску. URL для каждой записи блога может выглядеть примерно так:

https://website.thm/blog?id=1

Из URL выше вы можете видеть, что выбранная запись блога взята из параметра id в строке запроса. Веб-приложению 
необходимо извлечь статью из базы данных, и оно может использовать оператор SQL , который выглядит примерно так: 

`SELECT * from blog where id=1 and private=0 LIMIT 1;`

Из того, что вы узнали в предыдущей задаче, вы должны быть в состоянии понять, что оператор SQL выше ищет в таблице 
блога статью с номером id 1 и столбцом private, установленным на 0, что означает, что она может быть просмотрена 
публикой и ограничивает результаты только одним совпадением.

Как было упомянуто в начале этой задачи, SQL- инъекция вводится, когда пользовательский ввод вводится в запрос к 
базе данных. В этом случае параметр id из строки запроса используется непосредственно в SQL -запросе. 

Давайте представим, что статья с идентификатором 2 по-прежнему заблокирована как частная, поэтому ее нельзя 
просмотреть на веб-сайте. Теперь мы могли бы вместо этого вызвать URL: 
 
https://website.thm/blog?id=2;--

Что затем, в свою очередь, произведет оператор SQL :

`SELECT * from blog where id=2;-- and private=0 LIMIT 1;`

Точка с запятой в URL обозначает конец оператора SQL, а два тире заставляют все последующее рассматривать как 
комментарий. Делая это, вы просто, по сути, запускаете запрос: 

`SELECT * from blog where id=2;--`

Который вернет статью с идентификатором 2 независимо от того, установлена ли она как публичная или нет.

Это всего лишь один пример уязвимости SQL-инъекции, относящейся к типу, называемому In-Band SQL Injection; всего 
существует три типа: In-Band, Blind и Out-of-Band, которые мы рассмотрим в следующих задачах. 

### Ответьте на вопросы ниже
Какой символ обозначает конец SQL-запроса?
```commandline
;
```

## Задание 5
#### Внутриполосная SQL- инъекция

Внутриполосная инъекция SQL является самым простым типом для обнаружения и эксплуатации; внутриполосная инъекция 
просто относится к тому же методу связи, который используется для эксплуатации уязвимости, а также для получения 
результатов, например, обнаружение уязвимости SQL- инъекции на странице веб-сайта, а затем возможность извлечь 
данные из базы данных на ту же страницу.


#### SQL- инъекция на основе ошибок
Этот тип SQL- инъекции наиболее полезен для простого получения информации о структуре базы данных, поскольку 
сообщения об ошибках из базы данных выводятся непосредственно на экран браузера. Это часто можно использовать для 
перечисления всей базы данных.

#### SQL - инъекция на основе объединения
Этот тип инъекции использует оператор SQL UNION вместе с оператором SELECT для возврата дополнительных результатов 
на страницу. Этот метод является наиболее распространенным способом извлечения больших объемов данных с помощью 
уязвимости SQL Injection.

Практика:
Нажмите зеленую кнопку "Start Machine", чтобы использовать практическую лабораторию SQL Injection Example. Каждый 
уровень содержит макет браузера, а также поля SQL Query и Error, помогающие правильно настраивать запросы/полезную 
нагрузку.

Первый уровень практической лаборатории содержит макет браузера и веб-сайт с блогом с различными статьями, доступ к 
которому можно получить, изменив идентификационный номер в строке запроса.

Ключом к обнаружению SQL-инъекции, основанной на ошибке, является нарушение SQL-запроса кода путем попытки ввести 
определенные символы до тех пор, пока не будет выдано сообщение об ошибке; чаще всего это одинарные апострофы (') 
или кавычки ( " ).

Попробуйте ввести апостроф (  '  ) после id=1 и нажмите Enter. И вы увидите, что это возвращает ошибку SQL, 
информирующую вас об ошибке в вашем синтаксисе. Тот факт, что вы получили это сообщение об ошибке, подтверждает 
существование уязвимости SQL Injection. Теперь мы можем использовать эту уязвимость и использовать сообщения об 
ошибках, чтобы узнать больше о структуре базы данных.

Первое, что нам нужно сделать, это вернуть данные в браузер без отображения сообщения об ошибке. Во-первых, мы 
попробуем оператор UNION, чтобы мы могли получить дополнительный результат, если мы его выберем. Попробуйте 
установить параметр id фиктивного браузера на:

`1 UNION SELECT 1`
Этот оператор должен выдать сообщение об ошибке, информирующее вас о том, что оператор UNION SELECT имеет другое 
количество столбцов, чем исходный запрос SELECT. Давайте попробуем еще раз, но добавим еще один столбец:
`1 UNION SELECT 1,2`

Снова та же ошибка, поэтому давайте повторим, добавив еще один столбец:
`1 UNION SELECT 1,2,3`

Успех, сообщение об ошибке исчезло, и статья отображается, но теперь мы хотим отобразить наши данные вместо статьи. 
Статья отображается, потому что она берет первый возвращенный результат где-то в коде веб-сайта и показывает его. 
Чтобы обойти это, нам нужно, чтобы первый запрос не выдавал никаких результатов. Это можно просто сделать, изменив 
идентификатор статьи с 1 на 0.   

`0 UNION SELECT 1,2,3`
Теперь вы увидите, что статья состоит только из результата выборки UNION, возвращающей значения столбцов 1, 2 и 3. 
Мы можем начать использовать эти возвращаемые значения для извлечения более полезной информации. Сначала мы получим 
имя базы данных, к которой у нас есть доступ: 

`0 UNION SELECT 1,2,database()`

Теперь вы увидите, где раньше отображалась цифра 3; теперь она отображает имя базы данных —  sqli_one .
Наш следующий запрос соберет список таблиц, находящихся в этой базе данных.
`0 UNION SELECT 1,2,group_concat(table_name) FROM information_schema.tables WHERE table_schema = 'sqli_one'`

В этом запросе есть пара новых вещей, которые нужно изучить. Во-первых, метод  group_concat()  получает указанный 
столбец (в нашем случае table_name) из нескольких возвращенных строк и помещает его в одну строку, разделенную 
запятыми. Следующее —  база данных information_schema  ; каждый пользователь базы данных имеет к ней доступ, и она 
содержит информацию обо всех базах данных и таблицах, к которым у пользователя есть доступ. В этом конкретном 
запросе мы заинтересованы в перечислении всех таблиц в базе  данных sqli_one  , то есть article и staff_users.

Поскольку первый уровень направлен на обнаружение пароля Мартина, нас интересует таблица staff_users. Мы можем снова 
использовать базу данных information_schema, чтобы найти структуру этой таблицы, используя следующий запрос.

`0 UNION SELECT 1,2,group_concat(column_name) FROM information_schema.columns WHERE table_name = 'staff_users'`

Это похоже на предыдущий запрос SQL . Однако информация, которую мы хотим получить, изменилась с table_name на  
column_name , таблица, которую мы запрашиваем в базе данных information_schema, изменилась с tables на  columns , и 
мы ищем любые строки, где  столбец table_name  имеет значение  staff_users.

Результаты запроса предоставляют три столбца для таблицы staff_users: id, password и username. Мы можем использовать 
столбцы username и password для нашего следующего запроса, чтобы получить информацию о пользователе.

`0 UNION SELECT 1,2,group_concat(username,':',password SEPARATOR '<br>') FROM staff_users`

Опять же, мы используем метод group_concat, чтобы вернуть все строки в одну строку и сделать ее более удобной для 
чтения. Мы также добавили  ,':',  чтобы разделить имя пользователя и пароль друг от друга. Вместо того, чтобы 
разделять их запятой, мы выбрали HTML-  тег <br>  , который заставляет каждый результат быть на отдельной строке, 
чтобы сделать его более удобным для чтения.

Теперь у вас должен быть доступ к паролю Мартина для входа и перехода на следующий уровень.

### Ответьте на вопросы ниже
Какой флаг появляется после завершения уровня 1?

```commandline
THM{SQL_INJECTION_3840}
```
## Задание 6
#### Слепой SQLi

В отличие от In-Band SQL-инъекции, где мы можем видеть результаты нашей атаки прямо на экране, слепая SQLi — это 
когда мы получаем мало или вообще не получаем обратной связи для подтверждения того, были ли наши инъецированные 
запросы на самом деле успешными или нет, это происходит потому, что сообщения об ошибках были отключены, но инъекция 
все равно работает независимо. Вас может удивить, что все, что нам нужно, — это эта небольшая часть обратной связи 
для успешного перечисления всей базы данных.    

#### Обход аутентификации
Один из самых простых методов слепой SQL-инъекции — обход методов аутентификации, таких как формы входа. В этом 
случае мы не так уж заинтересованы в извлечении данных из базы данных; мы просто хотим обойти вход.

Формы входа, подключенные к базе данных пользователей, часто разрабатываются таким образом, что веб-приложению не 
интересно содержимое имени пользователя и пароля, а больше то, образуют ли они пару в таблице пользователей. Проще 
говоря, веб-приложение спрашивает базу данных: «У вас есть пользователь с именем пользователя bob и паролем bob123?»,
база данных отвечает «да» или «нет» (true/false) и, в зависимости от этого ответа, определяет, позволит ли 
веб-приложению продолжить работу или нет.

Принимая во внимание вышеизложенную информацию, нет необходимости перечислять допустимую пару имя 
пользователя/пароль. Нам просто нужно создать запрос к базе данных, который отвечает yes/true.

Практика:

Уровень 2 примеров SQL Injection показывает именно этот пример. Мы можем видеть в поле с надписью "SQL Query", что 
запрос к базе данных выглядит следующим образом: 

`select * from users where username='%username%' and password='%password%' LIMIT 1;`

NB  Значения %username%  и  %password%  берутся из полей формы входа. Начальные значения в поле SQL Query будут 
пустыми, поскольку эти поля в настоящее время пусты.

Чтобы сделать запрос, который всегда возвращает значение true, мы можем ввести в поле пароля следующее:
`' OR 1=1;--`

Что превращает SQL- запрос в следующий:
`select * from users where username='' and password='' OR 1=1;`

Поскольку 1=1 является истинным утверждением, а мы использовали  оператор ИЛИ  , это всегда приведет к тому, что 
запрос будет возвращать значение «истина», что удовлетворяет логике веб-приложений, согласно которой база данных 
нашла допустимую комбинацию имени пользователя и пароля, и доступ должен быть разрешен.

### Ответьте на вопросы ниже
Какой флаг появляется после завершения второго уровня? (и перехода на третий уровень)
```commandline
THM{SQL_INJECTION_9581}
```

## Задание 7
#### На основе булевых значений

Булева SQL-инъекция относится к ответу, который мы получаем от наших попыток инъекции, который может быть 
истина/ложь, да/нет, вкл/выкл, 1/0 или любым ответом, который может иметь только два результата. Этот результат 
подтверждает, что наша полезная нагрузка SQL-инъекции была либо успешной, либо нет. При первом осмотре вам может 
показаться, что этот ограниченный ответ не может предоставить много информации. Тем не менее, с помощью только этих 
двух ответов можно перечислить всю структуру и содержимое базы данных.

Практика:
На третьем уровне машины примеров SQL-инъекций вам предоставляется макет браузера со следующим URL-адресом:
https://website.thm/checkuser?имя_пользователя=администратор

Тело браузера содержит   {"taken":true} . Эта конечная точка API реплицирует общую функцию, встречающуюся во многих 
формах регистрации, которая проверяет, было ли уже зарегистрировано имя пользователя, чтобы предложить пользователю 
выбрать другое имя пользователя. Поскольку значение  took  установлено на  true , мы можем предположить, что имя 
пользователя admin уже зарегистрировано. Мы можем подтвердить это, изменив имя пользователя в адресной строке 
фиктивного браузера с  admin  на  admin123 , и после нажатия Enter вы увидите, что значение  took  теперь изменилось 
на  false.

Обрабатываемый SQL-запрос выглядит следующим образом :
`select * from users where username = '%username%' LIMIT 1;`

Единственный вход, который мы контролируем, — это имя пользователя в строке запроса, и нам придется использовать его 
для выполнения нашей SQL- инъекции. Сохраняя имя пользователя как  admin123 , мы можем начать добавлять к нему 
данные, чтобы попытаться заставить базу данных подтвердить истинные вещи, изменив состояние принятого поля с ложного 
на истинное. 

Как и на предыдущих уровнях, наша первая задача — установить количество столбцов в таблице пользователей, чего мы 
можем добиться с помощью оператора UNION. Измените значение имени пользователя на следующее:

`admin123' UNION SELECT 1;--` 

Поскольку веб-приложение ответило значением,  принятым  как false, мы можем подтвердить, что это неверное значение 
columns. Продолжайте добавлять больше столбцов, пока не получим  принятое  значение  true . Вы можете подтвердить, 
что ответ — три столбца, установив имя пользователя на следующее значение:
`admin123' UNION SELECT 1,2,3;-- `

Теперь, когда количество столбцов установлено, мы можем заняться перечислением базы данных. Наша первая задача — 
узнать имя базы данных. Мы можем сделать это, используя встроенный  метод database(), а затем используя  оператор 
like, чтобы попытаться найти результаты, которые вернут истинный статус.

Попробуйте ввести следующее значение имени пользователя и посмотрите, что произойдет:
`admin123' UNION SELECT 1,2,3 where database() like '%';--`

Мы получаем истинный ответ, потому что в операторе like у нас есть только значение  % , которое будет 
соответствовать чему угодно, поскольку это подстановочное значение. Если мы изменим подстановочный оператор на  a% , 
вы увидите, что ответ возвращается к false, что подтверждает, что имя базы данных не начинается с буквы  a . Мы 
можем циклически перебирать все буквы, цифры и символы, такие как - и _ , пока не обнаружим совпадение. Если вы 
отправите нижеследующее как значение имени пользователя, вы получите  истинный  ответ, который подтверждает, что имя 
базы данных начинается с буквы  s .

`admin123' UNION SELECT 1,2,3 where database() like 's%';--`

Теперь переходите  к следующему символу имени базы данных, пока не найдете другой верный ответ, например, «sa%», 
«sb%», «sc%» и т. д. Продолжайте этот процесс, пока не обнаружите все символы имени базы данных, то есть  sqli_three .

Мы установили имя базы данных, которое теперь можно использовать для перечисления имен таблиц с использованием 
аналогичного метода, используя базу данных information_schema. Попробуйте установить имя пользователя на следующее 
значение:

`admin123' UNION SELECT 1,2,3 FROM information_schema.tables WHERE table_schema = 'sqli_three' and table_name like 'a%';--`

Этот запрос ищет результаты в  базе данных information_schema  в  таблице tables  , где имя базы данных совпадает с  
sqli_three , а имя таблицы начинается с буквы a. Поскольку приведенный выше запрос дает  ложный  ответ, мы можем 
подтвердить, что в базе данных sqli_three нет таблиц, начинающихся с буквы a. Как и ранее, вам нужно будет 
циклически перебирать буквы, цифры и символы, пока не найдете положительное совпадение.

В конечном итоге вы обнаружите таблицу в базе данных sqli_three с именем users, в чем можно убедиться, выполнив 
следующую полезную нагрузку username:

`admin123' UNION SELECT 1,2,3 FROM information_schema.tables WHERE table_schema = 'sqli_three' and table_name='users';--`

Наконец, теперь нам нужно перечислить имена столбцов в  таблице users  , чтобы мы могли правильно искать в ней 
учетные данные для входа. Опять же, мы можем использовать базу данных information_schema и уже полученную нами 
информацию, чтобы запросить в ней имена столбцов. Используя полезную нагрузку ниже, мы ищем  таблицу столбцов, где 
база данных равна sqli_three, имя таблицы — users, а имя столбца начинается с буквы a.

`admin123' UNION SELECT 1,2,3 FROM information_schema.COLUMNS WHERE TABLE_SCHEMA='sqli_three' and TABLE_NAME='users' and COLUMN_NAME like 'a%';`

Опять же, вам нужно будет циклически перебирать буквы, цифры и символы, пока не найдете совпадение. Поскольку вы 
ищете несколько результатов, вам придется добавлять это в свою полезную нагрузку каждый раз, когда вы найдете новое 
имя столбца, чтобы избежать обнаружения того же самого. Например, как только вы найдете столбец с именем  id , вы 
добавите его в свою исходную полезную нагрузку (как показано ниже).

`admin123' UNION SELECT 1,2,3 FROM information_schema.COLUMNS WHERE TABLE_SCHEMA='sqli_three' and TABLE_NAME='users' and COLUMN_NAME like 'a%' and COLUMN_NAME !='id';`

Повторив этот процесс три раза, вы сможете обнаружить идентификатор столбцов, имя пользователя и пароль. Теперь вы 
можете использовать их для запроса  учетных данных для входа в таблицу пользователей. Сначала вам нужно будет 
обнаружить действительное имя пользователя, которое вы можете использовать в полезной нагрузке ниже:

`admin123' UNION SELECT 1,2,3 from users where username like 'a%`

После того, как вы прошли через все символы, вы подтвердите существование имени пользователя  admin . Теперь у вас 
есть имя пользователя. Вы можете сосредоточиться на поиске пароля. Полезная нагрузка ниже показывает вам, как найти 
пароль:

`admin123' UNION SELECT 1,2,3 from users where username='admin' and password like 'a%`

Перебрав все символы, вы обнаружите, что пароль — 3845.

Теперь вы можете использовать имя пользователя и пароль, которые вы указали с помощью уязвимости слепой SQL- 
инъекции в форме входа, для доступа на следующий уровень. 

### Ответьте на вопросы ниже
Какой флаг появляется после завершения третьего уровня?
```commandline
THM{SQL_INJECTION_1093}
```

## Задание 8
#### На основе времени

Слепая SQL- инъекция на основе времени очень похожа на вышеописанную на основе булевых значений, в которой 
отправляются те же запросы, но визуального индикатора правильности или неправильности ваших запросов на этот раз нет.
Вместо этого ваш индикатор правильности запроса основан на времени, которое требуется для выполнения запроса. Эта 
временная задержка вводится с помощью встроенных методов, таких как  SLEEP(x)  вместе с оператором UNION. Метод SLEEP
() будет выполняться только при успешном выполнении оператора UNION SELECT.

Так, например, при попытке установить количество столбцов в таблице вы можете использовать следующий запрос:
`admin123' UNION SELECT SLEEP(5);--`

Если паузы во времени ответа не было, мы знаем, что запрос не удался, поэтому, как и в предыдущих задачах, добавляем 
еще один столбец:
`admin123' UNION SELECT SLEEP(5),2;--`

Эта полезная нагрузка должна была вызвать 5-секундную задержку, подтверждающую успешное выполнение оператора UNION и 
наличие двух столбцов. 

Теперь вы можете повторить процесс перечисления из  SQL -инъекции на основе булевых значений , добавив метод SLEEP() 
к  оператору UNION SELECT  . 
Если вам сложно найти имя таблицы, следующий запрос должен вам помочь:
`referrer=admin123' UNION SELECT SLEEP(5),2 where database() like 'u%';--`


### Ответьте на вопросы ниже
Какой последний флаг после завершения четвертого уровня?
```commandline
THM{SQL_INJECTION_MASTER}
```

## Задание 9
Внеполосная SQL-инъекция встречается не так часто, поскольку зависит либо от определенных функций, включенных на 
сервере базы данных, либо от бизнес-логики веб-приложения, которая делает какой-то внешний сетевой вызов на основе 
результатов SQL- запроса.

Внеполосная атака классифицируется по наличию двух различных каналов связи: один для запуска атаки, а другой для 
сбора результатов. Например, каналом атаки может быть веб-запрос, а каналом сбора данных может быть мониторинг HTTP/ 
DNS- запросов, сделанных к службе, которой вы управляете. 

1) Злоумышленник отправляет запрос на сайт, уязвимый для SQL- инъекции, с полезной нагрузкой для инъекции.
2) Сайт делает SQL-запрос к базе данных, которая также передает полезную нагрузку хакера.
3) Полезная нагрузка содержит запрос, который принудительно отправляет HTTP-запрос обратно на машину хакера, 
   содержащий данные из базы данных. 

### Ответьте на вопросы ниже
Назовите протокол, начинающийся с буквы D, который можно использовать для извлечения данных из базы данных.
```commandline
DNS
```

## Задание 10
Ремедиация

Несмотря на всю серьезность уязвимостей SQL- инъекций, у разработчиков есть способ защитить от них свои 
веб-приложения, следуя приведенным ниже советам:

#### Подготовленные заявления (с параметризованными запросами):
В подготовленном запросе первое, что пишет разработчик, — это SQL-запрос, а затем любые пользовательские вводы 
добавляются в качестве параметров. Написание подготовленных операторов гарантирует, что структура SQL-кода не 
изменится, и база данных сможет различать запрос и данные. В качестве преимущества это также делает ваш код более 
чистым и более удобным для чтения.

Проверка входных данных:

Проверка ввода может иметь большое значение для защиты того, что вставляется в SQL- запрос. Использование списка 
разрешений может ограничить ввод только определенными строками, или метод замены строк в языке программирования 
может фильтровать символы, которые вы хотите разрешить или запретить.

#### Экранирование пользовательского ввода:
Разрешение пользовательского ввода, содержащего такие символы, как ' " $ \, может привести к сбою SQL-запросов или, 
что еще хуже, как мы узнали, сделать их уязвимыми для атак с использованием инъекций. Экранирование 
пользовательского ввода — это метод добавления обратной косой черты ( \ ) к этим символам, что затем приводит к их 
синтаксическому анализу как обычной строки, а не специального символа.

### Ответьте на вопросы ниже
Назовите метод защиты от SQL-инъекции.
```commandline
Prepared Statements
```
[>> вернуться на главную страницу](https://github.com/BEPb/tryhackme/blob/master/README.md)