[>> вернуться на главную страницу](https://github.com/BEPb/tryhackme/blob/master/README.md)

# Комната [Regular expressions](https://tryhackme.com/r/room/catregex) 

Всего 6 заданий:
## Задание 1
Что такое регулярные выражения?
Регулярные выражения (или Regex) — это шаблоны текста, которые вы определяете для поиска документов и точного 
соответствия тому, что вы ищете.

Почему мне следует научиться ими пользоваться?
Даже если они вам не понадобятся рано или поздно, это отличный инструмент, который нужно знать, как использовать. Он 
сделает вас более способным в CTF и потенциально лучшим разработчиком, если у вас есть такая цель. Вы тратите 
немного времени на его изучение и экономите себе много времени в долгосрочной перспективе, используя его.

Я все это знаю, но я ленивый.
Это учебник для ленивых. Немного чтения, а потом учишься на практике.

Где кнопка «Развернуть»?
Нет машины для развертывания. Есть два способа проверить ваши выражения. Либо:

создайте текстовый файл с несколькими тестовыми абзацами (на машине Unix), а затем используйте его, egrep <pattern> 
<file>чтобы увидеть, что совпадает, а что нет, или 
используйте онлайн-редактор, например https://regexr.com/ . Вы можете добавить свой собственный текст в поле «Текст»,
а затем ввести свои выражения (шаблоны) в поле «Выражение». 
Я рекомендую второй способ.

### Ответьте на вопросы ниже
Прочитайте вышеизложенное.
```commandline
Ответ не нужен
```

## Задание 2
При поиске определенной строки в файле или блоке текста вы можете искать ее как есть, с помощью `grep 'string' <file>` 
. Но что произойдет, если вы хотите искать шаблоны текста ? Например, вы можете искать слово, которое начинается с 
определенной буквы, или любые слова, которые заканчиваются цифрами. Вот где вступают в дело регулярные выражения.  

Обе вышеупомянутые проблемы можно решить с помощью `charsets`. Набор символов определяется путем заключения в 
[квадратные скобки ] символа(ов) или диапазона символов, которые вы хотите сопоставить. Затем он находит каждое 
вхождение шаблона, который вы определили в файле/тексте, который вы ищете.  

- [abc] будет соответствовать a, b, и c(каждому вхождению каждой буквы)
- [abc]zz будет соответствовать azz, bzz, и czz.
- [a-c]zz Для определения диапазонов можно также использовать тире: то же самое, что и выше.
- [a-cx-z]zz А затем вы можете объединить диапазоны вместе: будет соответствовать azz, bzz, czz, xzz, yzz, и zzz.
- [a-zA-Z] В частности, это можно использовать для сопоставления с любым алфавитным символом: будет соответствовать любой отдельной букве (строчной или заглавной).
- file[1-3] Вы также можете использовать цифры: будут соответствовать file1, file2, и file3.
- [^k]ing Затем есть способ исключить символы из набора символов с `^` символом шляпы и включить все остальное, будет 
  соответствовать ring, sing, $ing, но не king.
- [^a-c]at Конечно, вы можете исключить целые наборы символов, а не только отдельные символы.  будут соответствовать 
  fat и hat, но не bat или cat.


Примечание 1 : Не путайте строки с наборами символов. Набор символов [abc]будет соответствовать строке abc, а также 
cbaи ca. Он соответствует не строке, а каждому вхождению указанных символов в этой строке. 

Примечание 2 : При указании наборов символов следует вводить буквы в том же порядке, в котором они указаны в 
вопросах, чтобы избежать ввода чего-то правильного, что не является правильным ответом. 

Примечание 3: Ответить на некоторые из этих вопросов будет непросто. Часто существует множество различных шаблонов, 
соответствующих определенным строкам. Это означает (как указано в предыдущем примечании), что вы можете найти 
правильное решение, которое не будет правильным ответом для этой комнаты (потому что может быть только одно). 
Правильный ответ, как правило, является наиболее эффективным регулярным выражением для этого вопроса. Эффективность 
в этом контексте означает 2 вещи:
1. Будьте конкретны. Вот пример: вы можете сопоставить любой символ от a до c, используя [a-z]набор символов. Но если вопрос требует от вас сопоставить только символы от aдо c, вам следует использовать [a-c]набор символов, а не [a-z].
2. Не будьте слишком конкретны. В отличие от предыдущего примера, если вопрос требует от вас сопоставить a, c, f, r, s, z, в этот момент выражение, которое соответствует этим конкретным символам, станет длиннее и сложнее. Поэтому было бы разумнее использовать [a-z], потому что он короткий и простой.

Повторюсь, не может быть единственно правильного решения . Так что если вы проверили свое решение и оно работает, вы 
можете сделать перерыв и вернуться к нему позже, или попросить подсказку в Discord, но постарайтесь не расстраиваться. 

### Ответьте на вопросы ниже
Найдите все следующие символы: c, o, g
```commandline
[cog]
```
Сопоставьте все следующие слова: cat, fat, hat
```commandline
[cfh]at
```
Сопоставьте все следующие слова: Кот, кошка, Шляпа, шляпа
```commandline
[CcHh]at
```
Сопоставьте все следующие имена файлов: File1, File2, file3, file4, file5, File7, file9
```commandline
[Ff]ile[1-9]
```
Найдите все имена файлов из вопроса 4, кроме «File7» (используйте символ шляпы)
```commandline
[Ff]ile[^7]
```

## Задание 3
Подстановочный знак, который используется для сопоставления любого отдельного символа (кроме переноса строки), — это 
точка .. Это означает, что a.cбудет соответствовать aac, abc, a0c, a!c, и так далее. 
Также вы можете установить символ как необязательный в вашем шаблоне с помощью ?вопросительного знака. Это означает, 
что он abc?будет соответствовать ab и abc, поскольку c является необязательным. 

Примечание: Если вы хотите найти .буквальную точку, вам нужно экранировать ее обратной косой чертой \. Это означает, 
что a.cбудет соответствовать a.c, но также abc, a@c, и так далее. Но a\.cбудет соответствовать только a.c . 

### Ответьте на вопросы ниже
Сопоставьте все следующие слова: Кот, толстый, шляпа, крыса
```commandline
.at
```
Сопоставьте все следующие слова: Кот, кошки
```commandline
[Cc]ats?
```
Найдите следующее доменное имя: cat.xyz
```commandline
cat\.xyz
```
Соответствуют всем следующим доменным именам: cat.xyz, cats.xyz, hats.xyz
```commandline
[ch]ats?\.xyz
```
Соответствует каждой строке из 4 букв, которая не заканчивается ни на одну букву от n до z
```commandline
...[^n-z]
```
Сопоставьте биту, летучие мыши, шляпу, шляпы, но не крысу или крыс (используйте символ шляпы)
```commandline
[^r]ats?
```

## Задание 4
Есть более простые способы сопоставления больших наборов символов. Например, \dиспользуется для сопоставления любой 
одиночной цифры. Вот ссылка: 
- \d соответствует цифре, например 9
- \D соответствует нецифре, например Aили @
- \w соответствует буквенно-цифровому символу, например или соответствует небуквенно-цифровому символу, например a или 
соответствует пробелу (пробелы, табуляции и переносы строк) соответствует всему остальному (буквенно-цифровым 
  символам и символам) 3 
- \W!#
- \s
- \S

Примечание: Подчеркивания _включены в \w метасимвол, а не в \W. Это означает, что \w будет соответствовать каждому 
отдельному символу в test_file.

Часто нам нужен шаблон, который соответствует многим символам одного типа в строке, и мы можем сделать это с помощью 
повторений. Например, {2}используется для сопоставления предыдущего символа (или метасимвола, или набора символов) 
два раза подряд. Это означает, что z{2}будет соответствовать точно zz.  

Вот ссылка на каждое повторение с указанием того, сколько раз оно соответствует предыдущему шаблону:

- {12}- ровно 12 раз.
- {1,5}- от 1 до 5 раз.
- {2,}- 2 или более раз.
- *- 0 или более раз.
- +- 1 или более раз.

### Ответьте на вопросы ниже
Сопоставьте следующее слово: catssss
```commandline
cats{4}
```
Найдите все следующие слова (используйте знак *): Cat, cats, catsss
```commandline
[Cc]ats*
```
Сопоставьте все следующие предложения (используйте знак +): regex go br, regex go brrrrrr
```commandline
regex go br+
```
Соответствует всем следующим именам файлов: ab0001, bb0000, abc1000, cba0110, c0000 (не используйте метасимволы)
```commandline
[abc]{1,3}[01]{4}
```
Соответствует всем следующим именам файлов: File01, File2, file12, File20, File99
```commandline
[Ff]ile\d{1,2}
```
Сопоставьте все следующие имена папок: kali tools, kali tools
```commandline
kali\s+tools
```
Найдите все следующие имена файлов: notes~, stuff@, gtfob#, lmaoo!
```commandline
\w{5}\W
```
Сопоставьте строку в кавычках (используйте знак * и метасимволы \s, \S): "2f0h@f0j0%! a)K!F49h!FFOK"
```commandline
\S*\s*\S*
```
Найдите каждую строку из 9 символов (с буквами, цифрами и символами), которая не заканчивается знаком «!»
```commandline
\S{8}[^!]
```
Найдите все эти имена файлов (используйте символ +): .bash_rc, .unnecessarily_long_filename и note1
```commandline
\.?\w+
```

## Задание 5
Иногда очень полезно указать, что мы хотим искать по определенному шаблону в начале или конце строки . Мы делаем это 
с помощью следующих символов: 
- ^- начинается с
- $- заканчивается с

Так, например, если вы хотите найти строку, которая начинается с abc , вы можете использовать ^abc.
Если вы хотите найти строку, которая заканчивается на xyz , вы можете использовать xyz$.

Примечание: ^Символ шляпы используется для исключения набора символов, если он заключен в [квадратные скобки ], но 
если он не заключен в квадратные скобки, он используется для указания начала слова. 

Вы также можете определить группы, заключив шаблон в (скобки ). Эту функцию можно использовать для многих целей, 
которые не входят в рамки этого руководства. Мы будем использовать ее для определения шаблона «или/или» , а также 
для повторения шаблонов. Чтобы сказать «или» в Regex, мы используем вертикальную |черту.  

Для примера с шаблоном «или/или» шаблон during the (day|night)будет соответствовать обоим этим предложениям: during 
the dayи during the night. 
Для примера с повторением шаблон (no){5}будет соответствовать предложению nonononono.

### Ответьте на вопросы ниже
Соответствует каждой строке, которая начинается с «Пароль:», за которым следуют любые 10 символов, кроме «0»
```commandline
Password:[^0]{10}
```
Найдите «имя пользователя:» в начале строки (обратите внимание на пробел!)
```commandline
^username:\s
```
Найдите каждую строку, которая не начинается с цифры (используйте метасимвол)
```commandline
^\D
```
Сопоставьте эту строку в конце строки: EOF$
```commandline
EOF\$$
```
Сопоставьте все следующие предложения:
Я использую нано
Я использую ВИМ
```commandline
I use (nano|vim)
```
Соответствует всем строкам, начинающимся с символа $, за которым следует любая одна цифра,
за которой следует символ $, за которым следует один или несколько непробельных символов.
```commandline
\$\d\$\S+
```
Сопоставьте все возможные IP-адреса IPv4 (используйте метасимволы и группы)
```commandline
(\d{1,3}\.){3}\d{1,3}
```
Сопоставьте все эти адреса электронной почты, а также добавьте имя пользователя и доменное имя (не TLD) в отдельных 
группах (используйте \w): hello@tryhackme.com , username@domain.com , dummy_email@xyz.com 
```commandline
(\w+)@(\w+)\.com
```
## Задание 6
Отличная работа.

Регулярные выражения очень мощные, даже в самом простом использовании. Есть много ресурсов для изучения и практики в 
Интернете, которые я настоятельно рекомендую. 

Кроме того, если вы планируете использовать регулярные выражения для разработки чего-либо и хотите выполнить поиск, 
например, адреса электронной почты, вам следует искать готовые выражения, а не писать свои собственные. 

Используя регулярные выражения, вам нужно мыслить конкретно, но не слишком конкретно, потому что тогда вы можете 
придумать сложные решения, когда есть другие, более элегантные и простые. 

### Ответьте на вопросы ниже
Спасибо!
```commandline
Ответ не нужен
```
[>> вернуться на главную страницу](https://github.com/BEPb/tryhackme/blob/master/README.md)