[>> вернуться на главную страницу](https://github.com/BEPb/tryhackme/blob/master/README.md)

# Комната [Linux Privilege Escalation](https://tryhackme.com/r/room/linprivesc) 

Всего 12 заданий:
## Задание 1
Повышение привилегий — это путешествие. Нет серебряных пуль, и многое зависит от конкретной конфигурации целевой 
системы. Версия ядра, установленные приложения, поддерживаемые языки программирования, пароли других пользователей — 
вот несколько ключевых элементов, которые повлияют на ваш путь к оболочке root.

Эта комната была разработана, чтобы охватить основные векторы повышения привилегий и дать вам лучшее понимание 
процесса. Этот новый навык станет неотъемлемой частью вашего арсенала, независимо от того, участвуете ли вы в CTF, 
сдаете ли сертификационные экзамены или работаете тестером на проникновение.

### Ответьте на вопросы ниже
Прочитайте вышеизложенное.
```commandline
Ответ не нужен
```

## Задание 2
Что означает «повышение привилегий»?

По своей сути, повышение привилегий обычно подразумевает переход от учетной записи с более низкими правами доступа к 
учетной записи с более высокими правами доступа. Более технически, это эксплуатация уязвимости, недостатка дизайна 
или упущения конфигурации в операционной системе или приложении для получения несанкционированного доступа к 
ресурсам, которые обычно ограничены для пользователей.

Почему это важно?

При выполнении реального теста на проникновение редко удается закрепиться (начальный доступ), который дает вам 
прямой административный доступ. Повышение привилегий имеет решающее значение, поскольку оно позволяет вам получить 
уровни доступа системного администратора, что позволяет вам выполнять такие действия, как: 
- Сброс паролей
- Обход контроля доступа с целью компрометации защищенных данных
- Редактирование конфигураций программного обеспечения
- Обеспечение настойчивости
- Изменение привилегий существующих (или новых) пользователей
- Выполнить любую административную команду
### Ответьте на вопросы ниже
Прочитайте вышеизложенное.
```commandline
Ответ не нужен
```

## Задание 3
Примечание: для продолжения запустите целевую машину, подключенную к этой задаче.
Вы можете запустить целевую машину и получить к ней доступ прямо из браузера.
Кроме того, вы можете получить к нему доступ по SSH, используя указанные ниже учетные данные пользователя с низкими 
привилегиями: 

Имя пользователя: Карен
Пароль: Пароль1

Перечисление — это первый шаг, который вам нужно предпринять, получив доступ к любой системе. Вы могли получить 
доступ к системе, используя критическую уязвимость, которая привела к доступу на уровне root, или просто нашли 
способ отправлять команды с использованием учетной записи с низкими привилегиями. В отличие от машин CTF, задания по 
тестированию на проникновение не заканчиваются после получения доступа к определенной системе или уровню привилегий 
пользователя. Как вы увидите, перечисление так же важно на этапе после компрометации, как и до этого. 

#### hostname
Команда hostname вернет имя хоста целевой машины. Хотя это значение можно легко изменить или оно может иметь 
относительно бессмысленную строку (например, Ubuntu-3487340239), в некоторых случаях оно может предоставить 
информацию о роли целевой системы в корпоративной сети (например, SQL -PROD-01 для производственного сервера SQL ).


#### uname -a
Выведет системную информацию, дающую нам дополнительные сведения о ядре, используемом системой. Это будет полезно 
при поиске любых потенциальных уязвимостей ядра, которые могут привести к повышению привилегий. 


#### /proc/version
Файловая система proc (procfs) предоставляет информацию о процессах целевой системы. Вы найдете proc во многих 
различных вариантах Linux, что делает ее необходимым инструментом в вашем арсенале.

Просмотр /proc/version может предоставить вам информацию о версии ядра и дополнительные данные, например, установлен 
ли компилятор (например, GCC).

#### /etc/issue
Системы также можно идентифицировать, посмотрев на /etc/issue файл. Этот файл обычно содержит некоторую информацию 
об операционной системе, но его можно легко настроить или изменить. Кстати, любой файл, содержащий системную 
информацию, можно настроить или изменить. Для более четкого понимания системы всегда полезно просмотреть все это.



#### ps команда
Команда ps является эффективным способом просмотра запущенных процессов в системе Linux . Ввод ps на терминале 
покажет процессы для текущей оболочки. 

Вывод ps (Состояние процесса) покажет следующее;
- PID : идентификатор процесса (уникальный для процесса)
- TTY: Тип терминала, используемый пользователем
- Время: количество процессорного времени, использованного процессом (это НЕ время, в течение которого этот процесс 
  выполнялся)
- CMD: запущенная команда или исполняемый файл (НЕ будут отображаться параметры командной строки)
Команда «ps» предоставляет несколько полезных опций.

- ps -A: Просмотреть все запущенные процессы
- ps axjf: Просмотр дерева процессов (см. формирование дерева до ps axjf запуска ниже)
- ps aux: Эта aux опция покажет процессы для всех пользователей (a), отобразит пользователя, запустившего процесс (u)
  , и покажет процессы, которые не прикреплены к терминалу (x). Рассматривая вывод команды ps aux, мы можем лучше 
  понять систему и потенциальные уязвимости.  

#### env
Команда env покажет переменные среды.

Переменная PATH может содержать компилятор или язык сценариев (например, Python), которые можно использовать для 
запуска кода в целевой системе или использовать для повышения привилегий.

#### sudo -l
Целевая система может быть настроена так, чтобы пользователи могли запускать некоторые (или все) команды с 
привилегиями root. Команда sudo -l может использоваться для перечисления всех команд, которые ваш пользователь может 
запускать с помощью sudo.

#### ls
Вероятно, одной из распространенных команд, используемых в Linux  является ls.

При поиске потенциальных векторов повышения привилегий не забывайте всегда использовать команду ls с -la параметром. 
В примере ниже показано, как файл «secret.txt» можно легко пропустить, используя команды ls или ls -l .

#### id
Команда id предоставит общий обзор уровня привилегий пользователя и его членства в группах.

Стоит помнить, что эту id команду можно использовать и для получения той же информации для другого пользователя, как 
показано ниже. 

#### /etc/passwd
Чтение /etc/passwd файла может быть простым способом обнаружения пользователей в системе.

Хотя вывод может быть длинным и немного пугающим, его можно легко сократить и преобразовать в полезный список для 
атак методом перебора.

Помните, что это вернет всех пользователей, некоторые из которых являются системными или сервисными пользователями, 
которые не будут очень полезны. Другой подход может заключаться в grep для «home», поскольку реальные пользователи, 
скорее всего, будут иметь свои папки в каталоге «home».

#### history
Просмотр более ранних команд с помощью  history команды может дать нам некоторое представление о целевой 
системе и, хотя и редко, сохранить такую информацию, как пароли или имена пользователей.


#### ifconfig
Целевая система может быть точкой поворота к другой сети. ifconfig Команда предоставит нам информацию о сетевых 
интерфейсах системы. В примере ниже показано, что целевая система имеет три интерфейса (eth0, tun0 и tun1). Наша 
атакующая машина может достичь интерфейса eth0, но не может напрямую получить доступ к двум другим сетям.

Это можно подтвердить с помощью ip route команды, которая позволяет увидеть, какие сетевые маршруты существуют.

#### netstat
После первоначальной проверки существующих интерфейсов и сетевых маршрутов стоит изучить существующие коммуникации. 
Команда netstatможет использоваться с несколькими различными опциями для сбора информации о существующих соединениях. 
- netstat -a: показывает все прослушиваемые порты и установленные соединения.
- netstat -at или netstat -au также может использоваться для перечисления протоколов TCP или UDP соответственно.
- netstat -l: список портов в режиме «прослушивания». Эти порты открыты и готовы принимать входящие соединения. Это 
  можно использовать с опцией «t», чтобы вывести только порты, которые прослушиваются с использованием протокола TCP 
  (ниже) 
- netstat -s: вывод статистики использования сети по протоколу (ниже) Это также можно использовать с параметрами -t 
или -u для ограничения вывода определенным протоколом. 

`netstat -tp`: список подключений с указанием имени службы и PID.

Эту функцию также можно использовать с -l опцией составления списка портов прослушивания (ниже).

Мы видим, что столбец « PID /Имя программы» пуст, поскольку этот процесс принадлежит другому пользователю.

Ниже приведена та же команда, запущенная с привилегиями root и отображающая эту информацию как 2641/nc (netcat)

`netstat -i`: Показывает статистику интерфейса. Ниже мы видим, что «eth0» и «tun0» более активны, чем «tun1».

Наиболее частое использование netstat, которое вы, вероятно, увидите в сообщениях блогов, статьях и курсах, netstat 
-ano можно разделить следующим образом: 
- -a: Показать все розетки
- -n: Не разрешать имена
- -o: Отображение таймеров

#### find
Поиск важной информации и потенциальных векторов эскалации привилегий в целевой системе может быть плодотворным. 
Встроенная команда «find» полезна и заслуживает того, чтобы ее иметь в своем арсенале. 

Ниже приведены несколько полезных примеров использования команды «найти».

Найти файлы:

`find . -name flag1.txt`: найти файл с именем «flag1.txt» в текущем каталоге
`find /home -name flag1.txt`: найдите имена файлов «flag1.txt» в каталоге /home
`find / -type d -name config`: найдите каталог с именем config в «/»
`find / -type f -perm 0777`: найти файлы с правами доступа 777 (файлы, доступные для чтения, записи и выполнения 
всем пользователям) 
`find / -perm a=x`: найти исполняемые файлы
`find /home -user frank`: найти все файлы пользователя «frank» в «/home»
`find / -mtime 10`: найти файлы, которые были изменены за последние 10 дней
`find / -atime 10`: найти файлы, к которым был доступ за последние 10 дней
`find / -cmin -60`: найти файлы, измененные за последний час (60 минут)
`find / -amin -60`: найти доступы к файлам за последний час (60 минут)
`find / -size 50M`: найти файлы размером 50 МБ
Эту команду также можно использовать со знаками (+) и (-), чтобы указать файл, который больше или меньше указанного 
размера. 



В примере выше возвращаются файлы размером более 100 МБ. Важно отметить, что команда «find» имеет тенденцию 
генерировать ошибки, что иногда затрудняет чтение вывода. Вот почему было бы разумно использовать команду «find» с 
«`-type f 2>/dev/null`», чтобы перенаправить ошибки в «`/dev/null`» и получить более чистый вывод (ниже).  

Папки и файлы, в которые можно записывать данные или из которых можно выполнять данные:

`find / -writable -type d 2>/dev/null`: Найти папки, доступные для записи всем пользователям
`find / -perm -222 -type d 2>/dev/null`: Найти папки, доступные для записи всем пользователям
`find / -perm -o w -type d 2>/dev/null`: Найти папки, доступные для записи всем пользователям

Причина, по которой мы видим три разные команды «find», которые потенциально могут привести к одному и тому же 
результату, указана в документе руководства. Как вы можете видеть ниже, параметр perm влияет на то, как работает «find». 


`find / -perm -o x -type d 2>/dev/null` : Найти папки с исполняемыми файлами world-executable
Найдите инструменты разработки и поддерживаемые языки:
```commandline
find / -name perl*
find / -name python*
find / -name gcc*
```

Найдите определенные разрешения для файлов:

Ниже приведен краткий пример, используемый для поиска файлов, у которых установлен бит SUID. Бит SUID позволяет 
файлу запускаться с уровнем привилегий учетной записи, которой он принадлежит, а не учетной записи, которая его 
запускает. Это позволяет использовать интересный путь повышения привилегий, который мы рассмотрим более подробно в 
задаче 6. Пример ниже приведен для завершения темы по команде «find».

`find / -perm -u=s -type f 2>/dev/null`: Поиск файлов с битом SUID, который позволяет запустить файл с более высоким 
уровнем привилегий, чем у текущего пользователя. 

#### Общие команды Linux
Поскольку мы находимся в сфере Linux, знакомство с командами Linux в целом будет очень полезным. Пожалуйста, 
потратьте некоторое время на освоение таких команд, как find, locate, grep, cut, sort, и т. д.

### Ответьте на вопросы ниже
Каково имя хоста целевой системы?
```commandline
wade7363
```

Какова версия ядра Linux целевой системы?
```commandline
3.13.0-24-generic
```

Что это за Linux?
```commandline
Ubuntu 14.04 LTS
```

Какая версия языка Python установлена в системе?
```commandline
2.7.6
```

Какая уязвимость, по-видимому, затрагивает ядро целевой системы? (Введите номер CVE)
```commandline
CVE-2015-1328
```

## Задание 4
Несколько инструментов могут помочь вам сэкономить время в процессе перечисления. Эти инструменты следует 
использовать только для экономии времени, зная, что они могут пропустить некоторые векторы повышения привилегий. 
Ниже приведен список популярных инструментов перечисления Linux со ссылками на соответствующие репозитории Github.

Среда целевой системы будет влиять на инструмент, который вы сможете использовать. Например, вы не сможете запустить 
инструмент, написанный на Python, если он не установлен на целевой системе. Вот почему лучше быть знакомым с 
несколькими, а не иметь один универсальный инструмент.

LinPeas : https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/tree/master/linPEAS
LinEnum: https://github.com/rebootuser/LinEnum
LES ( рекомендация по использованию эксплойтов для Linux ): https://github.com/mzet-/linux-exploit-suggester
Умное перечисление Linux : https://github.com/diego-treitos/linux-smart-enumeration
Проверка конфиденциальности Linux : https://github.com/linted/linuxprivchecker
#### Ответьте на вопросы ниже
Установите и попробуйте несколько автоматизированных инструментов подсчета в вашем локальном дистрибутиве Linux.

```commandline
Ответ не нужен
```

## Задание 5
Примечание: для продолжения запустите целевую машину, подключенную к этой задаче.

Вы можете запустить целевую машину и получить к ней доступ прямо из браузера.

Кроме того, вы можете получить к нему доступ по SSH, используя указанные ниже учетные данные пользователя с низкими 
привилегиями: 
Имя пользователя: Карен
Пароль: Пароль1

Повышение привилегий в идеале приводит к привилегиям root. Иногда этого можно достичь, просто эксплуатируя 
существующую уязвимость, или в некоторых случаях, получая доступ к другой учетной записи пользователя, которая имеет 
больше привилегий, информации или доступа.

Если только единственная уязвимость не приведет к получению root-оболочки, процесс повышения привилегий будет 
зависеть от неправильных настроек и слабых разрешений.

Ядро в системах Linux управляет связью между компонентами, такими как память системы и приложения. Эта критическая 
функция требует, чтобы ядро имело определенные привилегии; таким образом, успешный эксплойт потенциально приведет 
к привилегиям root.  


Методология эксплуатации ядра проста;
- Определите версию ядра
- Поиск и нахождение кода эксплойта для версии ядра целевой системы
- Запустить эксплойт

Хотя это выглядит просто, пожалуйста, помните, что неудачный эксплойт ядра может привести к сбою системы. Убедитесь, 
что этот потенциальный результат приемлем в рамках вашего задания по тестированию на проникновение, прежде чем 
пытаться эксплойт ядра.

Источники исследования:
- На основании полученных результатов вы можете использовать Google для поиска существующего кода эксплойта.
- Также могут быть полезны такие источники, как https://www.linuxkernelcves.com/cves .
- Другой альтернативой может стать использование скрипта типа LES ( Linux Exploit Suggester), но помните, что эти 
  инструменты могут генерировать ложные срабатывания (сообщать об уязвимости ядра, которая не влияет на целевую 
  систему) или ложные срабатывания (не сообщать об уязвимостях ядра, хотя ядро уязвимо). 


Советы/Примечания:
- Слишком конкретная версия ядра при поиске эксплойтов в Google, Exploit-db или searchsploit
- Убедитесь, что вы понимаете, как работает код эксплойта, ПРЕЖДЕ ЧЕМ его запускать. Некоторые коды эксплойта могут 
  вносить изменения в операционную систему, которые сделают их незащищенными при дальнейшем использовании или внесут 
  необратимые изменения в систему, создавая проблемы позже. Конечно, это может не быть большой проблемой в 
  лабораторной среде или среде CTF, но это абсолютное табу во время реального тестирования на проникновение.
- Некоторые эксплойты могут потребовать дальнейшего взаимодействия после запуска. Прочитайте все комментарии и 
  инструкции, предоставленные вместе с кодом эксплойта.
- Вы можете перенести код эксплойта со своего компьютера на целевую систему, используя SimpleHTTPServer модуль Python 
  и wget соответственно.

### Ответьте на вопросы ниже
найдите и используйте соответствующий эксплойт ядра, чтобы получить права root на целевой системе.
```commandline
Ответ не нужен
```
Каково содержимое файла flag1.txt?
```commandline
THM-28392872729920
```

## Задание 6
Примечание: для продолжения запустите целевую машину, подключенную к этой задаче.
Вы можете запустить целевую машину и получить к ней доступ прямо из браузера.
Кроме того, вы можете получить к нему доступ по SSH, используя указанные ниже учетные данные пользователя с низкими привилегиями:

Имя пользователя: Карен
Пароль: Пароль1
Команда `sudo` по умолчанию позволяет запускать программу с привилегиями root. В некоторых случаях системным 
администраторам может потребоваться предоставить обычным пользователям некоторую гибкость в отношении их привилегий. 
Например, младшему аналитику SOC может потребоваться регулярно использовать Nmap , но он не будет допущен к полному 
доступу root. В этой ситуации системный администратор может разрешить этому пользователю запускать Nmap только с 
привилегиями root, сохраняя при этом его обычный уровень привилегий во всей остальной системе.

Любой пользователь может проверить свою текущую ситуацию, связанную с привилегиями root, с помощью `sudo -l` команды.

https://gtfobins.github.io/ — ценный источник, предоставляющий информацию о том, как можно использовать любую 
программу, на которую у вас могут быть права sudo. 

Используйте функции приложения

Некоторые приложения не будут иметь известного эксплойта в этом контексте. Такое приложение, которое вы можете 
увидеть, — это сервер Apache2.

В этом случае мы можем использовать "хак" для утечки информации, используя функцию приложения. Как вы можете видеть 
ниже, Apache2 имеет опцию, которая поддерживает загрузку альтернативных файлов конфигурации ( -f: указать 
альтернативный ServerConfigFile).

Загрузка `/etc/shadow` файла с использованием этой опции приведет к появлению сообщения об ошибке, включающего первую 
строку файла `/etc/shadow`.

#### Используйте LD_PRELOAD

В некоторых системах вы можете увидеть параметр среды LD_PRELOAD.

LD_PRELOAD — это функция, которая позволяет любой программе использовать общие библиотеки. Эта запись в блоге даст 
вам представление о возможностях LD_PRELOAD. Если включена опция "env_keep", мы можем сгенерировать общую библиотеку,
которая будет загружена и выполнена до запуска программы. Обратите внимание, что опция LD_PRELOAD будет 
проигнорирована, если реальный идентификатор пользователя отличается от эффективного идентификатора пользователя.

Шаги этого вектора эскалации привилегий можно обобщить следующим образом:
- Проверьте наличие LD_PRELOAD (с опцией env_keep)
- Напишите простой код на языке C, скомпилированный как файл общего объекта (расширение .so)
- Запустите программу с правами sudo и опцией LD_PRELOAD, указывающей на наш файл .so

Код C просто создаст оболочку root и может быть записан следующим образом:
```commandline
#include <stdio.h>
#include <sys/types.h>
#include <stdlib.h>

void _init() {
unsetenv("LD_PRELOAD");
setgid(0);
setuid(0);
system("/bin/bash");
}
```
Мы можем сохранить этот код как shell.c и скомпилировать его с помощью gcc в общий объектный файл, используя 
следующие параметры: 

`gcc -fPIC -shared -o shell.so shell.c -nostartfiles`

Теперь мы можем использовать этот файл общего объекта при запуске любой программы, которую наш пользователь может 
запустить с помощью sudo. В нашем случае можно использовать Apache2, find или почти любую из программ, которые мы 
можем запустить с помощью sudo.

Нам необходимо запустить программу, указав опцию LD_PRELOAD, как показано ниже;

`sudo LD_PRELOAD=/home/user/ldpreload/shell.so find`

Это приведет к появлению оболочки с привилегиями root.


### Ответьте на вопросы ниже
Сколько программ может запустить пользователь «karen» на целевой системе с правами sudo?
```commandline
3
```
Каково содержимое файла flag2.txt?
```commandline
THM-402028394
```
Как бы вы использовали Nmap для запуска оболочки root, если бы у вашего пользователя были права sudo в nmap?
```commandline
sudo nmap --interactive
```
Каков хеш пароля Фрэнка?
```commandline
$6$2.sUUDsOLIpXKxcr$eImtgFExyr2ls4jsghdD3DHLHHP9X50Iv.jNmwo/BJpphrPRJWjelWEz2HH.joV14aDEwW1c3CahzB1uaqeLR1
```

## Задание 7
Примечание: для продолжения запустите целевую машину, подключенную к этой задаче.
Вы можете запустить целевую машину и получить к ней доступ прямо из браузера.
Кроме того, вы можете получить к нему доступ по SSH, используя указанные ниже учетные данные пользователя с низкими 
привилегиями: 
Имя пользователя: Карен
Пароль: Пароль1
Большая часть управления привилегиями Linux основана на контроле взаимодействия пользователей и файлов. Это делается 
с помощью разрешений. К настоящему моменту вы знаете, что файлы могут иметь разрешения на чтение, запись и 
выполнение. Они предоставляются пользователям в пределах их уровней привилегий. Это меняется с помощью SUID 
(Set-user Identification) и SGID (Set-group Identification). Они позволяют выполнять файлы с уровнем разрешений 
владельца файла или владельца группы соответственно.

Вы заметите, что у этих файлов установлен бит «s», показывающий их особый уровень разрешений.

`find / -type f -perm -04000 -ls 2>/dev/null` выведет список файлов, у которых установлены биты SUID или SGID.

Хорошей практикой было бы сравнить исполняемые файлы в этом списке с GTFOBins ( https://gtfobins.github.io ). 
Нажатие на кнопку SUID отфильтрует двоичные файлы, которые, как известно, могут быть использованы при установке бита 
SUID (вы также можете использовать эту ссылку для предварительно отфильтрованного списка  https://gtfobins.github.io/#+suid ).  

Список выше показывает, что у nano установлен бит SUID. К сожалению, GTFObins не дает нам легкой победы. Как и в 
реальных сценариях повышения привилегий, нам нужно будет найти промежуточные шаги, которые помогут нам использовать 
любые незначительные находки, которые у нас есть.

Примечание : Подключенная виртуальная машина имеет другой двоичный файл с SUID, отличным от nano.

Установленный бит SUID для текстового редактора nano позволяет нам создавать, редактировать и читать файлы, 
используя привилегии владельца файла. Nano принадлежит пользователю root, что, вероятно, означает, что мы можем 
читать и редактировать файлы с более высоким уровнем привилегий, чем у нашего текущего пользователя. На этом этапе у 
нас есть два основных варианта повышения привилегий: чтение файла /etc/shadowили добавление нашего пользователя в 
/etc/passwd.

Ниже приведены простые шаги с использованием обоих векторов.

чтение `/etc/shadow` файла

Мы видим, что в текстовом редакторе nano установлен бит SUID, выполнив команду 
`find / -type f -perm -04000 -ls 2>/dev/null`.

`nano /etc/shadow` распечатает содержимое файла /etc/shadow. Теперь мы можем использовать инструмент unshadow для 
создания файла, который может взломать John the Ripper . Для этого unshadow нужны как файлы , так /etc/shadowи /etc/passwd.

Использование инструмента Unshadow можно увидеть ниже;
`unshadow passwd.txt shadow.txt > passwords.txt`

С правильным списком слов и небольшой удачей, Джон Потрошитель может вернуть один или несколько паролей в открытом 
тексте. Для более подробной комнаты о Джоне Потрошителе, вы можете посетить  https://tryhackme.com/room/johntheripper0 

Другим вариантом было бы добавление нового пользователя с правами root. Это помогло бы нам обойти утомительный 
процесс взлома пароля. Ниже приведен простой способ сделать это:

Нам понадобится хэш-значение пароля, который мы хотим дать новому пользователю. Это можно быстро сделать с помощью 
инструмента openssl на Kali Linux.

Затем мы добавим этот пароль вместе с именем пользователя в /etc/passwd файл.

После добавления пользователя (обратите внимание, как root:/bin/bash это было использовано для предоставления 
root-оболочки) нам нужно будет переключиться на этого пользователя и, как мы надеемся, получить права root. 

Теперь ваша очередь использовать навыки, которым вас только что научили, чтобы найти уязвимый двоичный файл.

### Ответьте на вопросы ниже
Какой пользователь помнит имя великого автора комиксов?
```commandline
gerryconway
```
Какой пароль у пользователя user2?
```commandline
Password1
```
Каково содержимое файла flag3.txt?
```commandline
THM-3847834
```

## Задание 8
Примечание: для продолжения запустите целевую машину, подключенную к этой задаче.

Вы можете запустить целевую машину и получить к ней доступ прямо из браузера.

Кроме того, вы можете получить к нему доступ по SSH, используя указанные ниже учетные данные пользователя с низкими 
привилегиями: 

Имя пользователя: Карен
Пароль: Пароль1

Другой метод, который системные администраторы могут использовать для повышения уровня привилегий процесса или 
двоичного файла, — это «Возможности». Возможности помогают управлять привилегиями на более детальном уровне. 
Например, если аналитику SOC необходимо использовать инструмент, который должен инициировать соединения сокетов, 
обычный пользователь не сможет этого сделать. Если системный администратор не хочет предоставлять этому пользователю 
более высокие привилегии, он может изменить возможности двоичного файла. В результате двоичный файл выполнит свою 
задачу без необходимости в пользователе с более высокими привилегиями.
Страница руководства по возможностям содержит подробную информацию о его использовании и параметрах.

Мы можем использовать этот `getcap` инструмент для перечисления включенных возможностей.

При запуске от имени непривилегированного пользователя `getcap -r` /будет генерироваться огромное количество ошибок, 
поэтому хорошей практикой будет перенаправлять сообщения об ошибках в `/dev/null`. 

Обратите внимание, что ни vim, ни его копия не имеют установленного бита SUID. Поэтому этот вектор повышения 
привилегий не обнаруживается при перечислении файлов, ищущих SUID. 

`GTFObins` имеет хороший список двоичных файлов, которые можно использовать для повышения привилегий, если мы найдем 
какие-либо установленные возможности. 

Мы замечаем, что vim можно использовать со следующей командой и полезной нагрузкой:

Это запустит оболочку root, как показано ниже;


### Ответьте на вопросы ниже
Выполните описанную выше задачу на целевой системе.
```commandline
Ответ не нужен
```
Сколько двоичных файлов имеют заданные возможности?
```commandline
6
```
Какой еще двоичный файл можно использовать с его возможностями?
```commandline
view
```
Каково содержимое файла flag4.txt?
```commandline
THM-9349843
```

## Задание 9
Примечание: для продолжения запустите целевую машину, подключенную к этой задаче.
Вы можете запустить целевую машину и получить к ней доступ прямо из браузера.
Кроме того, вы можете получить к нему доступ по SSH, используя указанные ниже учетные данные пользователя с низкими 
привилегиями: 

Имя пользователя: Карен
Пароль: Пароль1
Задания cron используются для запуска скриптов или двоичных файлов в определенное время. По умолчанию они 
запускаются с привилегией их владельцев, а не текущего пользователя. Хотя правильно настроенные задания cron 
изначально не уязвимы, при некоторых условиях они могут обеспечить вектор повышения привилегий.  
Идея довольно проста: если есть запланированная задача, которая запускается с привилегиями root, и мы можем изменить 
скрипт, который будет запущен, то наш скрипт будет запущен с привилегиями root. 

Конфигурации заданий cron хранятся в виде crontab (таблиц cron), чтобы увидеть следующее время и дату запуска задачи. У каждого пользователя в системе есть свой файл crontab, и он может запускать определенные задачи независимо от того, вошел он в систему или нет. Как и следовало ожидать, нашей целью будет найти задание cron, установленное root, и заставить его запустить наш скрипт, в идеале оболочку.
Любой пользователь может прочитать файл, сохраняя общесистемные задания cron в `/etc/crontab`
Хотя на машинах CTF задания cron могут запускаться каждую минуту или каждые 5 минут, в ходе испытаний на 
проникновение вы чаще будете видеть задачи, которые запускаются ежедневно, еженедельно или ежемесячно. 

Вы можете видеть, что backup.sh скрипт был настроен на запуск каждую минуту. Содержимое файла показывает простой 
скрипт, который создает резервную копию файла prices.xls.

Поскольку наш текущий пользователь может получить доступ к этому скрипту, мы можем легко изменить его для создания 
обратного шелла, надеюсь, с правами root. 

Скрипт будет использовать инструменты, доступные в целевой системе, для запуска обратного шелла.
Два момента, которые следует отметить;

Синтаксис команды будет различаться в зависимости от доступных инструментов (например, nc вероятно, не будет 
поддерживать -e опцию, которую вы могли видеть в других случаях). 
Мы всегда должны отдавать предпочтение запуску обратных оболочек, поскольку мы не хотим ставить под угрозу 
целостность системы во время реального тестирования на проникновение. 
Файл должен выглядеть примерно так;

Теперь мы запустим прослушиватель на нашей атакующей машине для приема входящего соединения.

Crontab всегда стоит проверять, так как иногда он может привести к легким векторам эскалации привилегий. Следующий 
сценарий не редкость в компаниях, которые не имеют определенного уровня зрелости кибербезопасности: 
- Системным администраторам необходимо запускать скрипт через регулярные промежутки времени.
- Они создают cron-задание для этого.
- Через некоторое время скрипт становится бесполезным, и его удаляют.
- Они не очищают соответствующее задание cron
Эта проблема управления изменениями приводит к потенциальной уязвимости, использующей задания cron.

В примере выше показана похожая ситуация, когда скрипт antivirus.sh был удален, но задание cron все еще существует.
Если полный путь к скрипту не определен (как это было сделано для скрипта backup.sh), cron будет ссылаться на пути, 
перечисленные в переменной PATH в файле /etc/crontab. В этом случае мы должны иметь возможность создать скрипт с 
именем «antivirus.sh» в домашней папке нашего пользователя, и он должен быть запущен заданием cron.

Файл в целевой системе должен выглядеть знакомо:

Входящее обратное соединение shell имеет привилегии root:

В странном случае, если вы обнаружите существующий скрипт или задачу, прикрепленную к заданию cron, всегда стоит 
потратить время на то, чтобы понять функцию скрипта и то, как любой инструмент используется в контексте. Например, 
tar, 7z, rsync и т. д. можно эксплуатировать с помощью их функции wildcard.  

### Ответьте на вопросы ниже
Сколько заданий cron, определенных пользователем, вы видите в целевой системе?
```commandline
4
```
Каково содержимое файла flag5.txt?
```commandline
THM-383000283
```
Какой пароль у Мэтта?
```commandline
123456
```

## Задание 10
Примечание: для продолжения запустите целевую машину, подключенную к этой задаче.

Вы можете запустить целевую машину и получить к ней доступ прямо из браузера.

Кроме того, вы можете получить к нему доступ по SSH, используя указанные ниже учетные данные пользователя с низкими привилегиями:



Имя пользователя: Карен

Пароль: Пароль1
Если папка, для которой у вашего пользователя есть разрешение на запись, находится в пути, вы потенциально можете 
перехватить приложение для запуска скрипта. PATH в Linux — это переменная среды, которая сообщает операционной 
системе, где искать исполняемые файлы. Для любой команды, которая не встроена в оболочку или не определена с 
абсолютным путем, Linux начнет поиск в папках, определенных в PATH. (PATH — это переменная среды, о которой мы здесь 
говорим, path — это местоположение файла).

Обычно PATH выглядит следующим образом:

Если мы введем «thm» в командной строке, это будут те места, где Linux будет искать исполняемый файл с именем thm. 
Сценарий ниже даст вам лучшее представление о том, как это можно использовать для повышения уровня наших привилегий. 
Как вы увидите, это полностью зависит от существующей конфигурации целевой системы, поэтому убедитесь, что вы можете 
ответить на вопросы ниже, прежде чем пытаться это сделать.

Какие папки находятся в $PATH
Имеет ли ваш текущий пользователь права на запись в какие-либо из этих папок?
Можете ли вы изменить $PATH?
Есть ли скрипт/приложение, которые можно запустить и которые будут подвержены этой уязвимости?

Для демонстрационных целей мы будем использовать следующий скрипт:

Этот скрипт пытается запустить системный двоичный файл под названием «thm», но пример можно легко повторить с любым 
двоичным файлом. 

Мы компилируем это в исполняемый файл и устанавливаем бит SUID.

Теперь наш пользователь имеет доступ к скрипту «path» с установленным битом SUID.

После запуска «path» будет искать исполняемый файл с именем «thm» внутри папок, перечисленных в PATH.

Если какая-либо доступная для записи папка указана в PATH, мы можем создать двоичный файл с именем thm в этом 
каталоге и запустить его с помощью нашего скрипта «path». Поскольку бит SUID установлен, этот двоичный файл будет 
запущен с привилегиями root  



Простой поиск папок, доступных для записи, можно выполнить с помощью `find / -writable 2>/dev/null` команды « ». Вывод 
этой команды можно очистить с помощью простой последовательности вырезания и сортировки.

Некоторые сценарии CTF могут представлять разные папки, но обычная система выведет что-то вроде того, что мы видим выше.

Сравнение этого с PATH поможет нам найти папки, которые мы можем использовать.

Мы видим несколько папок в /usr, поэтому было бы проще еще раз выполнить поиск доступных для записи папок, чтобы 
охватить подпапки. 


Альтернативой может быть команда ниже.

`find / -writable 2>/dev/null | cut -d "/" -f 2,3 | grep -v proc | sort -u`

Мы добавили «`grep -v proc`», чтобы избавиться от множества результатов, связанных с запущенными процессами.


К сожалению, подпапки в /usr не доступны для записи.


Папка, в которую будет проще записать, вероятно, /tmp. На этом этапе, поскольку /tmp отсутствует в PATH, нам нужно 
будет добавить его. Как мы видим ниже, команда « export PATH=/tmp:$PATH» выполняет это.


На этом этапе сценарий пути также будет искать исполняемый файл с именем «thm» в папке /tmp.

Создать эту команду довольно просто, скопировав /bin/bash как «thm» в папку /tmp.

Мы дали права на исполнение нашей копии /bin/bash, обратите внимание, что на этом этапе она будет работать с правами 
нашего пользователя. Что делает возможным повышение привилегий в этом контексте, так это то, что сценарий path 
работает с привилегиями root.  

### Ответьте на вопросы ниже
К какой папке у вас есть доступ на запись?
```commandline
/home/murdoch
```
Воспользуйтесь уязвимостью $PATH, чтобы прочитать содержимое файла flag6.txt.
```commandline
Ответ не нужен
```
Каково содержимое файла flag6.txt?
```commandline
THM-736628929
```
## Задание 11
Примечание: для продолжения запустите целевую машину, подключенную к этой задаче.
Вы можете запустить целевую машину и получить к ней доступ прямо из браузера.
Кроме того, вы можете получить к нему доступ по SSH, используя указанные ниже учетные данные пользователя с низкими 
привилегиями: 
Имя пользователя: Карен

Пароль: Пароль1


Векторы повышения привилегий не ограничиваются внутренним доступом. Общие папки и интерфейсы удаленного управления, 
такие как SSH и Telnet, также могут помочь вам получить root-доступ в целевой системе. В некоторых случаях также 
потребуется использовать оба вектора, например, найти закрытый ключ SSH root в целевой системе и подключиться через 
SSH с привилегиями root вместо того, чтобы пытаться повысить уровень привилегий текущего пользователя. 

Другой вектор, который более актуален для CTF и экзаменов, — это неправильно настроенная сетевая оболочка. Этот 
вектор иногда можно увидеть во время испытаний на проникновение, когда присутствует система резервного копирования 
сети.  

Конфигурация NFS (Network File Sharing) хранится в файле `/etc/exports`. Этот файл создается во время установки 
сервера NFS и обычно может быть прочитан пользователями. 

Критический элемент для этого вектора повышения привилегий — это опция «no_root_squash», которую вы видите выше. По 
умолчанию NFS изменит пользователя root на nfsnobody и лишит любой файл возможности работать с привилегиями root. 
Если опция «no_root_squash» присутствует в доступном для записи общем ресурсе, мы можем создать исполняемый файл с 
установленным битом SUID и запустить его на целевой системе.   

Начнем с перечисления монтируемых общих ресурсов с нашей атакующей машины.

Мы смонтируем один из общих ресурсов «no_root_squash» к нашей атакующей машине и начнем сборку нашего исполняемого файла.

Поскольку мы можем установить биты SUID, то для этой задачи подойдет простой исполняемый файл, который запустит 
`/bin/bash` на целевой системе. 

После компиляции кода мы установим бит SUID.

Ниже вы увидите, что оба файла (nfs.c и nfs присутствуют в целевой системе. Мы работали с смонтированным общим 
ресурсом, поэтому не было необходимости их переносить). 

Обратите внимание, что исполняемый файл nfs имеет установленный бит SUID в целевой системе и запускается с 
привилегиями root. 

### Ответьте на вопросы ниже
Сколько монтируемых общих ресурсов вы можете определить в целевой системе?
```commandline
3
```
На скольких ресурсах включена опция «no_root_squash»?
```commandline
3
```
Получите root-доступ на целевой системе.
```commandline
Ответ не нужен
```
Каково содержимое файла flag7.txt?
```commandline
THM-89384012
```

## Задание 12
К настоящему моменту вы уже достаточно хорошо понимаете основные векторы повышения привилегий в Linux, и эта задача 
должна оказаться для вас довольно простой. 

Вы получили доступ SSH к крупному научному объекту. Попробуйте повысить свои привилегии, пока не станете Root.
Мы разработали эту комнату, чтобы помочь вам создать тщательную методологию повышения привилегий Linux, которая 
будет очень полезна на экзаменах, таких как OSCP, и в ваших заданиях по тестированию на проникновение. 

Не оставляйте неисследованными ни один вектор эскалации привилегий, поскольку эскалация привилегий зачастую является 
скорее искусством, чем наукой. 

Вы можете получить доступ к целевой машине через браузер или использовать указанные ниже учетные данные SSH.

Имя пользователя: леонард
Пароль: Penny123
### Ответьте на вопросы ниже
Каково содержимое файла flag1.txt?
```commandline
THM-42828719920544
```
Каково содержимое файла flag2.txt?
```commandline
THM-168824782390238
```


[>> вернуться на главную страницу](https://github.com/BEPb/tryhackme/blob/master/README.md)