[>> вернуться на главную страницу](https://github.com/BEPb/tryhackme/blob/master/README.md)

# Комната [Advanced SQL Injection](https://tryhackme.com/r/room/advancedsqlinjection) 

Всего 5 заданий:
## Задание 1
SQL-инъекция остается одной из самых серьезных и распространенных уязвимостей безопасности веб-приложений. Эта 
угроза возникает, когда злоумышленник использует способность веб-приложения выполнять произвольные SQL- запросы, что 
приводит к несанкционированному доступу к базе данных, эксфильтрации данных, манипулированию данными или даже 
полному контролю над приложением. В этой комнате мы разберемся с передовыми методами SQL -инъекции, что обеспечит 
всестороннее понимание сложных векторов атак и стратегий смягчения.

К концу этой комнаты вы будете иметь более глубокое понимание различных методов SQL-инъекций. Это даст вам навыки 
выявления и использования этих уязвимостей в различных сценариях и внедрения надежной защиты для защиты ваших 
приложений.

#### Цели обучения

В ходе изучения этой аудитории вы получите полное представление о следующих ключевых концепциях:
- SQL-инъекция второго порядка 
- Фильтр уклонения
- Внеполосная SQL- инъекция
- Методы автоматизации
- Меры по смягчению последствий

Предпосылки обучения

Перед началом занятий рекомендуется изучить следующие темы:

- SQL- инъекция
- SQLMAP
- Топ-10 OWASP
- Nmap
Подключение к машине

Вы можете запустить виртуальную машину, нажав Start Machine кнопку, прикрепленную к этой задаче. Вы можете получить 
доступ к виртуальной машине с помощью AttackBox или вашего VPN- подключения. Позже в комнате мы воспользуемся 
уязвимым приложением для практического выполнения упражнения и ознакомления с различными векторами атак. Пожалуйста, 
подождите 1-2 минуты после полной загрузки системы, чтобы позволить автоматическим скриптам успешно выполниться.

Прежде чем погрузиться в работу, крайне важно четко понимать версию базы данных и сведения об операционной системе 
целевой машины. Для этого мы можем использовать Nmap, мощный инструмент сканирования сети, для тщательного 
сканирования MACHINE_IP. Это сканирование предоставит ценную информацию об открытых портах, запущенных службах и 
операционной системе целевой машины. Тем, кто не знаком с Nmap, мы рекомендуем просмотреть нашу всеобъемлющую 
комнату Nmap, чтобы быстро освоить эффективное использование этого инструмента. Вот вывод Nmap после сканирования 
машины:


Терминал
```commandline
thm@machine$ nmap -A -T4 -p 3306,3389,445,139,135 MACHINE_IP

Starting Nmap 7.60 ( https://nmap.org ) at 2024-05-25 12:03 BST
Nmap scan report for MACHINE_IP
Host is up (0.00034s latency).

PORT     STATE    SERVICE       VERSION
135/tcp  open     msrpc
139/tcp  open     netbios-ssn
445/tcp  open     microsoft-ds
3306/tcp open     mysql
3389/tcp open     ms-wbt-server Microsoft Terminal Services
| ssl-cert: Subject: commonName=SQLi
| Not valid before: 2024-05-23T04:08:44
|_Not valid after:  2024-11-22T04:08:44
|_ssl-date: 2024-05-25T11:03:33+00:00; 0s from scanner time.
MAC Address: 02:87:BD:21:12:33 (Unknown)
Warning: OSScan results may be unreliable because we could not find at least 1 open and 1 closed port
Device type: specialized
Running (JUST GUESSING): AVtech embedded (87%)
Aggressive OS guesses: AVtech Room Alert 26W environmental monitor (87%)
No exact OS matches for host (test conditions non-ideal).
Network Distance: 1 hop
Service Info: OS: Windows; CPE: cpe:/o:microsoft:windows

OS and Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
Nmap done: 1 IP address (1 host up) scanned in 17.67 seconds
```
Машина использует службу MySQL на Windows.

Начнем! 

### Ответьте на вопросы ниже
На каком порту работает служба MySQL?
```commandline
3306
```

## Задание 2
В последней комнате SQL -инъекции мы исследовали основы SQL -инъекции, понимая, как злоумышленники используют 
уязвимости в веб-приложениях для манипулирования SQL- запросами и доступа к несанкционированным данным. Мы 
рассмотрели основные методы, такие как SQL -инъекции на основе ошибок и объединений, а также методы слепой SQL 
-инъекции, такие как атаки на основе булевых значений и времени. Вот краткий обзор комнаты, охватывающей основные 
типы SQL -инъекций.

#### типы SQL-инъекций

Внутриполосная SQL- инъекция

Этот метод считается наиболее распространенным и простым типом атаки SQL -инъекцией. В этом методе злоумышленник 
использует один и тот же канал связи как для инъекции, так и для извлечения данных. Существует два основных типа 
**внутриполосной SQL- инъекции**:

- Error-Based SQL Injection : Злоумышленник манипулирует SQL- запросом, чтобы выдавать сообщения об ошибках из базы 
данных. Эти сообщения об ошибках часто содержат информацию о структуре базы данных, которую можно использовать для 
  дальнейшей эксплуатации базы данных. Пример: SELECT * FROM users WHERE id = 1 AND 1=CONVERT(int, (SELECT @@version)
  ). Если в сообщении об ошибке возвращается версия базы данных, это раскрывает информацию о базе данных.
- SQL - инъекция на основе объединения : злоумышленник использует SQL- оператор UNION для объединения результатов двух 
  или более операторов SELECT в один результат, тем самым извлекая данные из других таблиц. Пример: SELECT name, 
  email FROM users WHERE id = 1 UNION ALL SELECT username, password FROM admin.

**Выводная (слепая) SQL- инъекция**

Inferential SQL injection не передает данные напрямую через веб-приложение, что делает его эксплуатацию более 
сложной. Вместо этого злоумышленник отправляет полезные данные и наблюдает за поведением приложения и временем 
отклика, чтобы сделать вывод о базе данных. Существует два основных типа inferential SQL injection:

- Слепая инъекция SQL на основе логических значений: злоумышленник отправляет SQL- запрос в базу данных, заставляя 
приложение возвращать другой результат в зависимости от истинного или ложного условия. Анализируя ответ приложения, 
  злоумышленник может сделать вывод о том, была ли полезная нагрузка истинной или ложной. Пример: SELECT * FROM 
  users WHERE id = 1 AND 1=1 (true condition) versus SELECT * FROM users WHERE id = 1 AND 1=2 (false condition).  
  Злоумышленник может сделать вывод о результате, если содержимое или поведение страницы изменятся в зависимости от 
  условия.
- Слепая инъекция SQL-кода с задержкой по времени: злоумышленник отправляет SQL- запрос в базу данных, что 
  задерживает ответ на указанное время, если условие истинно. Измеряя время ответа, злоумышленник может сделать 
  вывод, является ли условие истинным или ложным. Например, SELECT * FROM users WHERE id = 1; IF (1=1) WAITFOR 
  DELAY '00:00:05'--. Если ответ задерживается на 5 секунд, злоумышленник может сделать вывод, что условие было 
  истинным.

**Внеполосная SQL- инъекция**

Внеполосная инъекция SQL используется, когда злоумышленник не может использовать тот же канал для запуска атаки и 
сбора результатов или когда ответы сервера нестабильны. Этот метод основан на том, что сервер базы данных делает 
внеполосный запрос (например, HTTP или DNS) для отправки результата запроса злоумышленнику. HTTP обычно используется 
при внеполосной инъекции SQL для отправки результата запроса на  сервер злоумышленника.  Мы подробно обсудим это в 
этой комнате.

Каждый тип техники SQL -инъекции имеет свои преимущества и проблемы. Понимание этих техник имеет решающее значение 
для выявления и устранения уязвимостей SQL -инъекции в веб-приложениях. Внутриполосная SQL -инъекция легко 
эксплуатируется и обнаруживается, но она шумная и легко отслеживается. Выводная (слепая) SQL -инъекция сложнее в 
эксплуатации и требует множественных запросов, но может использоваться, когда подробные сообщения об ошибках 
недоступны. Внеполосная SQL- инъекция встречается реже и очень эффективна, требует внешнего управления сервером и 
полагается на способность базы данных делать внеполосные запросы. Освоив эти техники, тестировщики на проникновение 
могут эффективно выявлять и эксплуатировать уязвимости SQL -инъекции, помогая организациям защищать свои 
веб-приложения от этих критических угроз.

### Ответьте на вопросы ниже
Какой тип SQL-инъекции использует один и тот же канал связи для инъекции и извлечения данных?

```commandline
In-band
```
Какой протокол обычно используется для отправки результатов запроса на сервер злоумышленника при внеполосной SQL-инъекции?
```commandline
HTTP
```

## Задание 3
SQL -инъекция второго порядка, также известная как хранимая SQL -инъекция, использует уязвимости, при которых 
вводимые пользователем данные сохраняются и впоследствии используются в другой части приложения, возможно, после 
некоторой начальной обработки. Этот тип атаки более коварен, поскольку вредоносный SQL-код не обязательно должен 
немедленно приводить к ошибке синтаксиса SQL или другим очевидным проблемам, что затрудняет его обнаружение с 
помощью стандартных методов проверки ввода. Инъекция происходит при втором использовании данных, когда они 
извлекаются и используются в команде SQL, отсюда и название «Второй порядок».

диаграмма рабочего процесса SQL-инъекции второго порядка

Влияние

Опасность SQL-инъекции второго порядка заключается в ее способности обходить типичные фронтальные защиты, такие как 
базовая проверка или очистка ввода, которые происходят только в точке начального ввода данных. Поскольку полезная 
нагрузка не вызывает сбоев на первом этапе, ее можно не заметить, пока не станет слишком поздно, что делает атаку 
особенно скрытной.

Пример
Мы будем использовать приложение для обзора книг. Приложение позволяет пользователям добавлять новые книги через 
веб-страницу (add.php). Пользователям предлагается предоставить сведения о книге, которую они хотят добавить в базу 
данных. Вы можете получить доступ к приложению по адресу http://MACHINE_IP/second/add.php. Собранные данные включают 
SSN, book_name, и author. Давайте рассмотрим добавление книги со следующими данными: SSN: UI00012, Название книги: 
Введение в PHP, Автор: Тим. Эта информация вводится через форму на add.php странице и после отправки сохраняется в 
базе данных BookStore, как показано ниже:

добавление новой книги в базу данных

Как мы знаем, SQL- инъекции второго порядка особенно сложно обнаружить. В отличие от традиционных SQL- инъекций, 
которые используют уязвимости обработки в реальном времени, они происходят, когда данные, ранее сохраненные в базе 
данных, позже используются в SQL- запросе. Обнаружение этой уязвимости часто требует понимания того, как данные 
проходят через приложение и используются повторно, что требует глубоких знаний внутренних операций.

Анализ Кодекса

Рассмотрим фрагмент PHP- кода, используемый в нашем приложении для добавления книг:

```commandline
if (isset($_POST['submit'])) {

    $ssn = $conn->real_escape_string($_POST['ssn']);

    $book_name = $conn->real_escape_string($_POST['book_name']);

    $author = $conn->real_escape_string($_POST['author']);

    $sql = "INSERT INTO books (ssn, book_name, author) VALUES ('$ssn', '$book_name', '$author')";

    if ($conn->query($sql) === TRUE) {

        echo "<p class='text-green-500'>New book added successfully</p>";

    } else {

        echo "<p class='text-red-500'>Error: " . $conn->error . "</p>";

    }

}
```
Код использует real_escape_string()метод для экранирования специальных символов во входных данных. Хотя этот метод 
может снизить некоторые риски немедленной инъекции SQL путем экранирования одинарных кавычек и других метасимволов 
SQL , он не защищает приложение от SQLi второго порядка. Ключевой проблемой здесь является отсутствие 
параметризованных запросов, что необходимо для предотвращения атак с использованием инъекции SQL . Когда данные 
вставляются с использованием real_escape_string()метода, они могут включать символы полезной нагрузки, которые не 
наносят немедленного вреда, но могут быть активированы при последующем извлечении и использовании в другом запросе 
SQL . Например, вставка книги с таким названием Intro to PHP'; DROP TABLE books;--может не повлиять на операцию 
INSERT , но может иметь серьезные последствия, если имя книги впоследствии будет использовано в другом контексте SQL 
без надлежащей обработки.

Давайте попробуем добавить еще одну книгу с SSN test'.

общее количество книг в базе данных

Итак, SSN test'успешно вставлен в базу данных. Приложение включает функцию обновления сведений о книге через 
интерфейс, такой как update.php. Этот интерфейс может отображать существующие сведения о книге в полях редактируемой 
формы, извлеченных на основе ранее сохраненных данных, а затем обновлять их на основе ввода пользователя. Пентестер 
будет исследовать, использует ли приложение повторно данные (например, book_name), которые были ранее сохранены и 
потенциально испорчены. Затем он будет строить SQL- запросы для обновления записей, используя эти потенциально 
испорченные данные без надлежащей очистки или параметризации. Манипулируя функцией обновления, тестер может увидеть, 
выполняется ли вредоносная полезная нагрузка, добавленная на этапе вставки, во время операции обновления. Если 
приложение не применяет надлежащие методы безопасности на этом этапе, ранее внедренная полезная нагрузка '; DROP 
TABLE books; -- может быть активирована, что приведет к выполнению вредоносной команды SQL, такой как удаление 
таблицы. Вы можете посетить страницу, http://MACHINE_IP/second/update.phpчтобы обновить любые сведения о книге.

обновить панель управления содержимым книги

Теперь давайте рассмотрим update.php код. Скрипт PHP позволяет пользователям обновлять сведения о книгах в базе 
данных BookStore . С помощью структуры запроса мы проанализируем типичный сценарий, в котором тестер на 
проникновение может искать уязвимости SQL- инъекции, уделяя особое внимание тому, как обрабатываются и используются 
пользовательские данные в SQL- запросах.

```commandline
if ( isset($_POST['update'])) {
    $unique_id = $_POST['update'];
    $ssn = $_POST['ssn_' . $unique_id];
    $new_book_name = $_POST['new_book_name_' . $unique_id];
    $new_author = $_POST['new_author_' . $unique_id];

    $update_sql = "UPDATE books SET book_name = '$new_book_name', author = '$new_author' WHERE ssn = '$ssn'; INSERT INTO logs (page) VALUES ('update.php');";
..
...
```
Скрипт начинается с проверки того, является ли метод запроса POST и была ли нажата кнопка обновления, что указывает 
на то, что пользователь намерен обновить данные книги. После этого скрипт извлекает вводимые пользователем данные 
непосредственно из данных POST:

```commandline
    $unique_id = $_POST['update'];
    $ssn = $_POST['ssn_' . $unique_id];
    $new_book_name = $_POST['new_book_name_' . $unique_id];
    $new_author = $_POST['new_author_' . $unique_id];
```
Эти переменные ( ssn, new_book_name, new_author) затем используются для построения SQL-запроса для обновления данных указанной книги в базе данных:

```commandline
$update_sql = "UPDATE books SET book_name = '$new_book_name', author = '$new_author' WHERE ssn = '$ssn'; INSERT INTO logs (page) VALUES ('update.php');";
```
Скрипт использует multi_query для выполнения нескольких запросов. Он также вставляет логи в таблицу журналов для 
аналитических целей.

Подготовка полезной нагрузки

Мы знаем, что можем добавлять или изменять данные книги на основе их ssn. Обычный запрос на обновление книги может 
выглядеть так: 
```commandline
UPDATE books SET book_name = '$new_book_name', author = '$new_author' WHERE ssn = '123123';
```
Однако команда SQL может быть изменена, если злоумышленник вставит специально созданное ssnзначение. Например, если 
злоумышленник использует ssn значение:
```commandline
12345'; UPDATE books SET book_name = 'Hacked'; --
```
Когда это значение используется в запросе на обновление, оно фактически завершает начальную команду обновления после 
12345и начинает новую команду. Это изменит book_name всех записей в таблице books на Hacked.

Давайте сделаем это

Начальная вставка полезной нагрузки : добавляется новая книга с полезной нагрузкой, 12345'; UPDATE books SET 
book_name = 'Hacked'; --вставленной как ssn. Точка с запятой ( ;) будет использоваться для завершения текущего 
оператора SQL.
общее количество книг в базе данных с полезной нагрузкой инъекции

Вредоносное выполнение SQL : После этого, когда администратор или любой другой пользователь посещает URL  
http://MACHINE_IP/second/update.php и обновляет книгу, вставленная полезная нагрузка вырывается из предполагаемой 
структуры команды SQL и внедряет новую команду, которая обновляет все записи в таблице книг. Давайте посетим 
страницу   http://MACHINE_IP/second/update.php page, обновим имя книги на что угодно и нажмем  кнопку Обновить . Код 
выполнит следующий оператор в бэкэнде.

UPDATE books SET book_name = 'Testing', author = 'Hacker' WHERE ssn = '12345'; Update books set book_name ="hacked"; --'; INSERT INTO logs (page) VALUES ('update.php');
Комментирование остального : Двойной тире ( --) — это символ комментария SQL . Все, что следует далее, --будет проигнорировано сервером SQL , что фактически нейтрализует любые оставшиеся части исходного оператора SQL , которые могут вызвать ошибки или раскрыть атаку. После выполнения указанного выше запроса он изменит название всех книг на hacked , как показано ниже:
состояние базы данных после выполнения полезной нагрузки

В этой задаче мы исследовали концепцию SQL- инъекции второго порядка через уязвимое веб-приложение для обзора книг. 
Для тестировщика на проникновение крайне важно изучить, как хранятся и впоследствии используются в SQL- запросах 
данные пользователя. Это включает в себя проверку того, что все формы обработки данных защищены от таких уязвимостей,
подчеркивая важность тщательного тестирования и знания методов безопасности для защиты от угроз инъекций.

### Ответьте на вопросы ниже
Каково значение флага после обновления названия всех книг на «скомпрометировано»?
```commandline
THM{SO_HACKED}
```
Каково значение флага после удаления таблицы hello из базы данных?
```commandline
THM{Table_Dropped}
```

## Задание 4

```commandline
Ответ не нужен
```

## Задание 5

```commandline
Ответ не нужен
```

[>> вернуться на главную страницу](https://github.com/BEPb/tryhackme/blob/master/README.md)