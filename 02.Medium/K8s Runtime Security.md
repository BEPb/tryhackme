[>> вернуться на главную страницу](https://github.com/BEPb/tryhackme/blob/master/README.md)

# Комната [K8s Runtime Security](https://tryhackme.com/r/room/k8sruntimesecurity) 

Всего 5 заданий:
## Задание 1
Добро пожаловать в очередную комнату безопасности Kubernetes, где продолжится квест по становлению подкованного в 
вопросах безопасности инженера DevSecOps. Как инженер DevSecOps, вы можете безопасно настроить свою среду 
Kubernetes и сконфигурировать свой кластер, следуя лучшим практикам отрасли k8s, избежав при этом некоторых ловушек 
с архитектурой микросервисов. Сделав все это, вы можете спокойно отдыхать, думая, что ваш кластер защищен от ошибок 
и хакеров. К сожалению, этот гипотетический пузырь вот-вот лопнет, так как в этой комнате мы узнаем об угрозах, 
которые могут возникнуть после запуска контейнерного приложения. То есть во время выполнения.

Безопасность во время выполнения или, в нашем случае, безопасность во время выполнения Kubernetes, может быть одним 
из самых сложных аспектов безопасности кластера. Как инженеры DevSecOps, мы должны обеспечить защиту среды 
Kubernetes от известных уязвимостей или атак. Тем не менее, уязвимость иногда возникает после запуска нашего 
приложения (угроза нулевого дня). Атаки также могут происходить во время выполнения, например, попытки повышения 
привилегий. Безопасность во время выполнения можно рассматривать как последнюю линию обороны. В идеале наши 
безопасные конфигурации кластера и такие вещи, как RBAC, предотвратят любые попытки взлома вашей среды Kubernetes, 
но реальность такова, что иногда хакеры находят новые эксплойты или пробелы в конфигурациях; как инженеры DevSecOps, 
мы должны убедиться, что эти события обнаружены. Пришло время продолжить ваше время в Kubernetes Laboratories, 
изучая все тонкости безопасности во время выполнения Kubernetes, доступные нам предложения и их реализацию в 
кластере Kubernetes.


Предпосылки обучения

Поскольку это комната безопасности Kubernetes, предполагается, что основы Kubernetes (описано в Intro to Kubernetes )
находятся в вашей голове, а также знание базовой технологии, на которой построен Kubernetes (описано в Intro to 
Containerisation и Intro to Docker). Введение в эту комнату упоминает гипотетическую ситуацию, когда кластер 
Kubernetes был безопасно настроен, соответствует лучшим практикам безопасности Kubernetes и разработан с учетом 
проблем, связанных с архитектурой микросервисов. Эти знания рекомендуются и рассматриваются в следующих комнатах: 
Cluster Hardening, K8s Best Security Practices и Microservices Architecture.

Цели обучения 

- Понять аудит Kubernetes и то, как его можно использовать для отслеживания и устранения неполадок в событиях 
безопасности.
- Понять различные проблемы и решения, связанные с безопасностью выполнения в Kubernetes.
- Изучите Falco, принципы его работы и способы его использования в кластере Kubernetes для обнаружения угроз в 
  реальном времени.
- Понять важность сквозного мониторинга и то, как другие инструменты могут работать вместе с Falco для достижения 
  этой цели.
### Ответьте на вопросы ниже
Нажмите, чтобы перейти к следующему заданию!
```commandline
Ответ не нужен
```

## Задание 2
Мы начнем эту комнату с рассмотрения того, что Kubernetes построил, что может помочь нам в наших поисках безопасной 
среды выполнения. Спойлеры: это не так много, но важно понимать, что Kubernetes предлагает и как это можно 
использовать для безопасности среды выполнения. Прежде чем определить, что предоставляется, давайте представим себе 
сценарий, в котором это необходимо. Представьте себе: вы занимаетесь своими делами, занимаетесь DevSecOps, и вдруг 
замечаете что-то странное. Вы видите, что модули, запущенные в развертывании, не работают с тем образом, который им 
положено. Кто-то изменил образ на тот, который вы не узнаете. Это не обсуждалось ни на одном из ваших 
стендап-совещаний и не упоминалось ни в каких сообщениях. У вас много вопросов, и первое место, куда вы 
отправляетесь за ответами, — это журналы. Затем вы проверяете события (содержащиеся в выводе команды kubectl 
describe), но все еще не можете найти то, что ищете. Вам нужно что-то, что может сказать вам, когда этот ресурс был 
изменен и кто выполнил изменение. Эта информация (а также другая информация, полезная в контексте безопасности) 
фиксируется в журнале аудита с помощью Kubernetes Auditing.

Kubernetes Auditing предоставляет пользователям/администраторам кластера набор хронологических записей, которые 
документируют последовательности действий в кластере. Эти записи полезны в контексте безопасности, поскольку они 
регистрируют действия, выполняемые пользователями, приложениями (которые используют Kubernetes API) и самой 
плоскостью управления, которые могут предоставить ценную информацию, отвечая на такие вопросы, как:

вопросы аудита

В типичном производственном кластере будет МНОГО событий. Теперь мы рассмотрим, как можно настроить наш кластер для 
захвата определенных событий. Однако перед этим нам нужно понять два термина, которые имеют решающее значение при 
определении наших критериев для события аудита: этапы и уровни.

Этапы 

Журнал аудита может быть записан на различных этапах запроса в компоненте kube-apiserver (куда отправляются все 
запросы). Различные этапы определяются следующим образом:

RequestReceived : Обработчик аудита (в kube-apiserver) получил запрос, но ответ пока не сгенерирован.

ResponseStarted : Это когда заголовки ответа были отправлены, но тело ответа не было. Этот этап будет присутствовать 
только для длительных запросов, таких как «wait» ( команда Kubernetes, которую вы можете использовать для ожидания 
выполнения условия, например, текущего состояния ресурса).

ResponseCompleted : Когда тело ответа завершено и отправлено.

Паника : это событие генерируется при возникновении паники (критическая ошибка, приводящая к сбою).



диаграмма стадии ответа

Уровни

Мы используем уровни, чтобы сообщить Kubernetes, сколько данных о событиях мы хотим зафиксировать в нашем журнале 
аудита. Всего существует четыре уровня. По мере повышения уровня фиксируется больше данных:

None — сообщает Kubernetes, что не следует регистрировать этот запрос. 

Метаданные — это указывает Kubernetes регистрировать только метаданные запроса. 

Запрос — сообщает Kubernetes о необходимости регистрировать метаданные запроса и тело запроса.

RequestResponse — сообщает Kubernetes о необходимости регистрировать метаданные запроса, тело запроса и тело ответа.

Определение политики аудита

Теперь, когда этапы и уровни определены, мы рассмотрим, как мы определяем, какие события мы хотим проверять (и какие 
данные должны быть включены) в нашем кластере Kubernetes с помощью политики аудита. Официальная документация 
Kubernetes определяет пример политики аудита, который мы можем рассмотреть сейчас:

```commandline
apiVersion: audit.k8s.io/v1 # This is required.
kind: Policy
# Don't generate audit events for all requests in RequestReceived stage.
omitStages:
  - "RequestReceived"
rules:
  # Log pod changes at RequestResponse level
  - level: RequestResponse
    resources:
    - group: ""
      # Resource "pods" doesn't match requests to any subresource of pods,
      # which is consistent with the RBAC policy.
      resources: ["pods"]
  # Log "pods/log", "pods/status" at Metadata level
  - level: Metadata
    resources:
    - group: ""
      resources: ["pods/log", "pods/status"]

  # Don't log requests to a configmap called "controller-leader"
  - level: None
    resources:
    - group: ""
      resources: ["configmaps"]
      resourceNames: ["controller-leader"]

  # Don't log watch requests by the "system:kube-proxy" on endpoints or services
  - level: None
    users: ["system:kube-proxy"]
    verbs: ["watch"]
    resources:
    - group: "" # core API group
      resources: ["endpoints", "services"]

  # Don't log authenticated requests to certain non-resource URL paths.
  - level: None
    userGroups: ["system:authenticated"]
    nonResourceURLs:
    - "/api*" # Wildcard matching.
    - "/version"

  # Log the request body of configmap changes in kube-system.
  - level: Request
    resources:
    - group: "" # core API group
      resources: ["configmaps"]
    # This rule only applies to resources in the "kube-system" namespace.
    # The empty string "" can be used to select non-namespaced resources.
    namespaces: ["kube-system"]

  # Log configmap and secret changes in all other namespaces at the Metadata level.
  - level: Metadata
    resources:
    - group: "" # core API group
      resources: ["secrets", "configmaps"]

  # Log all other resources in core and extensions at the Request level.
  - level: Request
    resources:
    - group: "" # core API group
    - group: "extensions" # Version of group should NOT be included.

  # A catch-all rule to log all other requests at the Metadata level.
  - level: Metadata
    # Long-running requests like watches that fall under this rule will not
    # generate an audit event in RequestReceived.
    omitStages:
      - "RequestReceived"
```

Обратите внимание, что поле «правило» должно содержаться в политике аудита, чтобы оно было действительным. Все 
правила, определенные в этом поле, затем оцениваются в порядке сверху вниз. 

Давайте теперь рассмотрим некоторые передовые практики, которые следует учитывать при определении политик аудита:

- Для конфиденциальных ресурсов (всех, что содержит конфиденциальную информацию, например секреты или карты 
конфигурации) регистрируйте только на уровне метаданных; в противном случае конфиденциальная информация будет включена в журнал аудита.
- URL-адреса только для чтения обычно не должны регистрироваться. Учитывая контекст, для чего нам нужны наши журналы 
  аудита (попытка найти информацию о событиях, связанных с безопасностью, таких как изменение ресурса), URL-адреса только для чтения вряд ли будут задействованы, поэтому их отсутствие в журнале может сократить объем журналов, значительно упростив поиск нужной нам информации.
- Общая передовая практика заключается в том, чтобы регистрировать все ресурсы (не только для чтения URL) по крайней 
  мере на уровне метаданных, а если ресурс критически важен, он должен быть зарегистрирован на уровне 
  RequestResponse (если только не содержится конфиденциальная информация). Ниже приведен пример политики аудита, 
  которая регистрирует все ресурсы на уровне метаданных.
```commandline
# Log all requests at the Metadata level.
apiVersion: audit.k8s.io/v1
kind: Policy
rules:
- level: Metadata
```
Прежде чем закончить эту задачу, давайте рассмотрим еще один пример. Мы рассмотрели, что позволяет нам делать 
Kubernetes Auditing и как мы можем использовать политики аудита для определения того, на каком этапе следует 
захватывать журнал аудита и сколько данных должно быть для него захвачено. Осталось рассмотреть только одно. Журнал 
аудита! Вот пример того, как может выглядеть журнал аудита при захвате события создания пода:

```commandline
{
  "kind": "Event",
  "apiVersion": "audit.k8s.io/v1",
  "level": "Request",
  "auditID": "3928b929-4c7d—8243-e5ea-4fc57cfd5c9a",
  "stage": "ResponseComplete",
  "requestURI": "/api/v1/namespaces/default/pods",
  "verb": "create",
  "user": {
    "username": "system:serviceaccount:default:example-suspicious-user",
    "groups": [
      "system:serviceaccounts",
      "system:serviceaccounts:default",
      "system:authenticated"
    ]
  },
  "sourceIPs": [],
  "userAgent": "kubectl/v1.18.0 (linux/amd64) kubernetes/9e99141",
  "objectRef": {
    "resource": "pods",
    "namespace": "default",
    "name": "my-pod"
  },
  "responseStatus": {
    "code": 201
  },
  "requestReceivedTimestamp": "2024-07-18T10:15:30.000Z",
  "stageTimestamp": "2024-07-18T10:15:31.000Z"
}
```
Еще одна вещь, которую следует учитывать инженеру DevSecOps , заключается в том, что они должны быть защищены после 
захвата этих журналов аудита. Журналы аудита после захвата могут быть защищены с помощью таких методов, как 
безопасная передача (обеспечение включения TLS) и контроль доступа (ограничение доступа к журналам аудита с помощью 
RBAC). Это все с точки зрения общего обзора аудита Kubernetes и того, как его можно использовать для обнаружения 
определенной активности в нашем кластере во время выполнения. Ответьте на вопросы ниже, прежде чем перейти к 
следующему заданию!

### Ответьте на вопросы ниже
На каком этапе запроса будут отправлены заголовки ответа, но не тело ответа?
```commandline
ResponseStarted
```
Какой уровень позволит собрать больше всего данных?
```commandline
RequestResponse
```
Какое поле должно содержаться в политике аудита, чтобы она была действительной?
```commandline
rule
```
На каком уровне рекомендуется регистрировать конфиденциальные ресурсы (например, секреты)? 
```commandline
Metadata
```

## Задание 3
Сдвиг влево, щит вправо

Безопасность во время выполнения была представлена во вводной задаче как практика обеспечения безопасности 
приложений во время выполнения; вы можете думать обо всех усилиях до выполнения (безопасная настройка, укрепление 
кластера и т. д.) как о поддержке ключевой концепции DevSecOps о смещении влево. Обеспечение безопасности на месте и 
рассмотрение ее на самых первых этапах разработки. Когда мы обсуждаем безопасность во время выполнения, мы 
фокусируемся на том, как мы защищаем право. То есть, гарантируем, что наши приложения защищены во время выполнения. 
В этой задаче мы более подробно рассмотрим, как этого можно добиться с помощью Kubernetes, различные виды 
инструментов, которые могут нам в этом помочь, и некоторые из базовых концепций, которые позволяют этим инструментам 
работать.

сдвиг влево, щит вправо

Эфемерная проблема

Итак, прежде чем углубляться в то, какие инструменты могут помочь нам защититься, обнаруживая угрозы времени 
выполнения в нашей среде Kubernetes, давайте рассмотрим эфемерного слона в комнате. Одной из самых больших проблем в 
обеспечении безопасности контейнеризированной среды, например, развернутой в Kubernetes, является отслеживание 
событий. Это связано с эфемерной природой контейнеров, то есть они часто недолговечны. Разворачиваются для 
выполнения скрипта или для обработки возросшей рабочей нагрузки, а затем снова разворачиваются. Фактически, Sysdig, 
которые предоставляют очень ценную информацию в своем ежегодном «Отчете о безопасности и использовании облачных 
вычислений», обнаружили в своем последнем отчете (2024), что колоссальные 70% контейнеров живут менее 5 минут, как 
показано ниже.

Статистика срока службы контейнера

Это создает проблему в мире цифровой криминалистики, мире, с которым нам нужно взаимодействовать, чтобы устранять 
неполадки событий безопасности во время выполнения или предотвращать их возникновение в первую очередь. Из-за их 
короткого жизненного цикла, это устранение неполадок не будет выполняться в источнике события, контейнере, как в 
монолитном приложении, поскольку он больше не будет существовать. Это также вызывает проблемы при извлечении 
информации, такой как IP-адреса, поскольку эта информация будет доступна вместе с идентификатором контейнера. Тем не 
менее, весьма вероятно, что новый контейнер (с новым IP) будет развернут на его месте к тому времени, когда это 
расследование будет проводиться. Представьте себе попытку расследовать преступление, где сцена преступления исчезает 
через 5 минут. Поэтому, за исключением плагина Шерлока Холмса, нам нужно начать искать другие инструменты, которые 
помогут нам защитить наш Kubernetes во время выполнения.

эфемерное место преступления

Инструменты безопасности среды выполнения Kubernetes

Как уже говорилось в предыдущей задаче, Kubernetes не предлагает многого с точки зрения безопасности во время 
выполнения. Он предлагает нам журналы аудита через Kubernetes Auditing, что позволяет нам отслеживать запросы 
ресурсов в нашем кластере. Однако он ничего не делает с этой информацией. Никакого анализа не выполняется, и 
оповещения не выдаются. Если мы хотим вывести нашу безопасность во время выполнения Kubernetes на новый уровень, нам 
нужна помощь. Это сторонние инструменты, которые позволяют нам блокировать нашу среду Kubernetes во время выполнения.
Существует два типа инструментов безопасности во время выполнения Kubernetes: инструменты обеспечения выполнения и 
инструменты аудита. Прежде чем мы рассмотрим несколько примеров, важно понять системные вызовы, поскольку многие из 
этих инструментов используют их для обеспечения/аудита безопасности в среде выполнения.

Системные вызовы

Системные вызовы — это важная концепция безопасности, которую нужно понимать, особенно в контексте безопасности во 
время выполнения. Системные вызовы (или системные вызовы) — это связь, которая происходит между запущенным процессом 
(в пользовательском пространстве) и ядром (в ОС). Эта связь происходит, когда запущенный процесс не имеет 
необходимых разрешений для выполнения задачи, поскольку пользовательское пространство, в котором выполняются 
процессы, строго ограничено в отличие от пространства ядра, которое имеет неограниченный доступ к 
аппаратным/системным ресурсам. Таким образом, запущенный процесс просит ядро выполнить указанную задачу от его 
имени. Эти системные вызовы полезны для определения того, что процесс пытается сделать во время выполнения, и, 
следовательно, важны для определения дальнейших действий. Сделав это, давайте рассмотрим некоторые из доступных нам 
инструментов безопасности во время выполнения.

системные вызовы

Инструменты обеспечения безопасности во время выполнения

Инструменты обеспечения безопасности во время выполнения позволяют вам определять политики, которые могут 
минимизировать влияние угрозы, когда она появляется в вашей среде выполнения. Это делается путем ограничения прав 
доступа и разрешений ресурсов в среде. Другими словами, это инструменты смягчения угроз, а не их предотвращения. Вы 
можете подумать: «Ух ты, это действительно очень похоже на RBAC», и вы не ошибетесь. RBAC и инструменты обеспечения 
похожи по своей природе в том, что они не позволяют контейнерам выполнять определенные действия, но ключевое отличие 
здесь заключается в том, что инструменты обеспечения обеспечивают контроль доступа на уровне ядра. Это очень полезно 
в контексте DevSecOps, поскольку это практически обеспечивает второй уровень безопасности. В сценарии, когда среда 
Kubernetes скомпрометирована, эти инструменты обеспечения, которые работают на уровне ядра, могут смягчить влияние, 
например, скомпрометированного контейнера, ограничив его доступ к внешним ресурсам. Давайте теперь рассмотрим 
некоторые примеры этих инструментов.

AppArmour : AppArmour определяет себя как «легкую в использовании» систему безопасности приложений Linux. Это модуль 
ядра, который защищает как операционную систему, так и приложения от внутренних и внешних угроз. В AppArmour можно 
определить политики, которые обеспечивают хорошее поведение, предотвращая использование известных и неизвестных 
(например, атак нулевого дня) уязвимостей приложений. Политики, вкратце, определяют, к каким системным ресурсам 
приложение может получить доступ и с какими привилегиями.

Seccomp : Seccomp (от англ. secure computing mode) — это инструмент принудительного исполнения, работающий на уровне 
ядра. Он работает путем фильтрации системных вызовов, разрешая только обработанным выполнять определенные вызовы 
(exit(), sigreturn(), read() и write()) для уже открытых файловых дескрипторов (уникальный идентификатор процесса 
для файла или другого ресурса ввода/вывода). Это безопасное состояние принудительно обеспечивается с помощью Seccomp,
и если процесс пытается выполнить любой другой вызов, он завершается ядром с помощью SYGKILL или SYGSYS. Профили 
Seccomp — это политики в формате JSON, которые определяют, какие системные вызовы разрешены, и действие по умолчанию 
при попытке других вызовов. Kubernetes позволяет автоматически применять профили Seccomp к модулям/контейнерам. 
Подробнее об этом здесь.

SELinux : SELinux очень похож на AppArmour в том, что это модуль ядра, который позволяет реализовать элементы 
управления доступом для защиты среды выполнения. Решение между AppArmour и SELinux в первую очередь сводится к 
личным предпочтениям, а не к каким-либо значительным спорам о плюсах и минусах. Преимущества таких инструментов, как 
SELinux, AppArmour и SELinux, заключаются в том, что они не ограничены средами Kubernetes, а всеми рабочими 
нагрузками Linux, поэтому они могут принести пользу установкам, использующим комбинацию контейнеров и виртуальных 
машин.

Инструменты аудита

Когда мы говорим об инструментах аудита в этом контексте, мы говорим о расширении аудита Kubernetes, которое 
поставляется из коробки. Инструменты аудита в этом контексте используются для обнаружения угроз в реальном времени, 
то есть анализа журнала аудита/события, чтобы можно было предпринять ответные действия (при желании). Лучшим 
примером инструмента, который подходит для этой цели для рабочей нагрузки Kubernetes, является Falco. Falco 
является очень важным инструментом, когда речь идет о безопасности среды выполнения Kubernetes, настолько важным, 
что он заслуживает собственных задач. Итак, без лишних слов, ответьте на вопросы ниже и перейдите в следующую 
комнату, где мы подробно рассмотрим Falco.

### Ответьте на вопросы ниже
Какой процент контейнеров проживет менее 5 минут в 2024 году согласно годовому отчету, представленному в этом задании?
```commandline
70
```
Какая концепция безопасности, рассматриваемая в этой задаче, представляет собой взаимодействие, осуществляемое между 
запущенным процессом и ядром? 
```commandline
System Calls
```
Какой инструмент обеспечения безопасности во время выполнения фильтрует системные вызовы, разрешая выполнять только 
определенные вызовы к уже открытым файловым дескрипторам?
```commandline
Seccomp
```

## Задание 4
Решение головной боли

К настоящему моменту, как мы надеемся, должно было быть ясно, что обеспечение безопасности контейнерной среды во 
время выполнения сопряжено со многими сложностями и трудностями. Эфемерная природа контейнеров представляет собой 
сложную задачу для криминалистики основ облачных вычислений, усложняя определение того, как выглядит вторжение. 
Больше нет единой точки входа, где периметральный брандмауэр может стоять на страже, определяя, что можно впускать 
или выпускать. Теперь у нас есть доступные извне контейнерные рабочие нагрузки, которые можно масштабировать вверх 
или вниз. Как же, при всех этих трудностях, мы можем обнаруживать угрозы в режиме реального времени в контейнерном 
рабочем процессе, таком как наша среда Kubernetes ? С помощью изящного инструмента под названием Falco!

рецепт фалько

Что такое Фалько?

Falco — это механизм обнаружения угроз во время выполнения. В двух словах, он анализирует поведение системы (в нашем 
случае представьте себе среду Kubernetes), сравнивает наблюдаемое поведение со списком предопределенных условий 
угроз и, что особенно важно, активирует оповещение, если обнаружено положительное совпадение. Таким образом, Falco 
можно рассматривать как камеру безопасности для современных приложений. Он отслеживает поведение и оповещения на 
основе определенных результатов, но НЕ отключает никакие обнаруженные угрозы (конечно, конвейеры автоматизации могут 
быть настроены для обработки определенных видов угроз, но важно отметить, что это не входит в функционал Falco). 
Falco был создан Sysdig и по состоянию на 2024 год достиг стадии выпуска CNCF (Cloud Native Computing Foundation), и 
поэтому является фактическим стандартом для обнаружения вторжений в облачных средах.

камера безопасности falco

Звучит здорово, не так ли? Но работает ли это? Как Falco этого достигает? Что ж, Falco может получить глубокую 
видимость активности контейнера, хоста и кластера, анализируя системные вызовы ядра (как упоминалось в последней 
задаче). Помимо системных вызовов ядра, Falco может анализировать события из других источников данных, в частности, 
в нашем случае Kubernetes, через журналы аудита Kubernetes (как описано в задаче 2). Вдобавок к этому Falco добавила 
контекст приложения Kubernetes к своим выводам, чтобы предоставить улучшенные сведения, значительно упростив нашу 
жизнь как инженера DevSecOps. Ниже приведен обзор архитектуры Falco. Мы подробно рассмотрим, как работает Falco, 
чтобы все эти части и то, как они связаны, были понятны.Обзорная диаграмма falco

eBPF против модулей ядра

Прежде чем углубляться во внутреннюю работу Falco, важно понять, как работает одна из основных технологий, на 
которой она построена. Эта технология — eBPF (расширенный фильтр пакетов Berkely). Выше упоминалось, что Falco 
работает, извлекая информацию из анализа системных вызовов ядра; именно здесь eBPF играет свою роль. eBPF — это 
технология ядра Linux, которая позволяет инженерам создавать программы, которые безопасно работают в пространстве 
ядра. Пространство ядра строго ограничено, и на то есть веская причина, поскольку ошибка или сбой в программе ядра 
может вызвать панику ядра, повреждение данных и всевозможные катастрофы. Именно из-за этого приложения, работающие в 
пространстве пользователя, блокируются от прямого доступа к пространству ядра. Однако это вызывает проблемы в 
контексте безопасности, поскольку блокировка доступа к пространству ядра ограничивает видимость низкоуровневых 
сетевых и событий безопасности. Эти события имеют решающее значение для работы таких инструментов, как Falco, и для 
других инструментов, которые предоставляют информацию о безопасности.

eBPF — еще один герой, пришедший на помощь инженерам в борьбе за безопасность их сред. Он решает эту проблему, 
позволяя программам работать в защищенной среде в пространстве ядра, что гарантирует безопасность кода перед 
выполнением. Эти программы можно прикреплять к различным хукам и событиям в системе, что позволяет таким 
инструментам, как Falco, иметь более глубокий уровень доступа к работе ядра, что позволяет проводить глубокий анализ 
событий безопасности без увеличения риска сбоя системы.

eBPF

Другой метод анализа системных операций на уровне ядра — использование модулей ядра. Модули ядра позволяют инженерам 
расширять функциональность ядра, что можно сделать, загрузив пользовательский код в ядро. Модули ядра можно 
использовать для сбора подробной информации о выполнении процесса (такой как переключение контекста процесса, 
создание и завершение). Модуль ядра — это драйвер по умолчанию, который будет включен при установке Falco.

Мы собираемся подробно рассказать о рабочем процессе Falco и ключевых компонентах, которые позволяют ему работать. 
Одним из этих ключевых компонентов являются драйверы, то есть то, как события системных вызовов захватываются в 
пространстве ядра. Вот почему были определены eBPF и модули ядра, так как это два варианта драйверов, доступных в 
Falco. Самым важным фактором, который будет определять решение о том, какой драйвер вам следует выбрать, является 
возможность установки модулей ядра в среде. Некоторые среды (например, GKE и Google Kubernetes Engine) не разрешают 
(или не доверяют) модулям ядра, поэтому для этого экземпляра будет выбран eBPF. Конечно, есть и другие факторы, 
такие как безопасность, изоляция, производительность и т. д., которые следует учитывать, но для этого урока важно 
понимать только то, что оба эти метода захватывают информацию о системных вызовах в пространстве ядра. Еще одно 
важное замечание в контексте этой комнаты заключается в том, что оба этих драйвера будут работать в среде Kubernetes.

Рабочий процесс Falco

Взгляните на схему ниже. Она иллюстрирует, как Falco работает под капотом: 

схема рабочего процесса falco

Давайте попробуем лучше понять это, проследив событие от его возникновения как системного вызова в пространстве ядра 
до его оценки и анализа в Falco. Во-первых, системный вызов происходит в пространстве ядра, и любой установленный 
драйвер (например,  модуль ядра  или  зонд eBPF  ) собирает информацию об этом событии. Затем эта информация 
помещается в кольцевой буфер (механизм, который ядро Linux предоставляет для эффективной связи между пространством 
ядра и пространством пользователя). Затем эта информация собирается  libscap  (библиотекой для захвата системы), 
библиотекой пользовательского пространства, которая пересылает эти события в  libinsp  (а также реализует сбор 
состояния ОС и чтение/запись файлов scap, где хранятся захваченные системные события и информация о состоянии). 
Libinsp (библиотека для проверки системы) обогащает события, полученные от libscap, состоянием машины (текущее 
состояние системы, в какой среде произошло это событие? и т. д.), добавляя контекст к необработанным событиям. Эти 
обогащенные события оцениваются механизмом  правил , который будет подробно рассмотрен в следующей задаче. Если 
событие соответствует правилу (включенному по умолчанию или определенному пользователем), оно генерирует оповещение, 
которое отправляется в программу пользовательского пространства Falco.  Затем программа Falco  отправляет оповещение 
в любой настроенный канал оповещения. Доступные каналы оповещения: стандартный вывод, файл, Syslog, порожденная 
программа, конечная точка HTTP (S), клиент через API gRPC или, наконец, Falco sidekick (рассматривается в 
предстоящей задаче).

Это много информации, и это так, потому что решение таких проблем, как трудности обнаружения угроз в реальном 
времени в облачной среде, такой как среда Kubernetes, требует многого. Эта «подкапотная» логика позволяет Falco 
анализировать события из системных вызовов, а также из других источников, таких как журналы аудита Kubernetes , 
предоставлять ценные сведения о безопасности и предупреждать нас об их наличии. Уделите немного времени, чтобы 
информация усвоилась, еще раз взгляните на диаграммы в этой задаче и попробуйте визуализировать рабочий процесс, 
если хотите, прежде чем отвечать на вопросы ниже и переходить к следующей задаче, где мы рассмотрим Falco с 
практической/пользовательской точки зрения.

### Ответьте на вопросы ниже
Falco может получить глубокую видимость в среде выполнения Kubernetes, анализируя события из различных источников. Какой источник (охваченный в задаче 3) доступен в Kubernetes?
```commandline
Audit Logs
```
Что позволяет пользовательским программам безопасно работать в защищенной среде внутри пространства ядра?
```commandline
eBPF
```
Обогащенные события сравниваются с _____, которые могут быть включены по умолчанию или определены пользователем. 
```commandline
rules
```

## Задание 5
Предыдущая задача определила, как работает Falco. В этой задаче будут обсуждаться некоторые ключевые концепции Falco, которые позволяют нам, как инженерам DevSecOps, раскрыть истинную мощь инструмента. Сначала мы рассмотрим, как работает механизм правил, упомянутый в предыдущей задаче. Как уже было сказано, механизм правил получает обогащенные события для анализа. Эти события могут поступать из различных источников, таких как системные вызовы и события журнала аудита K8s, но другие источники могут быть добавлены с помощью плагинов. Плагины включают в себя множество интересных опций, таких как устройства IoT и тому подобное, но они немного выходят за рамки этой комнаты. Затем эти события сравниваются с набором правил, включая некоторые предопределенные Falco и пользовательские правила, созданные пользователем. Теперь мы рассмотрим, как определяются правила, чтобы вы могли использовать их для обнаружения пользовательских событий времени выполнения.

двигатель правил

Создание правила

Как уже упоминалось, вы можете усилить защиту среды выполнения K8s, настроив обнаружение угроз в реальном времени с помощью правил Falco. Мы узнаем, как, будучи инженером DevSecOps, вы могли бы написать эти правила Falco. Правило Falco определяется в YAML. Ниже приведен пример пустого правила YAML с обязательными полями. Мы пройдемся по каждому из полей и начнем заполнять это правило по мере продвижения:
```commandline
- rule: 
  desc: 
  condition:
  output:  
  priority: 

```
Поля правила и описания таковы, как они звучат. Правило может быть названо так, как считает нужным пользователь, а описание должно описывать цель роли. Далее следует поле условия, вероятно, самая важная часть определения правила. Поле условия состоит из различных «условий» (например, имя процесса = bash) и операторов (например, and, or); события будут сравниваться с этими условиями и операторами, и если «TRUE», то будет срабатывать оповещение. Теперь мы рассмотрим синтаксис условий в правиле Falco. Чтобы начать понимать синтаксис, давайте посмотрим, как выглядит условие, которое выдает оповещение, когда оболочка bash запускается внутри контейнера:

```commandline
container.id != host and proc.name = bash
```
Этот оператор ищет событие, которое произошло в контейнере (если событие происходит в хостовой системе, container.id будет равен host; поэтому это событие проверяет обратное, гарантируя, что событие произошло в контейнере) и что запущенный процесс — это bash (proc.run = bash). Однако в настоящее время это условие будет выполняться не только при запуске оболочки bash внутри контейнера, но и при каждом последующем событии, которое произойдет после (потому что мы не указали конкретный системный вызов для фильтрации, поэтому все события, такие как создание файла и т. д., будут соответствовать этим критериям). Это приведет к переполнению систем оповещений, что является плохой практикой. Чтобы лучше настроить наше оповещение, мы можем добавить некоторые условия, чтобы гарантировать, что оповещение срабатывает только при успешной попытке оболочки. Как уже упоминалось, это происходит, потому что мы не указали системный вызов для фильтрации. Мы можем указать это, указав тип события (evt.type):

```commandline
evt.type = execve and evt.dir = < and container.id != host and proc.name = bash
```
Тип события, который мы фильтруем, проверяет порожденный процесс (execve). Evt.dir означает направление события, значение ">" является событием входа и означает, что системный вызов вызван, т. е. Falco обнаружил намерение выполнить системный вызов. Значение "< " является событием выхода и означает, что оно происходит после того, как системный вызов был выполнен; мы используем это в нашем контексте, чтобы Falco определил, когда был порожден процесс, т. е. пользователь успешно запустил оболочку bash в контейнере. Хорошо, это много синтаксиса (и если вы жаждете большего, не стесняйтесь углубиться в то, что возможно с условиями  здесь ), поэтому давайте сделаем шаг назад и заполним этот шаблон тем, что мы узнали на данный момент:
```commandline
- rule: container_shell_detection
  Desc: a rule that detects shell activity in a container
  condition: >
    evt.type = execve and 
    evt.dir = < and 
    container.id != host and 
    proc.name = bash  
  output:  
  priority: 
```
Далее у нас есть вывод. Вывод используется для предоставления некоторой информации в оповещении. Вы можете заполнить это поле текстовой строкой, описывающей событие и справочные поля (те же, которые доступны вам при создании условия), чтобы предоставить дополнительные метаданные, окружающие событие. Это делается путем добавления символа процента (%) перед полями; значение этого поля затем будет возвращено как его значение при выводе (что-то вроде printf, если вы знакомы). Так, например, если бы мы хотели, чтобы наш вывод включал имя пользователя, идентификатор контейнера, имя контейнера, имя процесса, родительский процесс и командную строку, используемую для вызова процесса, ваше поле вывода выглядело бы следующим образом:
```commandline
Shell Detected in Container 
(user=%user.name container_id=%container.id container_name=%container.name 
shell=%proc.name parent=%proc.pname cmdline=%proc.cmdline) 
```
Наконец, у нас есть приоритет, который используется для категоризации серьезности события и включается в вывод оповещения. Возможные варианты: Emergency, Alert, Critical, Error, Warning, Notice, Informational и Debug. Для наших целей давайте выберем "Warning". Соединим все это вместе, и у нас будет полностью определенное правило:
```commandline
- rule: container_shell_detection
  Desc: a rule that detects shell activity in a container
  condition: >
    evt.type = execve and 
    evt.dir = < and 
    container.id != host and 
    proc.name = bash  
  output: >     
     Shell Detected in Container 
    (user=%user.name container_id=%container.id container_name=%container.name 
    shell=%proc.name parent=%proc.pname cmdline=%proc.cmdline) 
  priority: WARNING
```
Эффективность правил с макросами и списками

Теперь, когда вы знаете, как определить правило Falco, давайте посмотрим, как мы можем сделать эти правила более эффективными и облегчить нашу жизнь с помощью макросов и списков. Давайте начнем с макросов.

макросы и списки

Макросы  используются в определении правил Falco как способ сокращения условий, которые часто используются в нескольких правилах; это экономит время, то есть условие, которое используется повторно, не нужно вводить каждый раз. Одна из причин, по которой был выбран приведенный выше пример, заключается в том, что определенные условия очень распространены в определении правил Falco. Настолько распространено, что это условие рассматривается в документации Falco при обсуждении определения правил, и по умолчанию существует два макроса, которые можно использовать для сокращения двух из приведенных выше условий:

Макрос по умолчанию для состояния контейнера существует, но он будет определен следующим образом:
```commandline
- macro: container
  condition: container.id != host
```
Макрос по умолчанию для условия порожденного процесса существует, но он будет определен следующим образом:
```commandline
- macro: spawned_process
  condition: evt.type = execve and evt.dir = <
```
Если оба этих макроса определены, наше поле условия больше не нужно будет определять следующим образом:
```commandline
condition: >
    evt.type = execve and 
    evt.dir = < and 
    container.id != host and 
    proc.name = bash
```
Но вот так:
```commandline
condition: >
    spawned_process and 
    container and 
    proc.name = bash 
```
И правила, и макросы определены в файле rules/falco_rules.yaml. Однако при развертывании в кластере Kubernetes этот файл будет содержаться в модуле Falco в /etc/falcoкаталоге.

Далее у нас есть списки, которые являются удобным способом ссылаться на коллекцию «элементов» в условии. Элементами может быть что угодно, от процессов, которые вы хотите проверить, до каталога, содержащего конфиденциальные файлы. Давайте рассмотрим последний пример; мы могли бы определить список, который включает все конфиденциальные каталоги, которые мы хотим проверить, следующим образом:
```commandline
- list: sensitive_directories
  items: [/k8slabs/security,/k8slabs/subjects/results,/k8slabs/config]
```
Затем мы можем использовать этот список в макросе или условии, например так:
```commandline
- macro: sensitive_access_attempt
  condition: env.arg.target in (sensitive_directories)
```
Теперь, когда вы это осветили, у вас есть все необходимые знания для создания пользовательских правил. Как уже упоминалось, есть макросы, которые включены по умолчанию, но как инженер DevSecOps, работа может лечь на вас, чтобы облегчить себе (и своей команде) жизнь, определив макросы, специфичные для вашей среды и событий угроз, которые вы хотите обнаружить; списки могут быть использованы в процессе этого определения макроса, чтобы сделать вашу жизнь еще проще. Надеюсь, эти последние две задачи сообщили, насколько мощным может быть Falco в качестве механизма обнаружения угроз во время выполнения в Kubernetes и как вы можете раскрыть эту мощь, определив правила Falco.

### Ответьте на вопросы ниже
Какой фрагмент можно использовать при определении условия правила Falco для сопоставления процессов bash?
```commandline
proc.name = bash
```
Что можно использовать для ссылки на коллекцию элементов в условии?
```commandline
Lists
```
Что можно использовать для сокращения часто используемых условий? 
```commandline
Macros
```

## Задание 6
Теперь, когда Falco был подробно рассмотрен и обсуждалось, как этот инструмент можно использовать для обнаружения 
угроз во время выполнения в кластере Kubernetes и оповещения при их появлении, мы рассмотрим некоторые другие 
инструменты, которые мы можем использовать вместе с Falco для перевода этих оповещений в визуализированные шаблоны, 
которые легко анализировать. Наша главная цель здесь — повысить видимость во время выполнения; Falco — это наш 
механизм обнаружения, который позволяет нам узнать, что происходит, с помощью оповещений; давайте рассмотрим, как мы,
как инженер DevSecOps , можем повысить видимость этих оповещений с помощью  Falcosidekick ,  Prometheus  и  Grafana.

Что такое Falcosidekick? 

Falcosidekick  — это не совсем еще один инструмент, а сопутствующий проект для Falco, который можно включить во 
время/после настройки. Его основная функция решает проблему, с которой пользователи сталкивались при использовании 
Falco. Эта проблема заключается в ограниченных возможностях вывода оповещений, доступных из коробки, которые, если 
вы помните, это: стандартный вывод, файл, системный журнал, порожденная программа, конечная точка HTTP(S) или клиент 
через API gRPC. Эти возможности полезны во многих случаях, но современные ИТ-инфраструктуры состоят из всевозможных 
инструментов и служб; вполне естественно, что пользователи начали хотеть интегрировать Falco с этими инструментами и 
службами. Вот где вступает в дело Falcosidekick.

На момент написания статьи Falcosidekick позволяет пересылать события/оповещения Falco более чем 60 службам (это 
число продолжает расти с течением времени). Это значительно увеличивает возможности Falco и упрощает интеграцию 
практически в любую среду. Это позволяет интегрировать инструменты ChatOps, такие как Slack и Microsoft Teams, когда 
происходят события, а также настраивать правила пересылки, чтобы обеспечить детальный контроль над этим, чтобы 
сообщения отправлялись только для критических событий и не рассылались спамом по различным каналам. Это также 
позволяет интегрироваться с различными облачными службами, что означает, что функции могут быть развернуты, и могут 
быть выполнены действия по смягчению последствий (например, с использованием функций AWS Lambda, если вы с ними 
знакомы). Однако самое важное для этой задачи то, что он позволяет пересылать события Falco на платформы мониторинга 
и ведения журналов. Эта интеграция позволяет нам значительно повысить нашу видимость угроз безопасности во время 
выполнения в среде Kubernetes . Подробнее об этом далее в задаче.

falcosidekick

Еще одна функция, включенная в Falcosidekick, которая помогает с видимостью и мониторингом событий безопасности во 
время выполнения, — это дополнительный компонент webUI. Этот веб-интерфейс пользователя дает пользователям быстрый 
обзор того, что происходит в их среде Falco. Компонент можно включить и получить к нему доступ через переадресацию 
портов в среде Kubernetes . Здесь вы найдете меню, позволяющие просматривать произошедшие события и детализировать 
их, чтобы получить больше информации о них. Вы также можете визуализировать ключевые точки данных с помощью панелей 
мониторинга, которые помогают отслеживать такие вещи, как объем событий на источник данных. Все это означает, что 
Falco — герой, который спасает положение (во время выполнения), и у каждого героя есть свой помощник, который может 
принести немного больше пользы. 

Что такое Прометей и Графана? 

Еще больше инструментов! Да, ваш и без того большой арсенал инструментов DevSecOps скоро вырастет. Многие проблемы в DevSecOps, как правило, имеют некоторые решения с открытым исходным кодом в виде изящных инструментов, и, как мы уже видели, безопасность во время выполнения не является исключением. Prometheus — это инструмент мониторинга и оповещения систем с открытым исходным кодом, впервые созданный в 2012 году в SoundCloud. Теперь это автономный проект с открытым исходным кодом, не привязанный ни к одной компании, а также являющийся частью CNCF.  Prometheus  собирает и хранит информацию о метриках с метками времени, известную как данные временных рядов. Эти данные временных рядов могут храниться вместе с дополнительными парами ключ-значение, известными как метки. С точки зрения того, какие метрики собираются, может быть широкий спектр различных системных метрик. Обычно в Prometheus собираются метрики производительности.  

Как и в случае со всеми инструментами DevSecOps, их использование обычно различается в зависимости от того, где они используются; возможно, вы отслеживаете фронтенд-приложение и хотите отслеживать время отклика или тайм-ауты, или, возможно, вам нужно отслеживать частоту вызовов базы данных или время отклика на бэкенде, в большинстве случаев оба варианта полезны. В контексте безопасности эти метрики могут быть полезны при устранении неполадок в текущем инциденте, поскольку данные временных рядов часто дают представление о том, какой ресурс используется в атаке, когда атака началась (и продолжается ли она еще) и подозрительных всплесках трафика. Как уже упоминалось, все эти метрики помогают получить представление, но Prometheus нуждается в некоторой помощи в визуализации этих метрик. Вот где вступает Grafana.

набор инструментов

Grafana  — это интерактивная платформа визуализации данных, разработанная Grafana Labs. Grafana позволяет визуализировать собранные данные с помощью диаграмм и графиков. Эти диаграммы и графики можно сгруппировать в панель мониторинга, эти панели мониторинга можно создать для определенных целей, например, одна для мониторинга производительности front-end, а другая — back-end. Затем эти панели мониторинга можно сделать доступными для соответствующих команд; это обеспечивает высокий уровень видимости системы для всей команды, что означает, что проблемы производительности, которые угрожают надежности приложения, или возникающие инциденты безопасности могут быть быстро обнаружены. 

Визуализируемые данные могут быть собраны из всех видов источников. В нашем случае самое важное отметить, что данные могут быть собраны из кластера Kubernetes , но все виды других облачных и необлачных сервисов могут быть отслежены с помощью Grafana.

Команда мечты

Было много разговоров о мониторинге, метриках и источниках данных, и легко запутаться в дебрях, когда на столе так много инструментов, каждый из которых выполняет схожую работу. Давайте рассмотрим каждый из обсуждаемых инструментов и то, как их различные цели и сильные стороны могут работать вместе, чтобы создать одно эффективное решение безопасности среды выполнения DevSecOps . Наша миссия при создании решения безопасности среды выполнения Kubernetes заключается в том, чтобы обеспечить как можно более раннее обнаружение угроз безопасности, аномалий производительности и тому подобного, которые возникают во время выполнения, для смягчения воздействия; ключ ко всему этому — обнаружение и видимость. 



Во-первых, как мы уже установили, мы используем Falco для определения правил, которые обнаруживают угрозы во время выполнения. Существует ряд встроенных правил, которые обнаруживают общие события системных вызовов, связанные с угрозами безопасности. Пользовательские правила могут быть определены в зависимости от потребностей вашего приложения и других источников данных для событий (например, журналов аудита Kubernetes). Это охватывает сторону обнаружения. Falcosidekick можно использовать для получения уровня видимости над триггерами и событиями оповещений, но для получения более высокого уровня понимания и видимости мы привлекаем Prometheus. Falcosidekick, как уже упоминалось, также функционирует как пересылатель; затем мы можем использовать его для пересылки событий Falco в Prometheus. Затем это позволяет собирать оповещения Falco или данные системных вызовов в виде временных рядов, идеально подходящих для обнаружения тенденций и аномалий. Последняя часть головоломки — Grafana, которая очень часто используется в качестве слоя визуализации поверх Prometheus, позволяя создавать графики/панели мониторинга, которые могут предоставить команде DevSecOps легко читаемые визуализированные данные, отслеживающие такие показатели, как частота событий в секунду, срабатывание оповещений в группе ресурсов и т. д. Этот пример, распространенный в реальной реализации, как мы надеемся, даст вам представление о том, как эти инструменты могут использовать каждую из своих сильных сторон для создания одного эффективного решения.

К настоящему моменту должно быть ясно, что ключевым навыком, который развивается как инженер DevSecOps, является приобретение знаний об океане инструментов, доступных в этой области, и понимание того, как они работают и могут использоваться вместе для решения проблем, которые встречаются на нашем пути при обеспечении безопасности динамических, часто облачных решений. С учетом сказанного, ответьте на вопросы ниже, а затем, я думаю, пришло время приступить к практике!

### Ответьте на вопросы ниже
Какой инструмент, рассматриваемый в этой задаче, можно использовать в качестве слоя визуализации и который позволяет визуализировать собранные данные в виде диаграмм и графиков?
```commandline
Grafana
```
Какой инструмент, рассматриваемый в этой задаче, собирает и хранит данные временных рядов?
```commandline
Prometheus
```
Какой инструмент, рассматриваемый в этой задаче, является сопутствующим проектом, который может выступать в качестве экспедитора для Falco?
```commandline
Falcosidekick
```

## Задание 7
Теперь, приближаясь к концу вашего первого месяца здесь, в Kubernetes Laboratories, вы начинаете чувствовать себя комфортно в своей рутине. Эта рутина продолжается еще одним ежедневным совещанием. На этот раз ваши товарищи по команде обсуждают текущую безопасность выполнения. Возникшая проблема заключается в том, что было принято решение внедрить Falco в технологический стек компании, но сотрудник, который его настроил, вскоре ушел; из-за этого инструмент еще не был протестирован или оптимизирован. Ваша растущая уверенность дает вам необходимый толчок, чтобы стать волонтером, и вам назначают тикет. Теперь пришло время подкрепить свои слова делами, в данном случае деньгами является ваша способность внедрять, тестировать и настраивать безопасность выполнения в Kubernetes с помощью Falco.

Давайте начнем, не так ли? Нажмите зеленую кнопку «Запустить машину» и подождите 2 минуты, пока загрузится виртуальная машина . Машина запустится в режиме разделенного экрана. Если виртуальная машина не видна, используйте синюю кнопку «Показать разделенный вид» в верхней части страницы. После загрузки выполните следующую команду, чтобы запустить кластер minikube:

Запуск Minikube
user@tryhackme$ minikube start
Подождите несколько минут, и кластер в конце концов запустится. Подождав несколько минут, выполните следующую команду:

Проверка пространств имен
user@tryhackme$ kubectl get pods
Здесь вы должны увидеть запущенный модуль Falco; это означает, что системные вызовы и события аудита Kubernetes в нашем кластере отслеживаются и оцениваются по правилам Falco. Мы можем увидеть это в действии, запустив одно из этих правил. Возьмем, к примеру, оболочку, созданную внутри контейнера. Это хорошее событие для отслеживания, так как иногда это может быть первым шагом злоумышленников при попытке повысить привилегии. Из-за этого это правило встроено в Falco по умолчанию. Давайте протестируем наш кластер и посмотрим, отслеживается ли он. Сначала давайте создадим оболочку в контейнере, чтобы запустить правило (заменив falco-pod-name на имя модуля falco, запущенного в кластере):

Создать ракушку
user@tryhackme$ kubectl exec falco-pod-name -it -- /bin/sh
Затем выйдите из контейнера:

Выход из оболочки
# exit
Теперь проверьте, сработало ли оповещение. Вы можете проверить это в журналах контейнера Falco. Выполните следующую команду для проверки:

Проверка событий Falco
user@tryhackme$ kubectl logs falco-pod-name | grep shell
Выглядит хорошо! Событие можно увидеть, что означает, что Falco отслеживает наш кластер во время выполнения! Однако определенные правила хороши для обычных случаев использования. В предыдущих задачах упоминалось, что можно определить пользовательские правила для тех случаев, которые вы хотите отслеживать в своем кластере и которые не охватываются правилами по умолчанию. Falco изначально был установлен в кластере с помощью helm с использованием файла, default_values.yamlрасположенного в  ~/Documents/falcoctl-local.

Изменить каталог
user@tryhackme$ cd ~/Documents/falcoctl-local
Вы можете добавить пользовательские правила в этот файл YAML , а затем при перестроении с помощью Helm события Falco по этим пользовательским правилам также будут оцениваться.  Давайте применим пользовательское правило сейчас. Вы можете открыть файл YAML для редактирования, перейдя в этот каталог и запустив (в этом примере используется vi/vim, но вы можете использовать свой любимый текстовый редактор):

Пользовательские правила
user@tryhackme~/Documents/falcoctl-local$ vi default_values.yaml
Файл должен открыться в блоке, где определены пользовательские правила (если нет, перейдите к строке 437); здесь определено правило, которое обнаруживает использование команды в контейнере. Однако отслеживаемый процесс оставлен пустым. Внесите изменения в это правило, чтобы оно отслеживало использование команды curl в контейнере. После этого сохраните изменения. Теперь, когда значения обновлены, экземпляр Falco, работающий в нашем кластере, необходимо обновить этими значениями. Это можно сделать следующим образом:

Пользовательские правила
user@tryhackme~/Documents/falcoctl-local$ helm upgrade falco ../falco -f default_values.yaml -n default
Применив это правило, пришло время его протестировать. У нас есть pod, работающий в кластере, который запускает команду curl при загрузке. Чтобы протестировать это правило, давайте удалим его. Поскольку этот pod является частью развертывания, он будет самовосстанавливаться, и pod перезапустится после удаления:

Удалить Под
user@tryhackme~/Documents/falcoctl-local$ kubectl delete pod k8s-labs-deployment-5c655669dc-tp8tb
Теперь давайте проверим, сработало ли правило, проверив логи:

Проверка событий Falco
user@tryhackme~/Documents/falcoctl-local$ kubectl logs falco-pod-name | grep curl
Похоже, что так и было; не только это, но есть каталог, упомянутый в команде curl. Перед тем, как перейти в этот каталог, выполните следующую команду, чтобы получить подпись base64 пользовательского правила, которое вы настроили:

Получить подпись Base64
user@tryhackme~/Documents/falcoctl-local$ sed -n '439,449p' default_values.yaml | base64 -w 0
Наконец, перейдите в каталог, указанный в команде curl, там должен быть файл, но он зашифрован. Вы можете использовать подпись base64 настроенного правила для расшифровки этого файла! Внутри вы найдете флаг!

Получить подпись Base64
user@tryhackme$ sudo openssl enc -aes-256-cbc -d -in <file-name-here> -out flag.txt -pass pass:"base64-signature-goes-here"
С этим вы закрыли еще один тикет в Kubernetes Laboratories. Слухи о вашем прогрессе начали распространяться в компании, и вы доказали, что являетесь ценным активом для команды.

### Ответьте на вопросы ниже
Что такое пользовательское правило в кодировке Base64?
```commandline
ICAgIC0gcnVsZTogRGV0ZWN0IFVzYWdlIG9mIEN1cmwKICAgICAgZGVzYzogRGV0ZWN0cyB3aGVuIHRoZSBjdXJsIGNvbW1hbmQgaXMgdXNlZCBpbnNpZGUgYSBjb250YWluZXIuCiAgICAgIGNvbmRpdGlvbjogPgogICAgICAgIGNvbnRhaW5lci5pZCAhPSBob3N0IGFuZAogICAgICAgIHByb2MubmFtZSA9IGN1cmwgYW5kCiAgICAgICAgZXZ0LnR5cGUgPSBleGVjdmUKICAgICAgb3V0cHV0OiA+CiAgICAgICAgQ3VybCBjb21tYW5kIHVzZWQgaW4gY29udGFpbmVyICh1c2VyPSV1c2VyLm5hbWUgY29udGFpbmVyPSVjb250YWluZXIubmFtZQogICAgICAgIHNoZWxsPSVwcm9jLm5hbWUgcGFyZW50PSVwcm9jLnBuYW1lIGNtZGxpbmU9JXByb2MuY21kbGluZSkKICAgICAgcHJpb3JpdHk6IFdBUk5JTkcKICAgICAgdGFnczogW25ldHdvcmssIGNvbW1hbmQsIHNlY3VyaXR5XSAgCg==
```
Каково значение флага THM?
```commandline
THM{th3_c4k3_1s_a_l13}
```

## Задание 8
Вы сделали это! Вот мы и в конце комнаты, и путешествие по этой комнате должно было научить вас многим вещам. Прежде 
всего, защита среды выполнения Kubernetes — непростая задача. Эта цель защиты нашей среды во время выполнения 
сопряжена со всевозможными проблемами и трудностями. К счастью для нас, те, кто прошел этот путь до нас, рассмотрели 
эти проблемы и разработали решение с использованием инструментов безопасности во время выполнения, таких как Falco. 
Давайте подведем итог тому, что было рассмотрено в этом уроке:

- Независимо от того, насколько правильно настроен ваш кластер Kubernetes , вам нужно быть готовым к угрозам, которые 
могут возникнуть во время выполнения .
- Kubernetes мало что предлагает с точки зрения безопасности во время выполнения, но журналы аудита Kubernetes 
  позволяют нам получать представление о событиях, происходящих в нашем кластере, и их можно контролировать с помощью политик аудита.
- Существуют различные виды инструментов, которые можно использовать для защиты нашей среды Kubernetes во время 
  выполнения. Инструменты обеспечения выполнения во время выполнения , которые позволяют определять политики для смягчения влияния определенных событий безопасности, и инструменты аудита , которые позволяют разрабатывать и наблюдать информацию путем анализа аудитов, журналов и других источников, таких как системные вызовы, для обнаружения угроз в режиме реального времени.
- Falco — это механизм обнаружения угроз во время выполнения, который оценивает события из разных источников, таких 
  как системные вызовы (с использованием модуля ядра или eBPF ) или журнал аудита Kubernetes , по списку предопределенных и (если определены) настраиваемых правил, выдавая оповещения в случае выполнения условия.
- Как инженер DevSecOps , вы можете реализовать более строгую безопасность выполнения, определив правила Falco для 
  отслеживания событий, характерных для вашей среды. Правила Falco должны содержать поля name , description , condition , output и priority и могут быть сделаны более эффективными с помощью макросов и списков .
- Ключ к обеспечению безопасности во время выполнения — это объединение мощи инструментов безопасности во время 
  выполнения, таких как Falco, с платформами мониторинга, такими как Prometheus и Grafana , что повышает видимость 
  угроз во время выполнения для всей команды. Это делается с помощью Falcosidekick для пересылки событий в 
  Prometheus.


Со всеми этими знаниями, безопасно переданными в ваш мозг, Kubernetes Laboratories может быть спокоен, зная, что не только их инфраструктура Kubernetes была надежно настроена в соответствии с лучшими практиками безопасности, но также защищена во время выполнения и постоянно контролируется вами и вашими коллегами из команды DevSecOps. Они так довольны вашим прогрессом, что решили, что вы прошли испытательный срок и заслуживаете торта! Однако еще долго после того, как торт будет съеден, у вас останется настоящий приз: знание того, как защитить кластер Kubernetes . 

### Ответьте на вопросы ниже
Все готово!
```commandline
Ответ не нужен
```
[>> вернуться на главную страницу](https://github.com/BEPb/tryhackme/blob/master/README.md)