[>> вернуться на главную страницу](https://github.com/BEPb/tryhackme/blob/master/README.md)

# Комната [Windows Reversing Intro](https://tryhackme.com/r/room/windowsreversingintro) 

Всего 8 заданий:
## Задание 1
Предыдущая комната
https://tryhackme.com/room/win64assembly


Эта комната является частью серии комнат, которые познакомят вас с программным обеспечением для обратного 
проектирования в Windows. Это будет довольно короткая и простая комната, в которой вы познакомитесь с тем, как 
концепции более высокого уровня выглядят на более низком уровне. Вы также начнете знакомиться с IDA. Мы будем 
использовать полученные здесь навыки для выполнения более продвинутых методов обратного проектирования в будущих 
комнатах.

Программы, представленные в этой комнате, скомпилированы с помощью MSVC (компилятор C++, встроенный в Visual Studio),
установленного в режим выпуска для x64. Отладочные двоичные файлы и символы не будут использоваться для обучения, 
однако отладочные символы будут предоставлены для тех, кому интересно. Это сделано для того, чтобы сделать все 
максимально реалистичным. Отладочные символы являются роскошью при обратном проектировании и не распространены при 
работе с исполняемыми файлами.

Получите практический опыт.
При запуске образцов самостоятельно, вне IDA, запускайте их через командную строку.

Используйте виртуальную машину, предоставленную вместе с этой комнатой, чтобы освоить материал. Это значительно 
улучшит ваш опыт и обучение в этой комнате. В виртуальной машине установлена бесплатная программа IDA вместе с 
образцами для комнаты.

Учетные данные виртуальной машины:

Имя пользователя: thm
Пароль: THMWinRE!
Краткое примечание для VM : при загрузке исполняемого файла в IDA вам будет предложено ввести отладочные символы 
(PDB). Скажите этому «нет». Дальнейшее объяснение того, почему это так, будет дано в следующей задаче. Если вы 
попытаетесь загрузить символы, IDA может дать сбой.

Приносите свою собственную виртуальную машину !
Хостинг виртуальных машин на THM великолепен, но у него есть свои ограничения. Такие вещи, как вычислительная 
мощность и доступ в Интернет, усложнят некоторые задачи, и именно по этим причинам я настоятельно рекомендую вам 
создать виртуальную машину на своем компьютере. Все, что вам нужно будет сделать, это установить IDA Freeware и 
получить программы, которые мы будем реверсировать.

### Ответьте на вопросы ниже
Давайте начнем!
```commandline
Ответ не нужен
```

## Задание 2
Знакомство с инструментами
В этой комнате мы будем использовать IDA Freeware. Исторически недостатком IDA всегда была его цена, однако, благодаря недавним разработкам в других инструментах, бесплатная версия IDA теперь имеет гораздо больше функций, чем раньше. Другие хорошие инструменты включают x64dbg, Ghidra, WinDBG, Radare2 и, конечно же, GDB. Мои ежедневные драйверы — x64dbg и Ghidra. IDA используется для этой серии, поскольку она проста для новичков и позволяет нам использовать только один инструмент.

Сначала давайте обсудим статический и динамический анализ. Статический анализ подразумевает просмотр программы, существующей на диске; программа никогда не выполняется. Динамический анализ подразумевает анализ процесса по мере его выполнения. Динамический анализ обычно предпочтительнее, если только вы не имеете дело с вредоносным ПО. Динамический анализ позволяет вам видеть данные в памяти и то, как они используются. Статический же анализ требует от вас угадывать или выполнять детальный обратный инжиниринг, чтобы выяснить это.

Наши инструменты предоставляют три основные функции: отладка, дизассемблирование и декомпиляция. Дизассемблеры преобразуют программу из ее байтов на диске или в памяти в ее эквивалент ассемблерного кода и представляют его в информативном виде. Декомпиляторы похожи на дизассемблеры, за исключением того, что вместо того, чтобы предоставить нам сборку, они пытаются воссоздать код на C/C++. Недостатком декомпиляторов является то, что они могут быть неточными или не иметь информации. Из-за этого, если вы используете декомпилятор, хорошей идеей будет иметь дизассемблированный код рядом с декомпилированным кодом для проверки на неточности. Отладчики , наряду с дизассемблерами и декомпиляторами, позволят нам размещать точки останова в программе во время ее работы и анализировать регистры, память, состояния и многое другое. Они также позволяют изменять данные в памяти во время работы программы.

Обзор МАР
IDA — довольно обширный инструмент, я покажу вам только то, что вам нужно знать. Я настоятельно рекомендую вам узнать больше о том, как использовать IDA в свободное время. Его несложно использовать, скорее, в нем просто много всего. Для следующих объяснений я буду использовать notepad.exe (C:\Windows\System32\notepad.exe).

Чтобы загрузить программу в IDA, вы можете запустить IDA и следовать подсказкам, или же вы можете просто перетащить исполняемый файл на значок IDA на рабочем столе. Во время загрузки программы в IDA вам будет предложено указать тип файла, вы можете просто придерживаться значений по умолчанию. В какой-то момент вас спросят об отладочных символах (PDB). В реальном мире получите любые отладочные символы, которые сможете. Обычно у вас будут только отладочные символы для библиотек Windows. Ради этой комнаты мы не будем использовать ничего, кроме тех, что идут с системой по умолчанию.

Отладочные символы
Отладочные символы чрезвычайно полезны, и вы должны использовать их, когда можете. К сожалению, у вас обычно будут только отладочные символы для общих библиотек и редко для интересующего вас исполняемого файла. Кроме того, большинство инструментов реверсирования загружают символы для общих библиотек, поэтому, если у вас нет подключения к Интернету, вы их не получите. Обратите внимание, что из-за этого не пытайтесь загружать символы в IDA при использовании виртуальной машины, иначе вы получите ошибки, и она может выйти из строя. В этой комнате мы рассмотрим примеры без их отладочных символов, чтобы сохранить как можно больше реализма. Однако для целей дальнейшего обучения отладочные символы будут предоставлены, если вы захотите загрузить их вручную.

Просмотры кода
Два основных вида, листинг и графическое представление, показывают программу в разобранном виде. Вы можете переключаться между ними, нажимая пробел. Я рекомендую вам проводить большую часть времени в графическом представлении, так как оно показывает ход выполнения программы.

Просмотр графика IDA

Как вы можете видеть в графическом представлении, стрелки представляют пункт назначения инструкций перехода. Это невероятно полезно и значительно экономит время.

Просмотр листинга IDA

В листинговом представлении вы можете увидеть немного больше информации, однако понять ход работы программы гораздо сложнее.

Возможно, вам будет полезно включить Auto Comments, перейдя в Options > General > Disassembly (выбрано по умолчанию) > Auto Comments.
Поиграйте с включением/выключением и посмотрите, понравится ли вам это. Я нашел это полезным, когда начал, так как это описывает то, что происходит в сборке.

Декомпилированный/псевдокодовый вид IDA

Вам нужен доступ в Интернет, чтобы иметь возможность декомпилировать код с помощью IDA Freeware, поэтому он НЕ будет работать в предоставленной VM .
IDA также имеет декомпилятор. Не полагайтесь на декомпиляторы, поскольку они не всегда точны и часто имеют проблемы с представлением каждой инструкции в более длинных разделах кода. С учетом сказанного, они являются отличным местом для получения общего представления о том, что происходит. Чтобы декомпилировать, IDA называет это псевдокодом, вы можете щелкнуть по области кода, которую вы хотите декомпилировать, и нажать F5 . Вы также можете перейти в Вид > Открыть подпредставления > Сгенерировать псевдокод .

Я не буду использовать функцию декомпилятора IDA для этой серии комнат.

Импорт/Экспорт
Эти вкладки довольно понятны. Вкладка импорта показывает все функции, импортированные текущей программой из других источников. Вкладка экспорта показывает все функции, предоставляемые текущей программой. Обратите внимание, что экспорт исполняемого файла обычно содержит только точку входа (откуда программа начинает выполняться).
Функции
Слева вы можете увидеть окно «Функции», в котором показаны идентифицированные функции для текущей программы. В зависимости от того, к каким символам у вас есть доступ, у вас может быть больше или меньше функций с реальными именами. Если нет символов для идентификации функции, ей будет присвоено общее имя, например sub_140001000, где 140001000 — адрес функции.
Другие подвиды
Другие полезные вкладки/подпредставления можно найти в разделе Вид > Открыть подпредставления . Я рекомендую вам поиграться с различными подпредставлениями, поскольку в них содержится значительный объем информации. Одно подпредставление, с которым вам следует ознакомиться, — это подпредставление Строки . Здесь вы можете просмотреть все идентифицированные строки в памяти. Это может быть полезно, как мы увидим позже при поиске определенной функции или интересующего вас места.
Дальнейшее обучение
Как уже упоминалось, IDA напичкана всем. Я настоятельно рекомендую вам поиграться и познакомиться с IDA. Существует множество руководств, видео и даже книг, которые вам помогут!
### Ответьте на вопросы ниже
Как только вы освоитесь с IDA, давайте начнем заниматься обратным проектированием!

```commandline
Ответ не нужен
```

## Задание 3
Помните, как функциям нужны стековые кадры? Прологи и эпилоги функций будут устанавливать, создавать и уничтожать стековые кадры в соответствии с используемым соглашением о вызовах. Я представлю их здесь и укажу на них, когда мы столкнемся с ними в нашем путешествии.

Пролог
Пролог идет до того, как выполняется тело функции. Не все прологи одинаковы, но вот три вещи, которые могут произойти, и порядок, в котором они обычно происходят.

Сохраняются изменчивые регистры. Если доступно теневое пространство и выбраны соответствующие параметры компиляции, теневое пространство может использоваться для хранения изменчивых регистров. Если в теневом пространстве нет места, то регистры помещаются в стек.
Пространство для стекового фрейма выделяется путем вычитания из RSP. Сумма, вычитаемая из RSP, может быть использована для определения количества параметров функции.
RSP или RBP могут быть сохранены для последующего восстановления. Поскольку RBP не используется для целей стека в x64, когда он сохраняется, он, скорее всего, не сохраняется для обеспечения безопасности адреса стека, а обрабатывается так же, как и другие изменчивые регистры. В случае, если он используется для целей стека, вы можете увидеть что-то вроде того mov RSP, RBP, что перемещает RSP туда, где был RBP, устанавливая новый кадр стека прямо рядом с предыдущим.
В целом, можно бегло просмотреть пролог функции, однако следует отметить, что он может подсказать, сколько параметров передается функции.

Эпилог
Эпилог довольно прост, он отменяет/раскручивает все, что связано со стеком, в основном вызванное прологом. Эпилог может быть хорошим местом для повторной проверки того, что вы ничего не упустили в прологе, но он, как правило, более бесполезен для обратного проектирования, чем пролог.

В эпилоге вы можете увидеть следующее:

Дополнение к RSP для восстановления/удаления кадра стека.
Восстановление регистров, обычно выполняемое путем извлечения из стека регистров, которые были помещены в стек во время пролога.
Возвращаться.
Вот и все, что можно сказать о большинстве эпилогов.

Краткое примечание: вы, возможно, слышали, что на диске ничего на самом деле не удаляется. Когда вы что-то удаляете, ОС просто отмечает эту область на диске как неиспользуемую, чтобы ОС знала, что может записывать в это место, не перезаписывая ничего важного. Вот почему существует программное обеспечение для удаления данных. Оно заходит и заполняет область нулями или мусорными данными, так что исходные данные удаляются. Аналогично, ничего не удаляется из стека прологом или эпилогом. Когда создается следующий кадр стека, он будет помещен прямо туда, где был старый, и там все еще будут данные. Вот почему вам следует заранее инициализировать переменные, потому что в противном случае ваша переменная может содержать мусор из предыдущей функции/кадра стека.

### Ответьте на вопросы ниже
Это как пьеса, но в ней гораздо больше фрагментов.

```commandline
Ответ не нужен
```

## Задание 4
При запуске образцов самостоятельно, вне IDA, запускайте их через командную строку.

Прежде чем загрузить программу в IDA, я хочу быстро повторить предупреждение. Когда вам будет предложено ввести 
символы отладки, не делайте этого. Это необходимо для сохранения реализма. Если вы хотите использовать символы 
отладки для дальнейшего самостоятельного обучения, вы можете загрузить их вручную после загрузки программы в IDA. 
Символы отладки предоставляются в папке на рабочем столе вместе с примерами. Если вы попытаетесь загрузить символы, 
IDA может дать сбой.

Начиная
Давайте рассмотрим пример, который вызывает функцию. Для этой задачи используйте HelloWorld.exe . Обычно хорошей 
идеей является запуск программы перед выполнением любого обратного проектирования, так что продолжайте и сделайте 
это. Опять же, когда вы запускаете программу, делайте это из командной строки, так как программа закрывается очень 
быстро.

Начнем с main(), найдем ее в списке функций, если IDA не перейдет к ней автоматически. Функция main() должна 
выглядеть примерно так:



Обратите внимание sub RSP, 28hна вверху. Для этой функции это весь пролог. Это настройка функции путем перемещения 
указателя стека и создания новой области кадра стека.

`printf()`
Сейчас мы сосредоточимся на первом вызове функции в main(), который является вызовом printf(). IDA не определяет, 
что это printf(), поэтому вместо этого вы можете идентифицировать его как таковой на основе переданных параметров и 
того, что он делает при запуске программы. IDA показывает две строки, загруженные в первые два параметра для вызова 
функции. Первый параметр (переданный через RCX) — это строка формата "%s\n", второй параметр (RDX) — это строка 
"Hello with...". Сразу после двух параметров идет вызов. В IDA вы можете переименовать sub_### на любое другое имя, 
щелкнув правой кнопкой мыши и перейдя в Rename  или выбрав функцию и нажав N. Переименование переменных и функций 
очень полезно при работе с большими проектами.

Вот и все о вызове printf(). Первый параметр — это строка формата, второй — строка "Hello...", и printf() творит 
волшебство. Не стесняйтесь изучать printf() больше, если хотите.

стд::cout
Теперь давайте рассмотрим второй вызов функции, который относится к std::cout.

Мы можем определить его std::cout, не используя строку, выведенную на консоль, потому что мы можем видеть вещи, связанные с cout, basic_ostream и char_traits. Вы можете заметить, что имена функций довольно странные, как они отображаются в IDA. Мы обсудим это в разделе DLL, но, вкратце, имена искажены для перегрузки функций. Пока что не обращайте внимания на искажение имен. С учетом сказанного, вы можете быть не знакомы с этими функциями, поэтому первое, что нужно сделать, это посмотреть их. Вот краткий обзор их всех:

basic_ostream - шаблон C++ для выходных потоков. Подробнее здесь .
char_traits — обеспечивает некоторую абстракцию от базовых типов символов и строк.
cout - std::cout - Отправляет текст на консоль.
Теперь перейдем к слону в комнате. Где находится строка, которая должна быть напечатана? Давайте найдем ее.

Чтобы найти нашу строку, перейдите в Вид > Открыть подпредставления > Строки или нажмите Shift + F12 . Обратите внимание, что это может занять некоторое время. Затем найдите строку в списке. Вы можете использовать Ctrl + F для поиска. Дважды щелкните строку в списке, и это приведет вас к строке, где вы сможете увидеть все ссылки на эту строку. IDA называет это XREF, сокращение от перекрестных ссылок.



Строка имеет только одну ссылку, поэтому дважды щелкните по ней. Это приведет вас к местоположению строки, которая находится в очень большой функции.





Строка явно не там, где мы ожидали ее увидеть. Мы видим sputn, что, короче говоря, означает, что мы имеем дело с потоками символов. Так что же это за огромная функция и что она делает? Если вы перейдете к началу функции в представлении листинга, вы увидите, что на нее ссылается. Конечно же, main() ссылается на эту функцию. Так что же здесь происходит?

Встраивание
Одна из оптимизаций компилятора/линкера, которая вносит заметные изменения в код, — это встраивание. Когда функция встраивается, она по сути вставляется туда, где должен быть вызов, а не делает вызов. Смотрите следующий пример.

Без встраивания функций:
```commandline
int Add(int x, int y){
    return x+y;
}
int main(){
    int x = RandInt();
    int res = Add(x, 5)
}
```

С встраиванием функций:
```commandline
int main(){
    int x = RandInt();
    int res = x + 5;
}
```

То, что происходит с нашей строкой в HelloWorld.exe, похоже. Вместо того, чтобы передавать строку в качестве параметра в std::cout, она напрямую ссылается в std::cout. Вы можете подумать, что это вызовет проблемы, потому что что, если std::cout вызывается для печати другой строки? Вы правы, это вызовет проблемы для дальнейших вызовов std::cout. Как оказалось, если std::cout вызывается более одного раза, вы не увидите использования этой оптимизации. Вместо этого вы увидите, что она используется аналогично тому, как используется printf().

Я призываю вас написать программу, чтобы поиграться с этим и развить более глубокое понимание. Вы могли заметить, что есть некоторые интересные вещи с std::cout, которые я пропустил. Короче говоря, это связано с перегрузкой функций, basic_ostream и streambuf, который работает с потоками символов. Если вам интересно, простой поиск этих вещей даст вам полезную информацию.

На этом базовый пример функции завершается. Понять вызовы функций очень просто, если вы знаете используемое соглашение о вызовах. К счастью, для x64 Windows используется только fastcall, но другие системы и архитектуры, скорее всего, не будут такими уж хорошими. Убедитесь, что вы хорошо знаете, с каким соглашением о вызовах вы имеете дело, это значительно облегчит вам работу.

### Ответьте на вопросы ниже
В образце HelloWorld.exe, какая инструкция устанавливает первый параметр для вызова printf()? Предоставьте полную инструкцию, как показано в IDA, с одинарными пробелами. Пример: mov RAX, RBX

```commandline
lea rcx, Format
```

## Задание 5
При запуске образцов самостоятельно, вне IDA, запускайте их через командную строку.

Настоятельно рекомендуется следовать этой части в вашей собственной виртуальной машине , так как это облегчит вам понимание. Эта задача использует Loop.exe . Загрузите его в IDA и перейдите к функции main(). Настоятельно рекомендуется использовать графическое представление.

Я также собираюсь заявить сейчас и несколько раз, чтобы иметь в виду общую картину. Не анализируйте одну инструкцию за раз, обычно требуется несколько инструкций для выполнения одного высокоуровневого действия. Также важно отметить, что мы будем делать предположения. Вы не всегда будете знать, что что-то есть или делает, поэтому вы делаете свою лучшую догадку. По мере продвижения используйте свою догадку, чтобы попытаться понять, что происходит, и в то же время подтверждайте/проверяйте свою догадку.

На высоком уровне используются три основных типа циклов: For, While и Do-While. При работе на низком уровне вы обычно увидите do-while и иногда while. Помните, что цикл for — это всего лишь абстрактный цикл while. При работе с циклами ожидайте увидеть регистр счетчика/итератора, инициализируемый в начале и увеличивающийся/уменьшающийся в конце. Условие для цикла обычно находится в конце, так как именно тогда вы определяете, продолжать цикл или нет. Часто в начале также есть условие, которое будет проверкой для пропуска всего цикла. Внутри цикла также могут быть условия, которые прерывают/выходят из цикла.

Возвращаем наш первый цикл вспять
Прежде чем мы закинем его в IDA, как всегда, вы должны его запустить. После запуска его цель, похоже, состоит в том, чтобы получить ввод от пользователя и подсчитать количество строчных символов, а затем вывести результат. Достаточно просто, вы, вероятно, могли бы догадаться, как это работает, не делая никаких обратных преобразований, но давайте посмотрим, чтобы мы могли научиться, поскольку это не всегда будет так просто.

Продолжайте и загружайте Loop.exe в IDA и переходите к main(). Вы можете заметить, что он довольно большой. Я бы рекомендовал вам использовать представление графика, это значительно облегчает понимание потока программы. Еще раз нажмите пробел , чтобы быстро переключиться между представлением графика и представлением списка.

Первоначальный анализ
Для начала позвольте мне познакомить вас с лучшим навыком, который стоит развивать в качестве реверс-инженера. Это умение пропустить неважные вещи, иначе вы потратите время впустую и упретесь в кроличью нору. В графическом представлении мы видим большой ящик наверху. Глядя на него, мы видим, что он в основном просто выводит информацию, чтобы мы могли пробежаться по нему, просто чтобы убедиться, что нет ничего важного. Глядя на нижнюю часть большого ящика, которую я буду называть частью кода инициализации цикла, мы видим кое-что интересное.



Причина, по которой это интересно, заключается в двух основных причинах. Во-первых, похоже, что он не печатает ничего, что печатали предыдущие строки. Во-вторых, за ним следует цикл, который мы можем быстро определить по стрелкам, представленным в графическом представлении. Давайте начнем наш анализ с рассмотрения,  mov rsi, [rsp+58h+var_20]поскольку это, похоже, начало разницы. Важно: не забывайте о коде, который мы только что просмотрели. Если мы заблудимся или нам понадобится больше информации (предзнаменование), одно из первых действий, которое мы сделаем, это вернемся к коду, который мы просмотрели.

Рассматривая перемещение в RSI, RDI и RDX, мы не получаем многого, поскольку данные не инициализированы. Обратите внимание на то, test RDX, RDXчто он может раскрыть немного больше. Тестирование регистра по отношению к самому себе проверит, равен ли регистр нулю. В этом случае, если RDX равен нулю, он пропускает цикл из-за jz short loc_140001332. Исходя из этого, мы знаем, что RDX не должен быть равен нулю, поскольку если это так, он, по-видимому, терпит неудачу/пропускает цикл. Поскольку мы перебираем входные данные, мы можем предположить, что RDX, скорее всего, является длиной строки, но он также может проверять, пуст ли буфер. Одна из приятных особенностей IDA заключается в том, что он может определить, являются ли данные буфером или просто обычным типом данных, таким как целое число. Вы можете видеть, что два перемещения включают var_##, а другое использует rsp+58h+Block. Это означает, что перемещение в RDI включает буфер, а перемещения в RSI и RDX являются обычными типами данных. Теперь мы можем подтвердить нашу догадку, что RDX — это длина строки, поскольку цикл, скорее всего, будет итерироваться по строке. Мы будем иметь это в виду, когда будем двигаться дальше, чтобы и проверить нашу догадку, и лучше понять, что делает цикл.

Анализ цикла
Первое, что я люблю делать, это переходить к концу цикла, чтобы определить регистр, используемый в качестве счетчика, и конечный случай для цикла. Ключ к нахождению счетчика — это определение регистра, который увеличивается или уменьшается. Конечный случай для цикла можно определить путем сравнения со счетчиком.



Внизу вы можете видеть, как RCX увеличивается, а затем сравнивается с RDX. Другими словами, счетчик сравнивается с тем, что мы предполагаем длиной строки. Теперь мы знаем, что RCX — это счетчик, а условие между RCX и RDX — это конечное условие. Это также подтверждает, что RDX — это длина строки.

Теперь давайте рассмотрим первый блок, участвующий в цикле.

Блок цикла 1



Опять же, вам следует попытаться понять несколько инструкций одновременно, поскольку они, скорее всего, объединяются для выполнения одной задачи.

Мы видим, что адрес буфера (идентифицированного по «Block») помещается в RAX, поэтому RAX — это то, как будет осуществляться ссылка на строку в цикле.

Что это за странное сравнение RSI и cmovnb? cmovnbИнструкция — условный ход, если не ниже. Это говорит о перемещении RBX в RAX, если RSI не меньше 0x10. Вы также можете думать об этом, как если бы RSI был больше или равен 0x10.

Давайте выясним, что такое RDI. В блоке инициализации (большом) внизу мы видим, что буфер строки перемещается в RDI ( mov rdi, [rsp+58h+Block]). Поскольку RDI составляет 8 байт, первые 8 байт буфера перемещаются в RDI. Обратите внимание, что в отличие от RAX, RDI не содержит адреса буфера. RAX получил адрес из-за инструкции, leaтогда как RDI получил первые 8 байт (на основе размера регистра RDI) данных в буфере из-за movинструкции.
Теперь для RSI. Мы можем видеть в нижней части блока инициализации, что RSI установлен на неизвестное значение ( mov rsi, [rsp+58h+var_20]). Продолжайте искать, что изменяет эту переменную, и вы увидите ближе к середине первого блока, что она инициализируется как 0xF ( mov [rsp+58h+var_20], 0Fh). Если RSI или RSP+58h+var_20 не изменены где-либо еще, то этого cmovnbникогда не произойдет, поскольку 0xF ниже 0x10.
Так что же именно все это делает, если это, по-видимому, не связано с циклом? Мы вернемся к этому, а пока, поскольку это, по-видимому, не влияет на цикл, мы проигнорируем это.
Далее идет сравнение RAX+RCX и 0x61 (ASCII "a"), а затем переход, если меньше. Это получение смещения в строке с расстоянием, являющимся счетчиком цикла (RCX). RAX+RCX — это то же самое, что string[index] или RAX[RCX] на языке высокого уровня, где RCX — это индекс/смещение, которое добавляется к базовому адресу строки, содержащейся в RAX. Теперь давайте разберем это более понятным образом. Он сравнит текущий символ в итерируемой строке с символом "a". Если текущий символ меньше "a", он перейдет к последнему блоку в цикле, который начнет следующую итерацию. В противном случае он продолжится ко второму блоку. Таким образом, хорошим результатом в этом случае является то, что символ больше или равен "a", поскольку он не перейдет к концу цикла.

Еще раз вспомним общую картину. Цель этой программы — подсчитать строчные символы. Поведение, которое мы только что проанализировали, имеет смысл, строчный символ не будет меньше значения ASCII 0x61.

Часть 2



Второй блок делает почти то же самое, что и первый, за исключением того, что он сравнивает текущий символ с "z". Если он больше, то он перейдет в конец. Однако есть кое-что очень важное, что легко пропустить. Обратите внимание, что RBX увеличивается. Условие, при котором RBX увеличивается, заключается в том, что текущий символ не меньше "a" и не больше "z". Другими словами, если это символ в нижнем регистре (az), RBX увеличивается! Таким образом, RBX будет содержать результат того, сколько символов в нижнем регистре.

Наконец, в конце цикла счетчик цикла (RCX) увеличивается, затем сравнивается с длиной строки (RDX) и переходит, если меньше, к началу цикла. В противном случае он переходит к коду после цикла.
Часть 3

Теперь посмотрим на остальную часть функции, чтобы увидеть, что там еще есть, и, возможно, выяснить, что происходило с RSI и всем этим cmovnbделом. Сначала посмотрим на большой блок после цикла.



Похоже, что он выводит результаты, как мы видели, когда мы запускали программу. Однако ближе к концу блока мы видим что-то знакомое, сравнение RSI и 0x10. Если RSI меньше 0x10, он перейдет к эпилогу функции. На основании этого мы можем предположить, что RSI и 0x10 как-то связаны с обработкой ошибок, возможно, проверкой ввода или параметров. Если рассмотреть несколько небольших блоков в конце функции, то кажется, что предположение верно.




Он далее сравнивает RSI, и мы можем увидеть функции, связанные с недопустимыми параметрами и освобождением памяти. Помните, ранее я говорил, что хороший обратный инженер знает, когда что-то пропускать, сейчас как раз тот случай. RSI, похоже, не привязан к циклу или пользовательскому вводу, вместо этого он, похоже, генерируется компилятором. Из-за этого мы обойдем кроличью нору и не будем копать в ней глубоко, однако, если хотите, можете это сделать.

Вот и все! При достаточной практике и опыте эта задача может занять у вас всего несколько секунд. Для новичков такие вещи могут быть немного запутанными, поэтому мы разбили их на части. По иронии судьбы, разбивка на части иногда может усложнить понимание, поэтому так важно держать в голове общую картину, анализировать несколько связанных инструкций вместе и делать предположения, когда это необходимо. Конечно, будьте готовы к тому, что ваши предположения могут оказаться неверными.

Ответьте на вопросы ниже
В примере Loop.exe, какая инструкция является ключом к выяснению того, какой регистр является счетчиком? Предоставьте полную инструкцию, как показано в IDA, с одинарными пробелами. Например: dec RAX
```commandline
inc rcx
```
## Задание 6
Структуры очень распространены в современном программном обеспечении, особенно в Windows. Вся ОС Windows является в высшей степени объектно-ориентированной. Общее определение структуры — это тип данных, который содержит несколько фрагментов данных. Для начала давайте рассмотрим массивы, которые по сути являются самой простой структурой данных, которую вы можете получить.

Массивы
Массивы хранят несколько фрагментов данных одного типа последовательно в памяти. Допустим, у вас есть массив из 5 целых чисел, который начинается с адреса 0x4000. Размер массива составляет 20 байт, поскольку каждое целое число занимает 4 байта. Первое целое число находится по адресу 0x4000+0x0, второе — по адресу 0x4000+0x04 и т. д. Массивы обычно легко анализировать, как и массив символов (строка), с которым мы столкнулись в задаче цикла.

Классы
Классы могут иметь несколько фрагментов данных разных типов. Это то, что затрудняет работу с ними при реверсировании. Чтобы выяснить структуру класса, вам придется провести некоторый анализ. Вам нужно выяснить не только, сколько вещей находится в классе, но и их типы данных. Существует довольно большое количество способов сделать это, но обычно все сводится к простому просмотру функций, которые используют класс, и уделению пристального внимания тому, как они его используют. Мы рассмотрим реверс-инжиниринг структуры класса в одной из будущих комнат. А пока я дам вам ускоренный курс.

Допустим, у нас есть следующий класс:
```commandline
class Human {
public:
	int age;
	float height;
	char* name;
	Human(char* newName, int newAge, float newHeight)
		: age(newAge), height(newHeight), name(newName) {}
};
```

Данные этого класса займут 16 байт. 4 байта для возраста, 4 байта для роста и 8 для имени (указатели содержат адреса, а адреса в x64 занимают 8 байт). Как это будет идентифицировано в ассемблере? Допустим, указатель на класс содержится в RAX, а адрес класса — 0x4000. Вот немного псевдоассемблирования:
```commandline
mov RAX, 0x4000     ; RAX = Address of the class and the age variable (offset 0)
lea RBX, [RAX+0x4]  ; RBX = Address of height
lea RCX, [RAX+0x8]  ; RCX = Address of name
mov [RAX], 0x32     ; age = 50
mov [RBX], 0x48     ; height = 72
mov [RCX], 0x424F42 ; name = "BOB"
```

Как вы видите, у нас есть базовый адрес, хранящийся в RAX, а доступ к элементам класса осуществляется через смещения. Одна из вещей, на которую следует обратить внимание при работе с классами, — это использование адресов/указателей и инструкции lea. Это делается потому, что обычно вы хотите получить доступ к данным в классе, а не к его копии.

Работа с классами обычно не так уж и плоха, но иногда вам не дают полный класс. Например, некоторые части класса обычно упоминаются только один раз, например, некоторая информация заголовка, поэтому вам нужно быть осторожным. Мы снова рассмотрим реальную структуру в будущей комнате.

### Ответьте на вопросы ниже
Структуры повсюду, будьте к ним готовы!
```commandline
Ответ не нужен
```

## Задание 7
Процесс обратного проектирования DLL в основном такой же, как и для исполняемых файлов, но они обычно проще, поскольку вы можете увидеть больше имен функций. Также чаще можно увидеть отладочные символы, предоставляемые вместе с DLL, чем вместе с исполняемыми файлами.

Импорт, экспорт, модули
Вы, вероятно, видели много имен функций, которые являются ерундой. Как упоминалось ранее, большинство имен функций не выживают при компиляции, поскольку они существуют только для человеческого понимания. Однако вы можете заметить, что некоторые имена все же существуют. Это может быть вызвано двумя основными причинами.

Сначала инструмент распознает функцию и дает ей соответствующее имя. IDA делает это с помощью сигнатур FLIRT (Fast Library Identification and Recognition Technology). Сигнатуры FLIRT используются для идентификации стандартных библиотечных функций. Общая идея их работы заключается в том, что они ищут в памяти фрагмент байтов, соответствующий известному фрагменту байтов в стандартной библиотечной функции. После того, как совпадение найдено, функцию можно назвать соответствующим образом. Вы можете узнать больше о сигнатурах FLIRT на веб-сайте IDA/Hex-Rays . Функция main() немного сложнее, поскольку ее сигнатура отличается для каждой программы. Однако IDA иногда все еще может найти ее, используя некоторые трюки. Одной из общих черт функции main() является то, что она вызывается из точки входа программы, обычно ближе к концу. Обычно также есть проверка возвращаемого значения main(), чтобы определить, было ли возвращено что-либо, кроме нуля. Вы можете использовать эти знания, чтобы помочь найти функцию main(), и есть несколько других способов. Я не буду вдаваться в подробности здесь, так как это может быть довольно длинным и сложным. Я настоятельно рекомендую вам провести собственное исследование по этому вопросу.
Во-вторых, его имя может быть сохранено, поскольку оно импортировано из или экспортировано DLL . Чтобы разработчик мог использовать функцию из DLL, ему необходимо знать и уметь разрешать имя нужной ему функции. Из-за этого имена должны оставаться нетронутыми. DLL может раскрывать свои имена функций через заголовок DLL / PE , файл библиотеки или файл заголовка (.h или .hpp). Файлы библиотеки и заголовка не требуются, но обычно они включены.
Импорты — это функции, которые исполняемый файл использует/импортирует из DLL , а экспорты — это функции, которые DLL предоставляет/экспортирует. DLL известны как динамически подключаемые библиотеки, поскольку они загружаются в память один раз и могут быть загружены в любое количество процессов в любое время без создания дополнительных копий. ОС Windows построена на DLL.

Модули — это по сути все, что связано с процессом, импортирующим или экспортирующим функции. Например, Loop.exe включает такие модули, как ntdll.dll, kernel32.dll и т. д. Если бы вы запустили Loop.exe, то во время его работы сам Loop.exe считается модулем процесса.

Имя искажение/украшение
Перегрузка функций C++ позволяет иметь две разные функции с одинаковыми именами, которые принимают разные параметры. Это становится проблемой, когда DLL экспортирует функции, так как экспортированные имена будут одинаковыми. Для разработчиков эта проблема решается с помощью библиотек и заголовочных файлов. На более низком уровне эта проблема решается путем искажения имен, чтобы они были уникальными. ВСЕ экспортированные имена функций C++ искажаются независимо от того, имеют ли они переопределения или нет.

Искажение функций также называется декорированием функций, что, вероятно, является более подходящим названием, просто не таким популярным. Хотя искаженные имена могут выглядеть как случайный мусор, в этом безумии есть свой метод. Вот пример искаженного имени функции: ??0?$_Yarn@D@std@@QEAA@PEBD@Z. Каким бы случайным оно ни казалось, его можно расшифровать. Расшифровав имя, вы можете найти тип функции и типы параметров. Разные компиляторы используют разные схемы искажения, в этой серии комнат все использует компилятор Microsoft C++ и схему искажения. Вам не нужно знать, как работают схемы, поскольку инструменты обратного проектирования могут их расшифровать, но если хотите, вот несколько ссылок.

Схема искажения Microsoft C++: http://mearie.org/documents/mscmangle/
Еще больше схем искажения: https://en.wikipedia.org/wiki/Name_mangling

Примечание для программистов. Размещение extern "C"перед функцией заставляет ее использовать C-связь, тем самым устраняя искажение имени. Это не позволяет вам перегружать функцию.

Запуск DLL
При обратном проектировании DLL вы можете захотеть запустить ее, чтобы проанализировать в отладчике. Это представляет собой очевидную проблему, вы не можете просто запустить DLL. Вот немного больше подробностей о том, как работают DLL.

При загрузке DLL функция DllMain() выполняется в контексте процесса, загружающего DLL . Здесь DLL может выполнять любой код, который захочет.

Вы, возможно, слышали о внедрении DLL , это один из способов, которым это можно сделать. Вы можете заставить целевой процесс вызвать LoadLibrary() в вашей DLL , что приведет к выполнению DllMain() в вашей DLL в контексте целевого процесса.

В Windows есть программа rundll32.exe, которая делает примерно то же самое: она просто загружает вашу DLL, заставляя DllMain() выполняться. Как разработчик, вы можете заставить rundll32.exe выполнять функции внутри DLL, но я не думаю, что кто-то это делает.

Для реверс-инженеров, что, если мы хотим динамически проанализировать функцию в DLL? Лучший способ сделать это — написать свой собственный код, который вызывает интересующую вас функцию. Без библиотеки или заголовочного файла вот один способ (вероятно, есть более элегантный способ), которым вы можете вызвать функцию в DLL, используя только файл .dll. Это не включает обработку ошибок, это только интересующий нас код. Это вызов функции Add() в DLL с именем DLL . DLL :

HMODULE dll = LoadLibraryA("DLL.DLL");
typedef void(WINAPI* Add_TypeDef)(int, int); // Add(int x, int y)
Add_TypeDef Add = (Add_TypeDef)GetProcAddress(dll, "Add_MangledName");
Add(1, 2);
Если у вас нет заголовочного или библиотечного файла, вам, скорее всего, придется выполнить обратную разработку функции, чтобы выяснить, какие параметры ей передаются.

Вот и все, что касается DLL, поскольку в остальном они ничем не отличаются от исполняемых файлов с точки зрения обратного проектирования.

### Ответьте на вопросы ниже
DLL — это исполняемый файл в простом режиме.

```commandline
Ответ не нужен
```

## Задание 8
Это базовое практическое введение в обратную разработку Windows, надеюсь, вам понравилось! Надеюсь, теперь, когда вы увидели это и имели возможность попрактиковаться, вы чувствуете себя более уверенно с программным обеспечением для обратной разработки. В следующей комнате мы, наконец, займемся настоящей обратной разработкой, взглянув на набор функций, экспортируемых NTDLL. Это будет довольно сложным шагом, но я думаю, что это будет отличным способом обучения. Для тех, кому интересно, мы затем применим наши знания для написания кода, который использует функции. Поверьте мне, когда я говорю, что обратная разработка может быть немного утомительной для изучения, но она становится гораздо интереснее, когда вы, наконец, понимаете, что делаете, и можете начать исследовать ее самостоятельно.

Вот несколько мест, где вы можете узнать больше об IDA:

https://www.youtube.com/playlist?list=PLKwUZp9HwWoDDBPvoapdbJ1rdofowT67z
https://www.youtube.com/watch?v=tt15P5Om3Zg
https://hex-rays.com/products/ida/tech/flirt/in_length/
Если у вас есть время, я бы рекомендовал взглянуть на Ghidra, а если вы планируете остаться на Windows, то на x64dbg. Ghidra — отличная альтернатива IDA, просто не такая зрелая. Самое приятное в Ghidra по сравнению с IDA — это цена. Ghidra бесплатна, IDA дорогая. До сих пор мы использовали IDA Freeware, которая великолепна, но имеет некоторые серьезные ограничения. При бесплатной цене Ghidra поддерживает множество архитектур и написана на Java, поэтому работает практически на чем угодно. Ее декомпилятор довольно хорош, хотя я думаю, что декомпилятор IDA лучше.

Увидимся в следующей комнате!

### Ответьте на вопросы ниже
Идите вперед и творите великие дела!
```commandline
Ответ не нужен
```
[>> вернуться на главную страницу](https://github.com/BEPb/tryhackme/blob/master/README.md)