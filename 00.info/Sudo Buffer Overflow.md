
[>> вернуться на главную страницу](https://github.com/BEPb/tryhackme/blob/master/README.md)

# Комната [Sudo Buffer Overflow](https://tryhackme.com/r/room/sudovulnsbof) 

Всего 2 задания:
## Задание 1
Для развертывания этой виртуальной машины вы должны быть подключены к сети TryHackMe с помощью файла конфигурации 
OpenVPN. Если вы не знаете, как это сделать, сначала быстро загляните в  комнату OpenVPN  . 

После подключения нажмите зеленую кнопку «Развернуть», чтобы запустить экземпляр машины, и мы можем приступить к работе!

( Обратите внимание, что полная загрузка виртуальных машин может занять несколько минут)

Для входа в машину вы будете использовать SSH. В Linux это делается из терминала командой, которая выглядит так:
```commandline
ssh -p <port-number> <username>@<remote-machine-ip>
```

В Windows вы обычно используете программное обеспечение, например  PuTTY . Затем вы входите в систему следующим образом:



Какой бы метод вы ни использовали, вас попросят ввести пароль, который после ввода позволит вам удаленно выполнять 
команды на машине. Учетные данные будут предоставлены позже в комнате. 

### Ответить на вопросы ниже
Развернуто!
```commandline
Ответ не нужен
```

## Задание 2
CVE -2019-18634 на момент написания статьи является последним предложением от Джо Венникса — того самого парня, 
который предоставил нам уязвимость обхода безопасности, которую мы использовали в комнате обхода безопасности. Эта 
уязвимость немного более технична, она использует атаку переполнения буфера для получения прав root. Она была 
исправлена, но влияет на версии sudo до 1.8.26.

### Давайте немного разберемся.

В комнате Security Bypass я кратко упомянул, что вы можете добавлять вещи в  /etc/sudoers файл, чтобы предоставить 
пользователям с низкими привилегиями дополнительные разрешения. Для этого эксплойта нас больше интересует один из 
других доступных вариантов: в частности, вариант под названием  pwfeedback. Этот вариант чисто эстетический и обычно 
отключен по умолчанию (за исключением ElementaryOS и Linux Mint — хотя они, скорее всего, также перестанут его 
использовать). Если вы раньше использовали Linux, то вы могли заметить, что пароли, введенные в терминал, обычно 
вообще не выводятся;  pwfeedback это делает так, что всякий раз, когда вы вводите символ, на экране отображается 
звездочка. Внутри файла  /etc/sudoers он указан следующим образом:

Вот в чем подвох. Когда эта опция включена, можно выполнить  атаку переполнения буфера  на команду sudo. Если 
объяснить это совсем просто, когда программа принимает ввод от пользователя, она сохраняет данные в установленном 
размере пространства для хранения. Атака переполнения буфера происходит, когда вы вводите так много данных во 
входные данные, что они выливаются из этого пространства для хранения в следующий «ящик», перезаписывая данные в нем.
Что касается нас, это означает, что если мы заполним поле пароля команды sudo большим количеством мусора,  мы 
сможем внедрить туда наши собственные вещи в конце. Это может означать, что мы получим оболочку как root! Этот 
эксплойт работает независимо от того, есть ли у нас какие-либо разрешения sudo изначально, в отличие от CVE 
-2019-14287, где нам изначально нужно было иметь очень определенный набор разрешений.

### Вот доказательство концепции:
В этой команде мы используем язык программирования Perl для генерации большого количества информации, которую затем 
передаем в команду sudo в качестве пароля с помощью |оператора pipe ( ). Обратите внимание, что это на самом деле не 
дает нам прав root — вместо этого мы видим сообщение об ошибке:  Segmentation fault, что по сути означает, что мы 
попытались получить доступ к некоторой памяти, к которой мы не должны были иметь доступа. Это доказывает, что 
существует уязвимость переполнения буфера: теперь нам просто нужно ею воспользоваться!

Конкретный эксплойт, который мы собираемся использовать, был написан Салимом Рашидом (@saleemrash1d).

Это программа, написанная на языке C, которая эксплуатирует CVE-2019-18634. На самом деле атаки BOF значительно 
сложнее, чем в объяснении выше, поэтому мы не будем вдаваться в подробности того, что именно делает программа, но вы 
можете себе представить, что она делает то же самое, что и в объяснении: заполняет поле пароля мусорной информацией, 
а затем перезаписывает что-то более важное, что находится в следующем «ящике», кодом, который дает нам root-shell.

Я уже загрузил скомпилированную копию кода в VM , так что все, что вам нужно сделать, это запустить ее. Следующий 
раздел интересен (и полезен, если вам когда-нибудь понадобится использовать эту программу для CTF или другого 
хакерского испытания), но не обязателен для завершения комнаты. Это процесс, который вы бы использовали, если бы вы 
скачали и скомпилировали программу для себя:

- Сначала вы загружаете программу (в данном случае я делал  wget это в терминале). Исходный код можно найти на  github 
Салима, так что если вам интересно, я настоятельно рекомендую прочитать код, чтобы увидеть, что он делает! 
- Далее вы компилируете программу. Я использовал gcc для компиляции эксплойта: 
```commandline
gcc -o <output-file> <source-file>
```
- Обратите внимание, что в каталоге есть два файла — файл синего цвета с именем,  exploit который является нашим 
  скомпилированным исполняемым файлом, и файл белого цвета с именем,  exploit.c который является исходным файлом. 
Затем вам нужно загрузить файл на целевую машину и запустить его:


Как я уже сказал ранее, я уже сделал компиляцию и загрузку для вас. Все, что вам нужно сделать, это войти в систему 
и запустить эксплойт, просто чтобы увидеть, как он работает. 

### Теперь твоя очередь.

Подключитесь по SSH к машине, которую вы развернули ранее, используя порт 4444 .

Учетные данные следующие:

Имя пользователя:  tryhackme
Пароль:  tryhackme

Если вы используете Linux , команда будет выглядеть так:
```commandline
ssh -p 4444 tryhackme@MACHINE_IP
```

### Ответить на вопросы ниже
Используйте предварительно скомпилированный эксплойт в виртуальной машине, чтобы получить root-оболочку.
```commandline
Ответ не нужен
```
Какой флаг в /root/root.txt?
```commandline
THM{buff3r_0v3rfl0w_rul3s}
```

[>> вернуться на главную страницу](https://github.com/BEPb/tryhackme/blob/master/README.md)