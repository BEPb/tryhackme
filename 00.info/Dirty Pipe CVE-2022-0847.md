 

[>> вернуться на главную страницу](https://github.com/BEPb/tryhackme/blob/master/README.md)

# Комната [Dirty Pipe: CVE-2022-0847](https://tryhackme.com/r/room/dirtypipe) 

Всего 5 заданий:
## Задание 1
В марте 2022 года исследователь по имени Макс Келлерман публично раскрыл уязвимость ядра Linux (прозванную «Dirty 
Pipe» из-за ее сходства с печально известным эксплойтом « Dirty Cow », влияющим на старые версии ядра), которая 
позволяла злоумышленникам произвольно перезаписывать файлы в операционной системе. Уязвимость была ответственно 
раскрыта в начале 2022 года и была публично опубликована в сообщении в блоге, написанном Максом Келлерманом вскоре 
после того, как были доступны исправления.

Произвольные перезаписи файлов на уровне ядра могут быть очень легко использованы для повышения привилегий на машине 
(т. е. для получения привилегий администратора или "root"). Это разрушительная уязвимость, которая становится еще 
более опасной из-за ее распространения: все устройства, работающие под управлением уязвимой версии ядра Linux 
(включая телефоны Android), подвержены этой уязвимости!   

В этой комнате будет представлен обзор уязвимости, а также предоставлена возможность самостоятельно 
эксплуатировать ее на уязвимой машине, прикрепленной к этой задаче. Мы начнем с обзора уязвимости и эксплуатируем ее 
на высоком уровне, прежде чем перейти к эксплуатации уязвимости в последующих разделах комнаты.  

Без лишних слов, начнем.
Ответить на вопросы ниже
Разверните машину, нажав на зеленую кнопку «Развернуть» в верхней части этой задачи!

```commandline
Ответ не нужен
```

## Задание 2
#### Обзор

Из-за их низкоуровневой природы любое глубокое обсуждение уязвимостей ядра быстро становится довольно сложным. Таким 
образом, мы сделаем информацию в этой задаче относительно легкой, в интересах сохранения информации легкой для 
усвоения. Если вы хотите прочитать подробное объяснение уязвимости (включая полный анализ кода), вам настоятельно 
рекомендуется ознакомиться с оригинальной записью в блоге Макса Келлермана .   

Прежде чем продолжить выполнение этой задачи, важно отметить, что Dirty Pipe была исправлена в версиях ядра  Linux 
5.16.11, 5.15.25 и 5.10.102, поэтому, если вы используете или управляете какими-либо устройствами Linux (или Android)
, убедитесь, что они работают под управлением ядра более новой версии, чем одна из этих версий!  

#### Теория

Чтобы понять, как работает Dirty Pipe, мы должны сначала рассмотреть, как ядро Linux управляет памятью.

Наименьшая единица памяти, контролируемая ЦП , называется страницей — в современных системах они обычно имеют размер 
около 4 КБ. В этой теме страницы используются при чтении и записи файлов с диска, хотя у них есть и множество других 
применений. Часть ядра, которая управляет страницами, называется кэшем страниц .  

Когда процесс пытается открыть файл, ядро загружает его в страницы, которые затем становятся доступными для процесса 
пользовательского пространства. Этот доступ к пользовательскому пространству может быть предоставлен либо путем 
копирования в память пользовательского пространства, либо путем сохранения страниц в пространстве ядра, но 
предоставления к ним доступа через системные вызовы (фактически специальные функции, которые используются для 
взаимодействия с ядром).    

Хорошо, так какое отношение это имеет к Dirty Pipe? Уязвимость возникает из-за того, как ядро реализует "каналы".

Вы, вероятно, знакомы с идеей «анонимных каналов» — они представлены в большинстве языков сценариев оболочки и 
позволяют передавать данные между двумя процессами, обычно с помощью символа канала (| ). Каналы характеризуются тем,
что имеют два конца — один для чтения и один для записи; вы можете увидеть это сами по тому, как анонимные каналы 
берут стандартный вывод процесса и записывают его в канал, где он может быть прочитан стандартным вводом следующей 
программы в цепочке.

Возвращаясь к теме: ядро Linux предоставляет системный вызов под названием " splice()", который фактически является 
сокращением, предназначенным для ускорения процесса помещения содержимого файла в конвейер. Эта оптимизация 
достигается путем перемещения ссылок на страницы, хранящие содержимое файла, а не перемещением всех данных. Другими 
словами, splice()позволяет нам указать конвейер на страницу, которая уже загружена в память и содержит раздел файла, 
изначально открытого процессом, запрашивающим доступ только для чтения. Видите, к чему это идет?

Вставив страницу в канал, а затем записав в канал наши собственные произвольные данные, мы можем перезаписать 
содержимое страницы! 

Однако не все так просто; нам все еще не хватает одного последнего кусочка головоломки. Обычно, когда вы пишете в 
канал после сплайсинга файла, pipe_bufferсоздается новый, чтобы избежать перезаписи сплайсированных данных. Итак, 
как заставить ядро разрешить нам перезаписывать соответствующие страницы?  

Вот в чем суть уязвимости, и ее можно проследить до двух изменений в ядре Linux :

В Linux Kernel v4.9 (2016) была введена ошибка , которая позволяла создавать каналы с произвольными флагами. Ни один 
из доступных в то время флагов не был каким-либо образом опасен, поэтому это не было проблемой, пока...
В Linux Kernel v5.8 (2020) добавлен новый флаг —PIPE_BUF_FLAG_CAN_MERGE . Проще говоря, этот флаг сообщает ядру, 
что страницу можно обновить без принудительной перезаписи данных.
Подведем итог: у нас есть флаг, который позволяет нам сообщить ядру, что перезаписывать данные на странице можно, у 
нас есть ошибка, которая позволяет нам указывать произвольные флаги для канала, и у нас есть системный вызов, 
который непреднамеренно позволяет нам указывать каналы на буферы страниц, которые были открыты только для чтения. 
Что может пойти не так?

Проще говоря, эксплойт сначала открывает целевой файл с установленным флагом «только для чтения» — чтобы сделать это,
мы должны выбрать файл, на чтение которого у нас есть разрешение. Затем эксплойт подготавливает канал особым образом,
принудительно добавляя флаг. PIPE_BUF_FLAG_CAN_MERGEЗатем он использует , splice()чтобы канал указывал на нужный 
раздел целевого файла. Наконец, он записывает любые произвольные данные, которые указал пользователь, в канал, 
перезаписывая целевую страницу в соответствии с флагом PIPE_BUF_FLAG_CAN_MERGE.

Эффекты

Итак, что же все это значит?

Короче говоря, это означает, что с правильным кодом мы можем произвольно перезаписать любой файл в системе, при 
условии, что мы можем открыть его для чтения. Другими словами: если наш пользователь имеет доступ на чтение к файлу 
(независимо от других разрешений или изменчивости), то мы также можем записывать в него. Интересно, что это также 
применимо к файловым системам только для чтения или иным образом защищенным файлам, в которые ядро обычно не 
позволяет нам записывать; эксплуатируя уязвимость ядра и обходя «обычные» методы записи, мы также обходим эти защиты.
Важно отметить, что изменения на самом деле не будут постоянными, пока ядро не решит вернуть память, используемую 
страницей (в этот момент страница сбрасывается на диск). Перезапуск устройства или очистка кэша страницы вручную до 
того, как ядро вернет память, вернет файл к его первоначальному содержимому.

#### Рекомедиации

К счастью, устранить эту уязвимость очень просто: обновить ядро.

Были выпущены исправленные версии ядра Linux для поддерживаемых основных версий ядра — в частности, уязвимость была 
исправлена в версиях ядра Linux 5.16.11, 5.15.25 и 5.10.102 .

Обязательно устанавливайте обновления на все свои устройства Linux (включая Android) сразу после выпуска исправлений 
безопасности.

Ответить на вопросы ниже
Прочитайте информацию в задании и поймите, как работает Dirty Pipe.

```commandline
Ответ не нужен
```

## Задание 3
#### Подключение к цели

Доступ к этой лаборатории можно получить двумя способами:

- Используя машину в браузере на правой стороне экрана. Это должно было появиться автоматически, когда вы развернули 
цель.
- Используя SSH с локальной атакующей машины или TryHackMe AttackBox. Учетные данные для этого следующие:

Имя пользователя: tryhackme
Пароль: TryHackMe123!
т.е.ssh tryhackme@MACHINE_IP
Выберите метод и достигните цели самостоятельно!


#### Эксплойт

В предыдущем задании мы рассмотрели предысторию эксплойта и как он работает. В этом задании мы будем эксплуатировать 
уязвимость для себя! 

Копию оригинального кода эксплойта доказательства концепции Макса Келлермана (первоначально найденного в сообщении 
блога раскрытия) можно найти на целевой машине по адресу . После компиляции этот эксплойт дает нам большой контроль 
над тем, как мы злоупотребляем уязвимостью Dirty Pipe. В частности, он позволяет нам указать файл, который мы хотим 
перезаписать, смещение, по которому мы хотим его перезаписать, и содержимое, которое мы хотим вставить. Мы получим 
каждую из этих вещей в следующих параграфах. В конце задания будет предоставлен интерактивный видеоклип, чтобы 
помочь с пониманием и отладкой шагов, описанных в следующих разделах./home/tryhackme/Exploit/PoC/poc.c

Учитывая, что эксплойт не позволит нам создавать файлы (мы можем только перезаписывать информацию в существующих 
файлах), нам сначала нужно найти файл, который наш пользователь может прочитать , но который все еще позволяет нам 
повысить наши привилегии. Очевидный простой выбор в этих условиях — /etc/passwd. Хотя хэши паролей обычно хранятся в 
ограниченном доступе /etc/shadowв современных системах Linux (в отличие от традиционного хранения в /etc/passwd), 
большинство вариантов Linux все еще проверяют, указаны ли хэши паролей учетных записей в /etc/passwd. Это означает, 
что мы можем записать пользователя с правами root и известным хэшем пароля непосредственно в файл passwd!

Примечание: Если вы знакомы с повышением привилегий из-за /etc/passwd файла, доступного для записи, перейдите к 
следующему абзацу — в противном случае щелкните поле ниже, чтобы узнать больше об этой методике.

#### Дополнительные знания: Файл Passwd (нажмите, чтобы прочитать)
Давайте сгенерируем хэш пароля и сформируем допустимую запись passwd, прежде чем двигаться дальше. Выберите пароль, 
затем используйте команду openssl для создания хеша SHA512Crypt выбранного вами пароля: 

Генерация хеша SHA512Crypt
```commandline
tryhackme@dirty-pipe:~$ openssl passwd -6 --salt THM "PASSWORD"
$6$THM$eRD0Ur0SZuwDLSwf9Lb2vyC2T6/PtQUA/B0Ssm6/jsiBtpSvc6QLjhFF0XNM8odgfkxMnC4oczGuvEomrVRfz0
```
Наконец, вставьте свое имя пользователя и хэш в этот шаблон записи пароля: USERNAME:HASH:0:0::/root:/bin/bash.

Ваша запись должна выглядеть примерно так:
```commandline
muiri:$6$THM$eRD0Ur0SZuwDLSwf9Lb2vyC2T6/PtQUA/B0Ssm6/jsiBtpSvc6QLjhFF0XNM8odgfkxMnC4oczGuvEomrVRfz0:0:0::/root:/bin/bash
```

Примечание: пароль: TryHackMe123!был использован для генерации примера хеша выше.

Поскольку мы перезаписываем существующие записи в файле паролей, нам также необходимо добавить новую строку в конце 
нашей записи. Это гарантирует, что мы не повредим нашу запись остатками предыдущего содержимого строки. 

Таким образом, наш окончательный контент должен выглядеть примерно так (включая цитаты):
```commandline
'muiri:$6$THM$eRD0Ur0SZuwDLSwf9Lb2vyC2T6/PtQUA/B0Ssm6/jsiBtpSvc6QLjhFF0XNM8odgfkxMnC4oczGuvEomrVRfz0:0:0::/root:/bin/bash
'
```


У нас есть наш файл ( /etc/passwd) и наше содержимое (запись passwd) — все, что нам нужно сейчас, это смещение . 
Смещение — это то место в файле, где эксплойт должен начать запись — другими словами, какая часть файла будет 
перезаписана.  

Уязвимость не позволит нам добавить файл, поэтому нам придется выбрать учетную запись и перезаписать ее. Реалистично 
говоря, учитывая длину нашей записи passwd (включая хэш), это, вероятно, фактически перезапишет несколько учетных 
записей. Просматривая файл passwd, games учетная запись выделяется как хороший кандидат на роль малоиспользуемой 
учетной записи, которую мы можем позволить себе уничтожить на несколько минут. Мы можем использовать grepс -b 
переключателем, чтобы найти смещение games от начала файла:    

Нахождение смещения
```
tryhackme@dirty-pipe:~ $ grep -b "игры" /etc/passwd
 189 :игры:x:5:60:игры:/usr/игры:/usr/sbin/nologin
```
Смещение оказывается равным 189, что дает нам последний фрагмент нашей головоломки.

Мы наконец-то готовы к работе!

Программу можно скомпилировать с помощью следующих команд:

Команда компиляции
```commandline
tryhackme@dirty-pipe:~$ cd ~/Exploit/PoC
tryhackme@dirty-pipe:~/Exploit/PoC$ gcc poc.c -o exploit
tryhackme@dirty-pipe:~/Exploit/PoC$ ls
poc.c  exploit
```
Это переместит вас в каталог, содержащий код эксплойта, а затем скомпилирует его с помощью gcc.

Прежде чем мы выполним эксплойт, очень важно сделать резервную копию /etc/passwd файла. Это разрушительный эксплойт, 
который нанесет ущерб системе (по крайней мере на некоторое время); с резервной копией файла passwd мы можем легко 
устранить ущерб после того, как эксплойт будет завершен.  

Используйте cp /etc/passwd /tmp/passwd для копирования файла passwd в /tmp, а затем запустите эксплойт!

Ваша команда должна выглядеть примерно так:

Выполнение эксплойта
```commandline
tryhackme@dirty-pipe:~/Exploit/PoC$ ./exploit /etc/passwd 189 'USERNAME:HASH:0:0::/root:/bin/bash
> '

```
Весь процесс, описанный в этом задании, продемонстрирован в видеоролике ниже:

Ответить на вопросы ниже
Выполните шаги, описанные в задании, если вы еще этого не сделали.

```commandline
Ответ не нужен
```

Переключите пользователя ( su) на недавно созданную учетную запись root.

Какой флаг найден в /root/flag.txt файле?
```commandline
THM{MmU4Zjg0NDdjNjFiZWM5ZjUyZGEyMzlm}
```

Как упоминалось ранее, мы случайно перезаписали другие учетные записи пользователей, эксплуатируя Dirty Pipe таким 
образом. Это может вызвать проблемы на сервере; поэтому, как профессионалы, мы должны убрать после наших эксплойтов. 

Используя root-оболочку, восстановите исходный /etc/passwd файл из резервной копии.

```commandline
Ответ не нужен
```

## Задание 4
#### Обзор

В предыдущей задаче мы эксплуатировали уязвимость Dirty Pipe, используя оригинальный код эксплойта доказательства 
концепции Макса Келлермана; однако с тех пор были выпущены и другие эксплойты. Оригинальный PoC позволял нам 
перезаписывать любой файл произвольными данными со смещением по нашему выбору; однако другие реализации 
злоупотребляли уязвимостью произвольной записи файла различными способами.

Для демонстрации этой концепции в лабораторную машину был добавлен второй скрипт эксплойта — его можно найти на цели 
по адресу /home/tryhackme/Exploit/Bl4sty/dirtypipez.c. Как следует из структуры каталогов, эта реализация была 
закодирована @bl4sty , исследователем безопасности, которого вы можете помнить, если уже прошли комнату « SudoVulns: 
Baron Samedit ». Исходный код эксплойта можно загрузить с веб-сайта bl4sty здесь ; однако, как упоминалось ранее, 
копия уже была добавлена в лабораторную машину.  

Этот эксплойт переводит произвольную запись файла на один этап дальше, злоупотребляя довольно особым качеством 
уязвимости. Программы SUID обычно теряют свой бит SUID, когда вы пытаетесь записать в них; однако этого не 
происходит с Dirty Pipe — другими словами, мы можем записывать в любую программу, которая имеет разрешение на 
выполнение с более высокими привилегиями, не уничтожая непреднамеренно это дополнительное разрешение (как это обычно происходит).   

Эксплойт Bl4sty извлекает выгоду из этого. Вместо того, чтобы перезаписывать файл типа /etc/passwd, он 
перезаписывает указанный пользователем двоичный файл SUID (например, /bin/su), внедряя в него шеллкод, который затем 
выполняется с разрешениями привилегированного пользователя (т. е. root). В частности, эксплойт захватывает выбранный 
двоичный файл SUID и заставляет его создать двоичный файл бэкдора, в  /tmp котором есть бит SUID и вызывает /bin/sh. 
Затем он восстанавливает целевой двоичный файл SUID до полностью рабочего состояния, повторно добавляя 
перезаписанный раздел, и использует недавно созданный бэкдор, чтобы предоставить злоумышленнику оболочку в качестве 
привилегированного пользователя.      



#### Эксплуатация

Прежде чем продолжить выполнение этой задачи, убедитесь, что вы вышли из сеанса как пользователь root. Вам следует 
снова выполнять команды в контексте пользователя tryhackme. 

Как tryhackmeпользователь, скомпилируйте эксплойт, используя тот же синтаксис, который был указан в предыдущем 
задании, например: 

Команда компиляции
```commandline
tryhackme@dirty-pipe:~/Exploit/Bl4sty$ gcc dirtypipez.c -o exploit
tryhackme@dirty-pipe:~/Exploit/Bl4sty$ ls
dirtypipez.c  exploit
```

После компиляции эксплойта его следует запустить с одним аргументом, указывающим целевой двоичный файл, 
принадлежащий пользователю root и с установленным битом SUID, например: ./exploit /bin/su. 

Теперь у вас снова должна быть корневая оболочка!

Ответить на вопросы ниже
Эксплуатируйте цель, используя эксплойт bl4sty для Dirty Pipe
```commandline
Ответ не нужен
```

Обязательно убирайте за собой!

Удалите двоичный файл SUID, созданный скриптом ( /tmp/sh).

```commandline
Ответ не нужен
```
[Необязательно] Найдите другой эксплойт для этой уязвимости в сети. Проверьте код, чтобы убедиться, что он делает то,
что заявлено, затем загрузите его на цель и попытайтесь эксплуатировать уязвимость третьим способом. 

```commandline
Ответ не нужен
```

## Задание 5
Поздравляем, вы достигли конца комнаты «Грязная труба»!

Надеюсь, что после завершения этой комнаты вы получите общее представление об уязвимости и сможете уверенно 
использовать две из многочисленных реализаций эксплойтов, нацеленных на нее. 

Если вы хотите более подробно рассмотреть CVE-2022-0847, вам рекомендуется прочитать (очень подробную) запись в 
блоге , опубликованную Максом Келлерманом, ссылка на которую приведена ранее в этом выпуске. 

Ответить на вопросы ниже
Я понимаю уязвимость Dirty Pipe!

```commandline
Ответ не нужен
```

[>> вернуться на главную страницу](https://github.com/BEPb/tryhackme/blob/master/README.md)