[>> вернуться на главную страницу](https://github.com/BEPb/tryhackme/blob/master/README.md)

# Комната [Learn & win prizes - Fall 2022](https://tryhackme.com/r/room/tickets3) 

Всего 6 заданий:
## Задание 1
Добро пожаловать в комнату Burp Suite Repeater!
В этой комнате мы рассмотрим расширенные возможности фреймворка Burp Suite, сосредоточившись на модуле Burp Suite 
Repeater. Опираясь на базовые знания, полученные в комнате Burp Basics, мы углубимся в мощные функции инструмента 
Repeater. Вы узнаете, как манипулировать и повторно отправлять захваченные запросы, и мы рассмотрим различные опции 
и функции, доступные в этом исключительном модуле. На протяжении всей комнаты мы будем приводить практические 
примеры, включая реальные упражнения, чтобы закрепить ваше понимание обсуждаемых концепций.

Если вы новичок в Burp Suite или не закончили комнату Burp Basics, мы рекомендуем сделать это перед продолжением. 
Комната Burp Basics дает основные знания, необходимые для этой комнаты, и улучшит ваш опыт обучения.

Разверните целевую виртуальную машину, прикрепленную к этой задаче, нажав зеленую кнопку Start Machine. Также 
запустите AttackBox, нажав синюю кнопку Start AttackBox в верхней части этой комнаты, если вы не используете свою 
собственную машину. Затем запустите Burp и следуйте следующим задачам.
```commandline
Ответ не нужен
```

## Задание 2
Что такое репитер?
Прежде чем использовать Burp Suite Repeater, давайте ознакомимся с его назначением и функционалом.
По сути, Burp Suite Repeater позволяет нам изменять и повторно отправлять перехваченные запросы на выбранную нами 
цель. Он позволяет нам брать запросы, захваченные в Burp Proxy, и манипулировать ими, отправляя их повторно по мере 
необходимости. В качестве альтернативы мы можем вручную создавать запросы с нуля, аналогично использованию 
инструмента командной строки, например cURL.   

Возможность многократного редактирования и повторной отправки запросов делает Repeater бесценным инструментом для 
ручного исследования и тестирования конечных точек. Он предоставляет удобный графический интерфейс для создания 
полезных нагрузок запросов и предлагает различные представления ответа, включая механизм рендеринга для графического 
представления.   

Интерфейс повторителя состоит из шести основных разделов, как показано на аннотированной схеме

Демонстрация примера запроса в burp suite repeater

Список запросов : Расположен в левом верхнем углу вкладки, отображает список запросов Repeater. Можно управлять 
несколькими запросами одновременно, и каждый новый запрос, отправленный в Repeater, будет отображаться здесь. 

Элементы управления запросами : эти элементы управления расположены непосредственно под списком запросов и позволяют 
отправлять запросы, отменять зависшие запросы и перемещаться по истории запросов. 

Вид запроса и ответа : Занимая большую часть интерфейса, этот раздел отображает виды запроса и ответа . Мы можем 
редактировать запрос в виде запроса, а затем пересылать его, в то время как соответствующий ответ будет показан в 
виде ответа.  

Параметры макета : Расположенные в правом верхнем углу представления «Запрос/Ответ», эти параметры позволяют нам 
настраивать макет представлений «Запрос» и «Ответ». Настройка по умолчанию — макет «бок о бок» (горизонтальный), но 
мы также можем выбрать вертикальный макет или объединить их в отдельных вкладках.  

Inspector : Расположенный справа, Inspector позволяет нам анализировать и изменять запросы более интуитивно, чем при 
использовании редактора raw. Мы рассмотрим эту функцию в более поздней задаче. 

Target : Расположенное над Inspector, поле Target указывает IP-адрес или домен, на который отправляются запросы. 
Когда запросы отправляются в Repeater из других компонентов Burp Suite , это поле заполняется автоматически. 

Ответить на вопросы ниже

Какие разделы дают нам более интуитивный контроль над нашими запросами?
```commandline
Inspector
```

## Задание 3
На данный момент мы знаем, как выглядит интерфейс приложения, но как мы можем эффективно его использовать?

Хотя ручное создание запроса является опцией, более распространенной практикой является захват запроса с помощью 
модуля Proxy и последующая его передача в Repeater для дальнейшего редактирования и повторной отправки. 

После того, как запрос был захвачен в модуле Proxy , мы можем отправить его в Repeater, щелкнув правой кнопкой мыши 
по запросу и выбрав « Отправить в Repeater» или используя сочетание клавиш Ctrl + R. 

Возвращаясь к Repeater, мы можем заметить, что наш захваченный запрос теперь доступен в представлении Request:


Разделы Target и Inspector теперь отображают соответствующую информацию, хотя в настоящее время у нас нет ответа. 
После нажатия кнопки Send быстро заполняется вид Response: 

Вид ответа быстро заполняется

Если мы хотим изменить какой-либо аспект запроса, мы можем просто ввести текст в поле Request и нажать Send еще раз. 
Это действие соответствующим образом обновит поле Response справа. Например, изменение заголовка Connection на 
"open" вместо "close" даст ответ с заголовком Connection , содержащим значение "keep-alive":  

заголовок, содержащий значение keep-alive

Кроме того, мы можем использовать кнопки истории, расположенные справа от кнопки «Отправить», для навигации по 
истории изменений, что позволяет нам перемещаться вперед или назад по мере необходимости. 

Ответить на вопросы ниже
Какое представление будет заполнено при отправке запроса из модуля Proxy в Repeater?

```commandline
Request
```

## Задание 4
Repeater предоставляет нам различные варианты представления запросов и ответов: от шестнадцатеричного вывода до 
полностью отрисованной страницы. 

Чтобы изучить эти возможности, мы можем обратиться к разделу, расположенному над полем ответа, где доступны 
следующие четыре кнопки просмотра: 

Четыре кнопки над полем ответа

Нам представлены следующие варианты отображения:

1. Pretty : это параметр по умолчанию, который берет необработанный ответ и применяет небольшие улучшения 
форматирования для улучшения читабельности.

2. Raw : этот параметр отображает неизмененный ответ, полученный напрямую от сервера, без какого-либо дополнительного 
форматирования.

3. Hex : выбрав этот вид, мы можем изучить ответ в представлении на уровне байтов, что особенно полезно при работе с 
двоичными файлами.

4. Render : опция render позволяет нам визуализировать страницу так, как она будет выглядеть в веб-браузере. Хотя она 
нечасто используется в Repeater, поскольку мы обычно фокусируемся на исходном коде, она все равно предлагает ценную 
   функцию. Для большинства сценариев опция Pretty обычно достаточна. Однако полезно ознакомиться с использованием 
   трех других опций.  

Рядом с кнопками просмотра, с правой стороны, мы находим кнопку Показать непечатаемые символы ( \n). Эта функция 
позволяет отображать символы, которые могут быть не видны с параметрами Pretty или Raw . Например, каждая строка в 
ответе обычно заканчивается символами \r\n, представляющими возврат каретки, за которым следует новая строка. Эти 
символы играют важную роль в интерпретации заголовков HTTP .   

Хотя этот вариант не является обязательным для большинства задач, в определенных ситуациях он может оказаться полезным.
```commandline
Render
```

## Задание 5
Inspector — это дополнительная функция к представлениям Request и Response в модуле Repeater. Он также используется 
для получения визуально организованной разбивки запросов и ответов, а также для экспериментов, чтобы увидеть, как 
изменения, внесенные с помощью Inspector более высокого уровня, влияют на эквивалентные необработанные версии.  

Inspector может использоваться как в модуле Proxy , так и в модуле Repeater. В обоих случаях он расположен в крайней 
правой части окна, представляя список компонентов в запросе и ответе: 

Среди этих компонентов разделы, относящиеся к запросу, обычно могут быть изменены, что позволяет добавлять, 
редактировать и удалять элементы. Например, в разделе Атрибуты запроса мы можем изменить элементы, связанные с 
местоположением, методом и протоколом запроса. Это включает в себя изменение желаемого ресурса для извлечения, 
изменение метода HTTP с GET на другой вариант или переключение протокола с HTTP /1 на HTTP /2:   

Переключение протокола с HTTP/1 на HTTP/2

Другие разделы, доступные для просмотра и/или редактирования, включают:

Параметры запроса: они относятся к данным, отправленным на сервер через URL. Например, в запросе GET типа 
https://admin.tryhackme.com/?redirect=false, параметр запроса redirect имеет значение "false". 
Параметры тела запроса: Аналогично параметрам запроса, но специфично для запросов POST. Любые данные, отправленные 
как часть запроса POST, будут отображены в этом разделе, что позволит нам изменить параметры перед повторной отправкой.
Запросить файлы cookie: этот раздел содержит изменяемый список файлов cookie, отправляемых с каждым запросом.
Заголовки запросов: позволяет нам просматривать, получать доступ и изменять (включая добавление или удаление) любые 
заголовки, отправленные с нашими запросами. Редактирование этих заголовков может быть полезным при изучении того, 
как веб-сервер реагирует на неожиданные заголовки.
Заголовки ответа: В этом разделе отображаются заголовки, возвращаемые сервером в ответ на наш запрос. Его нельзя 
изменить, так как мы не контролируем заголовки, возвращаемые сервером. Обратите внимание, что этот раздел 
становится видимым только после отправки запроса и получения ответа.
Хотя текстовое представление этих компонентов можно найти в представлениях «Запрос» и «Ответ», табличный формат 
Inspector обеспечивает удобный способ визуализации и взаимодействия с ними. Эксперименты с добавлениями, удалениями 
и правками заголовков в Inspector помогают понять, как соответствующая сырая версия изменяется в ответе.

Ответить на вопросы ниже
Какой раздел в Inspector относится только к запросам POST?

```commandline
Body Parameters
```

## Задание 6
Repeater особенно хорошо подходит для задач, требующих повторной отправки похожих запросов, как правило, с 
небольшими изменениями. Это особенно полезно для таких действий, как ручное тестирование уязвимостей SQL Injection 
(которые будут рассмотрены в предстоящей задаче), попытка обойти фильтры брандмауэра веб-приложений или настройка 
параметров в отправке формы.   

Начнем с очень простого примера: использование Repeater для изменения заголовков запроса, отправляемого получателю.

Захватите запрос http://MACHINE_IP/в модуле Proxy и отправьте его в Repeater.

Отправьте запрос один раз из Repeater  —  в представлении «Ответ» вы должны увидеть исходный HTML-код запрошенной 
вами страницы. 

Попробуйте просмотреть это в одном из других вариантов отображения (например, Hex).

Используя Inspector (или вручную, если вам так удобнее), добавьте заголовок с именем FlagAuthorised и задайте для 
него значение True, как показано ниже: 

Ответить на вопросы ниже
Какой флаг вы получите?

```commandline
THM{Yzg2MWI2ZDhlYzdlNGFiZTUzZTIzMzVi}
```

## Задание 7
В предыдущем задании мы продемонстрировали использование Repeater, добавив заголовок и отправив запрос. Это 
послужило наглядным примером использования Repeater. Теперь пришло время для простого испытания! 

Для начала убедитесь, что перехват отключен в вашем модуле Proxy и перейдите к http://MACHINE_IP/products/. Затем 
попробуйте нажать на некоторые из ссылок See More . 

Обратите внимание, что вы перенаправлены на числовую конечную точку (например, /products/3).

Цель состоит в том, чтобы проверить конечную точку, подтвердив существование числа, к которому вы хотите перейти, и 
убедившись, что это действительное целое число. Однако подумайте, что может произойти, если эта конечная точка не 
будет должным образом проверена.  

Ответить на вопросы ниже

Включите перехват еще раз и перехватите запрос к одной из конечных точек числовых продуктов в модуле Proxy, затем перешлите его в Repeater.
```commandline
Ответ не требуется
```

Попробуйте заставить сервер выдать ошибку с кодом «500 Внутренняя ошибка сервера», изменив число в конце запроса на 
экстремальные входные данные. 

Какой флаг вы получаете при возникновении ошибки 500 в конечной точке?

```commandline
THM{N2MzMzFhMTA1MmZiYjA2YWQ4M2ZmMzhl}
```

## Задание 8
Вызов на сверхмили

Это задание предназначено для проверки ваших навыков в немного более сложном реальном сценарии с использованием Burp 
Repeater. Если вы обладаете опытом самостоятельного выполнения ручного SQL- инъекта, вы можете перейти к последнему 
вопросу и попробовать выполнить его вслепую. Тем не менее, ниже будет предоставлено подробное пошаговое руководство, 
если вам требуется руководство.   

Необходимые знания
Прежде чем приступить к этой задаче, рекомендуется ознакомиться с принципами SQL-инъекции. Если вы еще этого не 
сделали, пожалуйста, рассмотрите возможность изучения комнаты SQL- инъекции , посвященной этой теме. Хотя будет 
предоставлено подробное пошаговое руководство, наличие базового понимания принципов SQL- инъекции будет полезным при 
выполнении этой задачи.   

### Цель задачи
Ваша цель в этом задании — выявить и использовать уязвимость Union SQL Injection, присутствующую в параметре ID 
/about/ID конечной точки. Используя эту уязвимость, ваша задача — запустить атаку, чтобы получить заметки о 
генеральном директоре, хранящиеся в базе данных.  

### Прохождение
Мы знаем, что есть уязвимость, и мы знаем, где она находится. Теперь нам просто нужно ее эксплуатировать!

Давайте начнем с захвата запроса http://MACHINE_IP/about/2в Burp Proxy . После захвата запроса отправьте его в 
Repeater с помощью Ctrl + R или щелкнув правой кнопкой мыши и выбрав «Отправить в Repeater». 

Теперь, когда наш запрос готов, давайте подтвердим, что уязвимость существует. Добавления одного апострофа ( ') 
обычно достаточно, чтобы сервер выдал ошибку, когда присутствует простой SQLi, поэтому, либо используя Inspector, 
либо отредактировав путь запроса вручную, добавьте апостроф после "2" в конце пути и отправьте запрос:  


Вы должны увидеть, что сервер отвечает сообщением «500 Internal Server Error», что означает, что мы успешно прервали запрос:

Если мы посмотрим на текст ответа сервера, то увидим нечто очень интересное примерно в строке 40. Сервер сообщает 
нам запрос, который мы пытались выполнить: 

Это чрезвычайно полезное сообщение об ошибке, которое сервер ни в коем случае не должен нам отправлять, но тот факт, 
что оно у нас есть, значительно упрощает нашу работу. 

В сообщении содержится несколько сведений, которые окажутся бесценными при эксплуатации этой уязвимости:

Таблица базы данных, из которой мы выбираем, называется people.
Запрос выбирает пять столбцов из таблицы: firstName, lastName, pfpLink, role, и bio. Мы можем предположить, где они 
располагаются на странице, что будет полезно при выборе места размещения наших запросов. 
Имея эту информацию, мы можем пропустить шаги перечисления номеров столбцов запроса и имен таблиц.
Хотя нам удалось исключить большую часть необходимого перечисления, нам все еще нужно найти имя нашего целевого столбца.

Поскольку нам известно имя таблицы и количество строк, мы можем использовать запрос на объединение, чтобы выбрать 
имена столбцов для people таблицы из columns таблицы в information_schema базе данных по умолчанию. 

Простой запрос для этого выглядит следующим образом:
/about/0 UNION ALL SELECT column_name,null,null,null,null FROM information_schema.columns WHERE table_name="people"

Это создает запрос на объединение и выбирает нашу цель, затем четыре пустых столбца (чтобы избежать ошибки запроса). 
Обратите внимание, что мы также изменили идентификатор, из которого мы выбираем, 2на 0. Установив идентификатор на 
недопустимое число, мы гарантируем, что не получим ничего с исходным (законным) запросом; это означает, что первая 
строка, возвращенная из базы данных, будет нашим желаемым ответом на внедренный запрос.   

Мы успешно вытащили первое имя столбца из базы данных, но теперь у нас есть проблема. Страница отображает только 
первый соответствующий элемент  —  нам нужно увидеть все соответствующие элементы. 

К счастью, мы можем использовать наш SQLi для группировки результатов. Мы по-прежнему можем извлекать только один 
результат за раз, но с помощью функции group_concat() мы можем объединить все имена столбцов в один вывод:
/about/0 UNION ALL SELECT group_concat(column_name),null,null,null,null FROM information_schema.columns WHERE table_name="people"

Этот процесс показан ниже:

названия таблиц в заголовке

Мы успешно идентифицировали восемь столбцов в этой таблице: id, firstName, lastName, pfpLink, role, shortRole, bioи notes.

Принимая во внимание нашу задачу, можно с уверенностью сказать, что нашим целевым столбцом является notes.

Наконец, мы готовы взять флаг из этой базы данных — у нас есть вся необходимая информация:

Название таблицы: people.
Имя целевого столбца: notes.
Идентификатор генерального директора — 1; его можно узнать, просто нажав на профиль Джеймсона Вульфа на 
/about/странице и проверив идентификатор в URL-адресе.
Давайте создадим запрос для извлечения этого флага:
0 UNION ALL SELECT notes,null,null,null,null FROM people WHERE id = 1

Вуаля, у нас есть флаг!

флаг из базы данных

Ответить на вопросы ниже
Использовать уязвимость Union SQL-инъекции на сайте.
флаг?

```commandline
THM{ZGE3OTUyZGMyMzkwNjJmZjg3Mzk1NjJh}
```

## Задание 9
Поздравляем с завершением комнаты Burp Suite Repeater!

К настоящему моменту у вас должно быть четкое понимание эффективного использования Repeater для редактирования, 
манипулирования и повторной отправки запросов. Кроме того, вы должны были получить представление о многочисленных 
практических применениях этого инструмента.  

В следующей комнате модуля мы рассмотрим модуль Burp Suite Intruder. Intruder позволяет проводить автоматизированные 
и настраиваемые атаки, что делает его мощным инструментом для различных сценариев тестирования безопасности. 

Удачи в следующей комнате и наслаждайтесь исследованием возможностей Burp Suite Intruder !

Ответить на вопросы ниже
Я могу использовать Burp Suite Repeater!
```commandline
Ответ не нужен
```

[>> вернуться на главную страницу](https://github.com/BEPb/tryhackme/blob/master/README.md)